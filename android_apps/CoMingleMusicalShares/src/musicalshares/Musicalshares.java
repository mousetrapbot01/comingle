package musicalshares;

import java.io.Serializable;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.Calendar;

import comingle.goals.*;
import comingle.store.*;
import comingle.facts.*;
import comingle.rewrite.*;
import comingle.hash.*;
import comingle.tuple.*;
import comingle.misc.*;
import comingle.mset.*;
import comingle.actuation.*;
import comingle.lib.*;
import comingle.pretty.*;

import comingle.lib.ExtLib;

import musicalshares.lib.CommLib;




/**
**  
** Generated by Comingle: Distributed Logic Programming for Decentralized Mobile Ensembles
** Visit https://github.com/sllam/comingle for more information.
** Or contact us:      
**      Edmund Lam          sllam@qatar.cmu.edu
**      Iliano Cervesato    iliano@cmu.edu
**
**/

/**
** This Comingle Runtime is generated from the following Comingle specifications:
ensem musicalshares {

	module comingle.lib.ExtLib import {
		size :: {B} -> int.
		length :: [E] -> int.
		uncons :: [D] -> (D,[D]).
		addSeconds :: (time,int) -> time.
		diff :: ({A},{A}) -> {A}.
		pick :: ({A},int) -> {A}.
		mset :: [C] -> {C}.
	}

	module musicalshares.lib.CommLib import {
		decideTargets :: (loc,{loc}) -> {loc}.
	}

	predicate distribute :: ([string],{loc},{(loc,loc)}) -> trigger.
	predicate start      :: time -> trigger.

	predicate all        :: {loc} -> fact.
	predicate src        :: loc -> fact.
	predicate edge       :: loc -> fact.
	predicate transScore :: (loc,[string],int) -> fact.
	predicate note  :: (string,int) -> fact.
	predicate fire  :: time -> fact.
	predicate playLog :: (string,time) -> fact.

	predicate refresh :: actuator.
	predicate play    :: (string,time) -> actuator.
	predicate completed :: actuator.

	predicate reset :: trigger.
	predicate empty :: fact.

	export query note(_,_).
	export query playLog(_,_).

	rule dist :: [I]distribute(Ns,Vs,Es) --o { [X]edge(Y),[X]edge(Y) | (X,Y)<-Es }, [I]all(Vs), 
                                                 { [V]src(I) | V<-Vs }, [I]transScore(I,Ns,0).

	rule fwd :: { [X]edge(Y) | Y->Ys } \ [X]transScore(Z,Ns,P) | (size(diff(Ys,{Z})))>0, (length(Ns)) > 0 
                        --o [X]note(M,P), [X]refresh(), { [W]transScore(X,Ms,P+1) | W<-Ws }
                            where (M,Ms) = uncons(Ns),
                                  Ws = diff(Ys,{Z}).

	rule ret :: { [X]edge(Y) | Y->Ys } \ [X]transScore(Z,Ns,P) | (size(diff(Ys,{Z})))==0, (length(Ns)) > 0
                        --o [X]note(M,P), [X]refresh(), [Z]transScore(X,Ms,P+1)
                            where (M,Ms) = uncons(Ns).

	rule end :: [X]src(I) \ [X]transScore(_,Ns,_) | (length(Ns))==0 --o [I]completed().

	rule start :: [X]all(Ls) \ [X]start(T) --o { [L]fire(T) | L<-Ls }.

	rule note :: [X]fire(Tn) \ [X]note(M,P), { [X]note(M,P) } --o [X]play(M,Tm), [X]playLog(M,Tm) where Tm = addSeconds(Tn,P).

	rule clear :: [I]all(Ls), [I]reset() --o { [L]empty() | L<-Ls }.

	rule empty :: [X]empty(), { [X]playLog(_,_) }, { [X]edge(_) }, { [X]src(_) }, { [X]fire(_) } --o 1.

}
**/


public class Musicalshares extends RewriteMachine {

	public class Actuations {
		public static final String refresh = "refresh";
		public static final String play = "play";
		public static final String completed = "completed";
		public static final String delay = "delay";
		public static final String beep = "beep";
		public static final String toast = "toast";
	}

	abstract class MusicalsharesFact extends Fact {
		public MusicalsharesFact(int l) { super(l); }
		public void execute(Musicalshares ensem) { }
		public void intro(Musicalshares ensem) { }
	}

	public class Distribute extends MusicalsharesFact {
		public LinkedList<String>  arg1;
		public SimpMultiset<Integer>  arg2;
		public SimpMultiset<Tuple2<Integer,Integer> >  arg3;
	
		public Distribute(int l, LinkedList<String>  a1, SimpMultiset<Integer>  a2, SimpMultiset<Tuple2<Integer,Integer> >  a3) { super(l); arg1=a1; arg2=a2; arg3=a3; }
	
		public int fact_idx() { return 0; }
	
		@Override
		public void execute(Musicalshares ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Musicalshares ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1, (Serializable) arg2, (Serializable) arg3 };
			return new SerializedFact(loc, 0, arguments);
		}
	
		public String toString() { return String.format("[%s]Distribute(%s,%s,%s)",loc,arg1,arg2,arg3); }
	
	}
	
	public class Start extends MusicalsharesFact {
		public long arg1;
	
		public Start(int l, long a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 1; }
	
		@Override
		public void execute(Musicalshares ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Musicalshares ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 1, arguments);
		}
	
		public String toString() { return String.format("[%s]Start(%s)",loc,PrettyPrinter.prettyTime(arg1)); }
	
	}
	
	public class All extends MusicalsharesFact {
		public SimpMultiset<Integer>  arg1;
	
		public All(int l, SimpMultiset<Integer>  a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 2; }
	
		@Override
		public void execute(Musicalshares ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Musicalshares ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 2, arguments);
		}
	
		public String toString() { return String.format("[%s]All(%s)",loc,arg1); }
	
	}
	
	public class Src extends MusicalsharesFact {
		public int arg1;
	
		public Src(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 3; }
	
		@Override
		public void execute(Musicalshares ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Musicalshares ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 3, arguments);
		}
	
		public String toString() { return String.format("[%s]Src(%s)",loc,arg1); }
	
	}
	
	public class Edge extends MusicalsharesFact {
		public int arg1;
	
		public Edge(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 4; }
	
		@Override
		public void execute(Musicalshares ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Musicalshares ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 4, arguments);
		}
	
		public String toString() { return String.format("[%s]Edge(%s)",loc,arg1); }
	
	}
	
	public class TransScore extends MusicalsharesFact {
		public int arg1;
		public LinkedList<String>  arg2;
		public int arg3;
	
		public TransScore(int l, int a1, LinkedList<String>  a2, int a3) { super(l); arg1=a1; arg2=a2; arg3=a3; }
	
		public int fact_idx() { return 5; }
	
		@Override
		public void execute(Musicalshares ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Musicalshares ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1, (Serializable) arg2, (Serializable) arg3 };
			return new SerializedFact(loc, 5, arguments);
		}
	
		public String toString() { return String.format("[%s]TransScore(%s,%s,%s)",loc,arg1,arg2,arg3); }
	
	}
	
	public class Note extends MusicalsharesFact {
		public String arg1;
		public int arg2;
	
		public Note(int l, String a1, int a2) { super(l); arg1=a1; arg2=a2; }
	
		public int fact_idx() { return 6; }
	
		@Override
		public void execute(Musicalshares ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Musicalshares ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1, (Serializable) arg2 };
			return new SerializedFact(loc, 6, arguments);
		}
	
		public String toString() { return String.format("[%s]Note(%s,%s)",loc,arg1,arg2); }
	
	}
	
	public class Fire extends MusicalsharesFact {
		public long arg1;
	
		public Fire(int l, long a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 7; }
	
		@Override
		public void execute(Musicalshares ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Musicalshares ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 7, arguments);
		}
	
		public String toString() { return String.format("[%s]Fire(%s)",loc,PrettyPrinter.prettyTime(arg1)); }
	
	}
	
	public class PlayLog extends MusicalsharesFact {
		public String arg1;
		public long arg2;
	
		public PlayLog(int l, String a1, long a2) { super(l); arg1=a1; arg2=a2; }
	
		public int fact_idx() { return 8; }
	
		@Override
		public void execute(Musicalshares ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Musicalshares ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1, (Serializable) arg2 };
			return new SerializedFact(loc, 8, arguments);
		}
	
		public String toString() { return String.format("[%s]PlayLog(%s,%s)",loc,arg1,PrettyPrinter.prettyTime(arg2)); }
	
	}
	
	public class Refresh extends MusicalsharesFact {
		
	
		public Refresh(int l) { super(l); }
	
		public int fact_idx() { return 9; }
	
		@Override
		public void execute(Musicalshares ensem) { ensem.invokeActuator("refresh",Tuples.make_unit()); }
	
		@Override
		public void intro(Musicalshares ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = {  };
			return new SerializedFact(loc, 9, arguments);
		}
	
		public String toString() { return String.format("[%s]Refresh()",loc); }
	
	}
	
	public class Play extends MusicalsharesFact {
		public String arg1;
		public long arg2;
	
		public Play(int l, String a1, long a2) { super(l); arg1=a1; arg2=a2; }
	
		public int fact_idx() { return 10; }
	
		@Override
		public void execute(Musicalshares ensem) { ensem.invokeActuator("play",Tuples.make_tuple(arg1,arg2)); }
	
		@Override
		public void intro(Musicalshares ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1, (Serializable) arg2 };
			return new SerializedFact(loc, 10, arguments);
		}
	
		public String toString() { return String.format("[%s]Play(%s,%s)",loc,arg1,PrettyPrinter.prettyTime(arg2)); }
	
	}
	
	public class Completed extends MusicalsharesFact {
		
	
		public Completed(int l) { super(l); }
	
		public int fact_idx() { return 11; }
	
		@Override
		public void execute(Musicalshares ensem) { ensem.invokeActuator("completed",Tuples.make_unit()); }
	
		@Override
		public void intro(Musicalshares ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = {  };
			return new SerializedFact(loc, 11, arguments);
		}
	
		public String toString() { return String.format("[%s]Completed()",loc); }
	
	}
	
	public class Reset extends MusicalsharesFact {
		
	
		public Reset(int l) { super(l); }
	
		public int fact_idx() { return 12; }
	
		@Override
		public void execute(Musicalshares ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Musicalshares ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = {  };
			return new SerializedFact(loc, 12, arguments);
		}
	
		public String toString() { return String.format("[%s]Reset()",loc); }
	
	}
	
	public class Empty extends MusicalsharesFact {
		
	
		public Empty(int l) { super(l); }
	
		public int fact_idx() { return 13; }
	
		@Override
		public void execute(Musicalshares ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Musicalshares ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = {  };
			return new SerializedFact(loc, 13, arguments);
		}
	
		public String toString() { return String.format("[%s]Empty()",loc); }
	
	}
	
	public class Delay extends MusicalsharesFact {
		public int arg1;
	
		public Delay(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 14; }
	
		@Override
		public void execute(Musicalshares ensem) { ensem.invokeActuator("delay",arg1); }
	
		@Override
		public void intro(Musicalshares ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 14, arguments);
		}
	
		public String toString() { return String.format("[%s]Delay(%s)",loc,arg1); }
	
	}
	
	public class Beep extends MusicalsharesFact {
		public String arg1;
	
		public Beep(int l, String a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 15; }
	
		@Override
		public void execute(Musicalshares ensem) { ensem.invokeActuator("beep",arg1); }
	
		@Override
		public void intro(Musicalshares ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 15, arguments);
		}
	
		public String toString() { return String.format("[%s]Beep(%s)",loc,arg1); }
	
	}
	
	public class Toast extends MusicalsharesFact {
		public String arg1;
	
		public Toast(int l, String a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 16; }
	
		@Override
		public void execute(Musicalshares ensem) { ensem.invokeActuator("toast",arg1); }
	
		@Override
		public void intro(Musicalshares ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 16, arguments);
		}
	
		public String toString() { return String.format("[%s]Toast(%s)",loc,arg1); }
	
	}
	

	protected static int index0Start(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0All(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0Src(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0Edge(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0TransScore(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0Note(int loc, String arg1, int arg2) {
		return Hash.join(Hash.hash(loc),Hash.hash(arg1),Hash.hash(arg2));
	}
	protected static int index1Note(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0Fire(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0PlayLog(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0Reset(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0Empty(int loc) {
		return Hash.hash(loc);
	}

	protected static final int distribute_fact_idx = 0;
	protected static final int start_fact_idx = 1;
	protected static final int all_fact_idx = 2;
	protected static final int src_fact_idx = 3;
	protected static final int edge_fact_idx = 4;
	protected static final int transscore_fact_idx = 5;
	protected static final int note_fact_idx = 6;
	protected static final int fire_fact_idx = 7;
	protected static final int playlog_fact_idx = 8;
	protected static final int refresh_fact_idx = 9;
	protected static final int play_fact_idx = 10;
	protected static final int completed_fact_idx = 11;
	protected static final int reset_fact_idx = 12;
	protected static final int empty_fact_idx = 13;
	protected static final int delay_fact_idx = 14;
	protected static final int beep_fact_idx = 15;
	protected static final int toast_fact_idx = 16;

	protected Goals<MusicalsharesFact> goals;

	protected ListStore<Distribute> distribute_store_0;
	protected MultiMapStore<Start> start_store_0;
	protected ListStore<Start> start_store_1;
	protected MultiMapStore<All> all_store_0;
	protected ListStore<All> all_store_1;
	protected MultiMapStore<Src> src_store_0;
	protected ListStore<Src> src_store_1;
	protected MultiMapStore<Edge> edge_store_0;
	protected ListStore<Edge> edge_store_1;
	protected MultiMapStore<TransScore> transscore_store_0;
	protected ListStore<TransScore> transscore_store_1;
	protected MultiMapStore<Note> note_store_0;
	protected MultiMapStore<Note> note_store_1;
	protected ListStore<Note> note_store_2;
	protected ConcListStore<Note> note_store_3;
	protected MultiMapStore<Fire> fire_store_0;
	protected ListStore<Fire> fire_store_1;
	protected MultiMapStore<PlayLog> playlog_store_0;
	protected ListStore<PlayLog> playlog_store_1;
	protected ConcListStore<PlayLog> playlog_store_2;
	protected MultiMapStore<Reset> reset_store_0;
	protected ListStore<Reset> reset_store_1;
	protected MultiMapStore<Empty> empty_store_0;
	protected ListStore<Empty> empty_store_1;

	protected int dist_rule_count;
	protected int fwd_rule_count;
	protected int ret_rule_count;
	protected int end_rule_count;
	protected int start_rule_count;
	protected int note_rule_count;
	protected int clear_rule_count;
	protected int empty_rule_count;
	protected int rule_app_misses;

	public Musicalshares() {
		super();
	
		dist_rule_count = 0;
		fwd_rule_count = 0;
		ret_rule_count = 0;
		end_rule_count = 0;
		start_rule_count = 0;
		note_rule_count = 0;
		clear_rule_count = 0;
		empty_rule_count = 0;
		rule_app_misses = 0;
	
		goals = new ListGoals<MusicalsharesFact>();
		set_goal_component( goals );
	
		distribute_store_0 = new ListStore<Distribute>();
		distribute_store_0.set_name("Distribute Store");
		// set_store_component( distribute_store_0 );
		
		start_store_0 = new MultiMapStore<Start>();
		start_store_0.set_name("Start Store");
		// set_store_component( start_store_0 );
		
		start_store_1 = new ListStore<Start>();
		start_store_1.set_name("Start Store");
		// set_store_component( start_store_1 );
		
		all_store_0 = new MultiMapStore<All>();
		all_store_0.set_name("All Store");
		// set_store_component( all_store_0 );
		
		all_store_1 = new ListStore<All>();
		all_store_1.set_name("All Store");
		// set_store_component( all_store_1 );
		
		src_store_0 = new MultiMapStore<Src>();
		src_store_0.set_name("Src Store");
		// set_store_component( src_store_0 );
		
		src_store_1 = new ListStore<Src>();
		src_store_1.set_name("Src Store");
		// set_store_component( src_store_1 );
		
		edge_store_0 = new MultiMapStore<Edge>();
		edge_store_0.set_name("Edge Store");
		// set_store_component( edge_store_0 );
		
		edge_store_1 = new ListStore<Edge>();
		edge_store_1.set_name("Edge Store");
		// set_store_component( edge_store_1 );
		
		transscore_store_0 = new MultiMapStore<TransScore>();
		transscore_store_0.set_name("TransScore Store");
		// set_store_component( transscore_store_0 );
		
		transscore_store_1 = new ListStore<TransScore>();
		transscore_store_1.set_name("TransScore Store");
		// set_store_component( transscore_store_1 );
		
		note_store_0 = new MultiMapStore<Note>();
		note_store_0.set_name("Note Store");
		// set_store_component( note_store_0 );
		
		note_store_1 = new MultiMapStore<Note>();
		note_store_1.set_name("Note Store");
		// set_store_component( note_store_1 );
		
		note_store_2 = new ListStore<Note>();
		note_store_2.set_name("Note Store");
		// set_store_component( note_store_2 );
		
		note_store_3 = new ConcListStore<Note>();
		note_store_3.set_name("Note Store");
		// set_store_component( note_store_3 );
		
		fire_store_0 = new MultiMapStore<Fire>();
		fire_store_0.set_name("Fire Store");
		// set_store_component( fire_store_0 );
		
		fire_store_1 = new ListStore<Fire>();
		fire_store_1.set_name("Fire Store");
		// set_store_component( fire_store_1 );
		
		playlog_store_0 = new MultiMapStore<PlayLog>();
		playlog_store_0.set_name("PlayLog Store");
		// set_store_component( playlog_store_0 );
		
		playlog_store_1 = new ListStore<PlayLog>();
		playlog_store_1.set_name("PlayLog Store");
		// set_store_component( playlog_store_1 );
		
		playlog_store_2 = new ConcListStore<PlayLog>();
		playlog_store_2.set_name("PlayLog Store");
		// set_store_component( playlog_store_2 );
		
		reset_store_0 = new MultiMapStore<Reset>();
		reset_store_0.set_name("Reset Store");
		// set_store_component( reset_store_0 );
		
		reset_store_1 = new ListStore<Reset>();
		reset_store_1.set_name("Reset Store");
		// set_store_component( reset_store_1 );
		
		empty_store_0 = new MultiMapStore<Empty>();
		empty_store_0.set_name("Empty Store");
		// set_store_component( empty_store_0 );
		
		empty_store_1 = new ListStore<Empty>();
		empty_store_1.set_name("Empty Store");
		// set_store_component( empty_store_1 );
		
	
		set_store_component( distribute_store_0 );
		set_store_component( start_store_1 );
		set_store_component( all_store_1 );
		set_store_component( src_store_1 );
		set_store_component( edge_store_1 );
		set_store_component( transscore_store_1 );
		set_store_component( note_store_3 );
		set_store_component( fire_store_1 );
		set_store_component( playlog_store_2 );
		set_store_component( reset_store_1 );
		set_store_component( empty_store_1 );
	}
	

	@Override
	protected boolean rewrite() {
		boolean done_something = false;
		while(goals.has_goals()) {
			goals.next().execute( this );
			done_something = true;
		}
		return done_something;
	}
	
	@Override
	protected boolean rewrite(int max_steps) {
		int count = 0;
		while(goals.has_goals() && count < max_steps) {
			goals.next().execute( this );
			count++;
		}
		return count > 0;
	}

	protected MusicalsharesFact demultiplex(SerializedFact fact) {
		Serializable[] args = fact.arguments;
		switch(fact.fact_idx) {
			case 0: return new Distribute(fact.loc,(LinkedList<String> ) args[0],(SimpMultiset<Integer> ) args[1],(SimpMultiset<Tuple2<Integer,Integer> > ) args[2]);
			
			case 1: return new Start(fact.loc,(Long) args[0]);
			
			case 2: return new All(fact.loc,(SimpMultiset<Integer> ) args[0]);
			
			case 3: return new Src(fact.loc,(Integer) args[0]);
			
			case 4: return new Edge(fact.loc,(Integer) args[0]);
			
			case 5: return new TransScore(fact.loc,(Integer) args[0],(LinkedList<String> ) args[1],(Integer) args[2]);
			
			case 6: return new Note(fact.loc,(String) args[0],(Integer) args[1]);
			
			case 7: return new Fire(fact.loc,(Long) args[0]);
			
			case 8: return new PlayLog(fact.loc,(String) args[0],(Long) args[1]);
			
			case 9: return new Refresh(fact.loc);
			
			case 10: return new Play(fact.loc,(String) args[0],(Long) args[1]);
			
			case 11: return new Completed(fact.loc);
			
			case 12: return new Reset(fact.loc);
			
			case 13: return new Empty(fact.loc);
			
			case 14: return new Delay(fact.loc,(Integer) args[0]);
			
			case 15: return new Beep(fact.loc,(String) args[0]);
			
			case 16: return new Toast(fact.loc,(String) args[0]);
			
		}
		return null;
	}
	
	
	@Override
	protected synchronized boolean flushGoals() {
		if (external_goals.size() == 0) { return false; }
		for (SerializedFact new_goal : external_goals) {
			MusicalsharesFact ef_goal = demultiplex( new_goal );
			ef_goal.intro( this ) ;
		}
		external_goals.clear();
		return true;
	}
	
	protected void store(Distribute distribute) {
		distribute_store_0.add( distribute );
	} 				
	
	protected void store(Start start) {
		start_store_0.add( start, index0Start(start.loc) );
		start_store_1.add( start );
	} 				
	
	protected void store(All all) {
		all_store_0.add( all, index0All(all.loc) );
		all_store_1.add( all );
	} 				
	
	protected void store(Src src) {
		src_store_0.add( src, index0Src(src.loc) );
		src_store_1.add( src );
	} 				
	
	protected void store(Edge edge) {
		edge_store_0.add( edge, index0Edge(edge.loc) );
		edge_store_1.add( edge );
	} 				
	
	protected void store(TransScore transscore) {
		transscore_store_0.add( transscore, index0TransScore(transscore.loc) );
		transscore_store_1.add( transscore );
	} 				
	
	protected void store(Note note) {
		note_store_0.add( note, index0Note(note.loc,note.arg1,note.arg2) );
		note_store_1.add( note, index1Note(note.loc) );
		note_store_2.add( note );
		note_store_3.add( note );
	} 				
	
	protected void store(Fire fire) {
		fire_store_0.add( fire, index0Fire(fire.loc) );
		fire_store_1.add( fire );
	} 				
	
	protected void store(PlayLog playlog) {
		playlog_store_0.add( playlog, index0PlayLog(playlog.loc) );
		playlog_store_1.add( playlog );
		playlog_store_2.add( playlog );
	} 				
	
	protected void store(Refresh refresh) {
		
	} 				
	
	protected void store(Play play) {
		
	} 				
	
	protected void store(Completed completed) {
		
	} 				
	
	protected void store(Reset reset) {
		reset_store_0.add( reset, index0Reset(reset.loc) );
		reset_store_1.add( reset );
	} 				
	
	protected void store(Empty empty) {
		empty_store_0.add( empty, index0Empty(empty.loc) );
		empty_store_1.add( empty );
	} 				
	
	protected void store(Delay delay) {
		
	} 				
	
	protected void store(Beep beep) {
		
	} 				
	
	protected void store(Toast toast) {
		
	} 				
	
	public void add_distribute(int loc,LinkedList<String>  arg1,SimpMultiset<Integer>  arg2,SimpMultiset<Tuple2<Integer,Integer> >  arg3) {
		if (isSolo || location == loc) {
			intro( new Distribute(loc,arg1,arg2,arg3) );
		}
	}
	
	public void add_start(int loc,long arg1) {
		if (isSolo || location == loc) {
			intro( new Start(loc,arg1) );
		}
	}
	
	public void add_all(int loc,SimpMultiset<Integer>  arg1) {
		if (isSolo || location == loc) {
			intro( new All(loc,arg1) );
		}
	}
	
	public void add_src(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new Src(loc,arg1) );
		}
	}
	
	public void add_edge(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new Edge(loc,arg1) );
		}
	}
	
	public void add_transscore(int loc,int arg1,LinkedList<String>  arg2,int arg3) {
		if (isSolo || location == loc) {
			intro( new TransScore(loc,arg1,arg2,arg3) );
		}
	}
	
	public void add_note(int loc,String arg1,int arg2) {
		if (isSolo || location == loc) {
			intro( new Note(loc,arg1,arg2) );
		}
	}
	
	public void add_fire(int loc,long arg1) {
		if (isSolo || location == loc) {
			intro( new Fire(loc,arg1) );
		}
	}
	
	public void add_playlog(int loc,String arg1,long arg2) {
		if (isSolo || location == loc) {
			intro( new PlayLog(loc,arg1,arg2) );
		}
	}
	
	public void add_refresh(int loc) {
		if (isSolo || location == loc) {
			intro( new Refresh(loc) );
		}
	}
	
	public void add_play(int loc,String arg1,long arg2) {
		if (isSolo || location == loc) {
			intro( new Play(loc,arg1,arg2) );
		}
	}
	
	public void add_completed(int loc) {
		if (isSolo || location == loc) {
			intro( new Completed(loc) );
		}
	}
	
	public void add_reset(int loc) {
		if (isSolo || location == loc) {
			intro( new Reset(loc) );
		}
	}
	
	public void add_empty(int loc) {
		if (isSolo || location == loc) {
			intro( new Empty(loc) );
		}
	}
	
	public void add_delay(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new Delay(loc,arg1) );
		}
	}
	
	public void add_beep(int loc,String arg1) {
		if (isSolo || location == loc) {
			intro( new Beep(loc,arg1) );
		}
	}
	
	public void add_toast(int loc,String arg1) {
		if (isSolo || location == loc) {
			intro( new Toast(loc,arg1) );
		}
	}
	
	protected void intro(Distribute distribute) {
		goals.add( distribute );
		notify_new_goals();
	}
	
	protected void intro(Start start) {
		goals.add( start );
		notify_new_goals();
	}
	
	protected void intro(All all) {
		goals.add( all );
		notify_new_goals();
	}
	
	protected void intro(Src src) {
		goals.add( src );
		store( src );
		notify_new_goals();
	}	
	
	protected void intro(Edge edge) {
		goals.add( edge );
		store( edge );
		notify_new_goals();
	}	
	
	protected void intro(TransScore transscore) {
		goals.add( transscore );
		notify_new_goals();
	}
	
	protected void intro(Note note) {
		goals.add( note );
		store( note );
		notify_new_goals();
	}	
	
	protected void intro(Fire fire) {
		goals.add( fire );
		store( fire );
		notify_new_goals();
	}	
	
	protected void intro(PlayLog playlog) {
		goals.add( playlog );
		store( playlog );
		notify_new_goals();
	}	
	
	protected void intro(Refresh refresh) {
		goals.add( refresh );
		notify_new_goals();
	}
	
	protected void intro(Play play) {
		goals.add( play );
		notify_new_goals();
	}
	
	protected void intro(Completed completed) {
		goals.add( completed );
		notify_new_goals();
	}
	
	protected void intro(Reset reset) {
		goals.add( reset );
		notify_new_goals();
	}
	
	protected void intro(Empty empty) {
		goals.add( empty );
		notify_new_goals();
	}
	
	protected void intro(Delay delay) {
		goals.add( delay );
		store( delay );
		notify_new_goals();
	}	
	
	protected void intro(Beep beep) {
		goals.add( beep );
		store( beep );
		notify_new_goals();
	}	
	
	protected void intro(Toast toast) {
		goals.add( toast );
		store( toast );
		notify_new_goals();
	}	
	
	protected void send(Distribute distribute) {
		if(location == distribute.get_loc()) {
			intro(distribute);
		} else {
			send_buffers.add(distribute);
		}
	}
	
	protected void send(Start start) {
		if(location == start.get_loc()) {
			intro(start);
		} else {
			send_buffers.add(start);
		}
	}
	
	protected void send(All all) {
		if(location == all.get_loc()) {
			intro(all);
		} else {
			send_buffers.add(all);
		}
	}
	
	protected void send(Src src) {
		if(location == src.get_loc()) {
			intro(src);
		} else {
			send_buffers.add(src);
		}
	}
	
	protected void send(Edge edge) {
		if(location == edge.get_loc()) {
			intro(edge);
		} else {
			send_buffers.add(edge);
		}
	}
	
	protected void send(TransScore transscore) {
		if(location == transscore.get_loc()) {
			intro(transscore);
		} else {
			send_buffers.add(transscore);
		}
	}
	
	protected void send(Note note) {
		if(location == note.get_loc()) {
			intro(note);
		} else {
			send_buffers.add(note);
		}
	}
	
	protected void send(Fire fire) {
		if(location == fire.get_loc()) {
			intro(fire);
		} else {
			send_buffers.add(fire);
		}
	}
	
	protected void send(PlayLog playlog) {
		if(location == playlog.get_loc()) {
			intro(playlog);
		} else {
			send_buffers.add(playlog);
		}
	}
	
	protected void send(Refresh refresh) {
		if(location == refresh.get_loc()) {
			intro(refresh);
		} else {
			send_buffers.add(refresh);
		}
	}
	
	protected void send(Play play) {
		if(location == play.get_loc()) {
			intro(play);
		} else {
			send_buffers.add(play);
		}
	}
	
	protected void send(Completed completed) {
		if(location == completed.get_loc()) {
			intro(completed);
		} else {
			send_buffers.add(completed);
		}
	}
	
	protected void send(Reset reset) {
		if(location == reset.get_loc()) {
			intro(reset);
		} else {
			send_buffers.add(reset);
		}
	}
	
	protected void send(Empty empty) {
		if(location == empty.get_loc()) {
			intro(empty);
		} else {
			send_buffers.add(empty);
		}
	}
	
	protected void send(Delay delay) {
		if(location == delay.get_loc()) {
			intro(delay);
		} else {
			send_buffers.add(delay);
		}
	}
	
	protected void send(Beep beep) {
		if(location == beep.get_loc()) {
			intro(beep);
		} else {
			send_buffers.add(beep);
		}
	}
	
	protected void send(Toast toast) {
		if(location == toast.get_loc()) {
			intro(toast);
		} else {
			send_buffers.add(toast);
		}
	}
	
	

	public void addDistribute(LinkedList<String>  arg1,SimpMultiset<Integer>  arg2,SimpMultiset<Tuple2<Integer,Integer> >  arg3) {
		intro( new Distribute(location,arg1,arg2,arg3) );
	}
	
	public void addStart(long arg1) {
		intro( new Start(location,arg1) );
	}
	
	public void addReset() {
		intro( new Reset(location) );
	}
	

	public void setRefreshActuator(ActuatorAction<Unit> action) {
		setActuator("refresh", action);
	}
	
	public void setPlayActuator(ActuatorAction<Tuple2<String,Long>> action) {
		setActuator("play", action);
	}
	
	public void setCompletedActuator(ActuatorAction<Unit> action) {
		setActuator("completed", action);
	}
	
	public void setDelayActuator(ActuatorAction<Integer> action) {
		setActuator("delay", action);
	}
	
	public void setBeepActuator(ActuatorAction<String> action) {
		setActuator("beep", action);
	}
	
	public void setToastActuator(ActuatorAction<String> action) {
		setActuator("toast", action);
	}
	

	

	public ConcListStore<Note> get_note() {
		return note_store_3;
	}
	
	public ConcListStore<PlayLog> get_playlog() {
		return playlog_store_2;
	}
	

	public ConcListStore[] getLinearStores() {
		ConcListStore[] stores = new ConcListStore[2];
		stores[0] = this.get_note();
		stores[1] = this.get_playlog();
		return stores;
	}
	

	/*
	**** 0 Join Ordering of Rule dist ****
	Rule Head Variables: (I::0), (Ns::1), (Vs::2), (Es::3)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]distribute((Ns::1),(Vs::2),(Es::3))
	DeleteHead #H0
	LetBind (Lvar0::4) 0
	IntroAtom Local NoPrior Mono [(I::0)]all((Vs::2))
	IntroAtom Local NoPrior Mono [(I::0)]transScore((I::0),(Ns::1),(Lvar0::4))
	IntroCompre Remote NoPrior NonMono (X::6),(Y::5) (Es::3) [(X::6)]edge((Y::5))
	IntroCompre Remote NoPrior NonMono (V::7) (Vs::2) [(V::7)]src((I::0))
	*/
	protected boolean execute_distribute_join_ordering_1(Distribute act) {
		
		int i;
		LinkedList<String>  ns;
		SimpMultiset<Integer>  vs;
		SimpMultiset<Tuple2<Integer,Integer> >  es;
		int lvar0;
		int y;
		int x;
		int v;
		// Join Task: Active #H0 [(I::0)]distribute((Ns::1),(Vs::2),(Es::3))
		i = act.loc;
		ns = act.arg1;
		vs = act.arg2;
		es = act.arg3;
		// Join Task: DeleteHead #H0
		// H0 is active and monotone, no delete required
		// Join Task: LetBind (Lvar0::4) 0
		lvar0 = 0;
		;
		// Join Task: IntroAtom Local NoPrior Mono [(I::0)]all((Vs::2))
		intro( new All(i,vs) );
		// Join Task: IntroAtom Local NoPrior Mono [(I::0)]transScore((I::0),(Ns::1),(Lvar0::4))
		intro( new TransScore(i,i,ns,lvar0) );
		// Join Task: IntroCompre Remote NoPrior NonMono (X::6),(Y::5) (Es::3) [(X::6)]edge((Y::5))
		SimpMultiset<Tuple2<Integer,Integer> >  comp_0 = es;
		for(int idx=0; idx<comp_0.size(); idx++) {
			Tuple2<Integer,Integer>  tup0;
			tup0 = comp_0.get(idx);
			x = tup0.t1;
			y = tup0.t2;
			send( new Edge(x,y) ); 
			send( new Edge(x,y) ); 
		}
		// Join Task: IntroCompre Remote NoPrior NonMono (V::7) (Vs::2) [(V::7)]src((I::0))
		SimpMultiset<Integer>  comp_1 = vs;
		for(int idx=0; idx<comp_1.size(); idx++) {
			v = comp_1.get(idx);
			send( new Src(v,i) ); 
		}
		dist_rule_count++;
		return false;
		
	}
	
	/*
	**** 0 Join Ordering of Rule start ****
	Rule Head Variables: (X::0), (Ls::1), (T::2)
	Rule Head Compre Binders: 
	Active #H0 [(X::0)]start((T::2))
	LookupAtom #H1 2:0:hash<[+]all(-)|.>  (X::0) [(X::0)]all((Ls::1))
	DeleteHead #H0
	IntroCompre Remote NoPrior NonMono (L::3) (Ls::1) [(L::3)]fire((T::2))
	*/
	protected boolean execute_start_join_ordering_1(Start act) {
		
		int x;
		SimpMultiset<Integer>  ls;
		long t;
		int l;
		// Join Task: Active #H0 [(X::0)]start((T::2))
		x = act.loc;
		t = act.arg1;
		// Join Task: LookupAtom #H1 2:0:hash<[+]all(-)|.>  (X::0) [(X::0)]all((Ls::1))
		StoreIter<All> candidates_1 = all_store_0.lookup_candidates(index0All(x));
		All cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int x__1;
			x__1 = cand_1.loc;
			ls = cand_1.arg1;
			if (true) {
				// Join Task: DeleteHead #H0
				// H0 is active and monotone, no delete required
				// Join Task: IntroCompre Remote NoPrior NonMono (L::3) (Ls::1) [(L::3)]fire((T::2))
				SimpMultiset<Integer>  comp_0 = ls;
				for(int idx=0; idx<comp_0.size(); idx++) {
					l = comp_0.get(idx);
					send( new Fire(l,t) ); 
				}
				start_rule_count++;
				return false;
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule start ****
	Rule Head Variables: (X::0), (Ls::1), (T::2)
	Rule Head Compre Binders: 
	Active #H0 [(X::0)]all((Ls::1))
	LookupAtom #H1 1:0:hash<[+]start(-)|.>  (X::0) [(X::0)]start((T::2))
	DeleteHead #H1
	IntroCompre Remote NoPrior NonMono (L::3) (Ls::1) [(L::3)]fire((T::2))
	*/
	protected boolean execute_all_join_ordering_1(All act) {
		
		int x;
		SimpMultiset<Integer>  ls;
		long t;
		int l;
		// Join Task: Active #H0 [(X::0)]all((Ls::1))
		x = act.loc;
		ls = act.arg1;
		// Join Task: LookupAtom #H1 1:0:hash<[+]start(-)|.>  (X::0) [(X::0)]start((T::2))
		StoreIter<Start> candidates_1 = start_store_0.lookup_candidates(index0Start(x));
		Start cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int x__1;
			x__1 = cand_1.loc;
			t = cand_1.arg1;
			if (true) {
				// Join Task: DeleteHead #H1
				start_store_0.remove( cand_1 );
				// Join Task: IntroCompre Remote NoPrior NonMono (L::3) (Ls::1) [(L::3)]fire((T::2))
				SimpMultiset<Integer>  comp_0 = ls;
				for(int idx=0; idx<comp_0.size(); idx++) {
					l = comp_0.get(idx);
					send( new Fire(l,t) ); 
				}
				start_rule_count++;
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule clear ****
	Rule Head Variables: (I::0), (Ls::1)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]all((Ls::1))
	LookupAtom #H1 12:0:hash<[+]reset()|.>  (I::0) [(I::0)]reset()
	DeleteHead #H0
	DeleteHead #H1
	IntroCompre Remote NoPrior Mono (L::2) (Ls::1) [(L::2)]empty()
	*/
	protected boolean execute_all_join_ordering_2(All act) {
		
		int i;
		SimpMultiset<Integer>  ls;
		int l;
		// Join Task: Active #H0 [(I::0)]all((Ls::1))
		i = act.loc;
		ls = act.arg1;
		// Join Task: LookupAtom #H1 12:0:hash<[+]reset()|.>  (I::0) [(I::0)]reset()
		StoreIter<Reset> candidates_1 = reset_store_0.lookup_candidates(index0Reset(i));
		Reset cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int i__1;
			i__1 = cand_1.loc;
			if (true) {
				// Join Task: DeleteHead #H0
				// H0 is active and monotone, no delete required
				// Join Task: DeleteHead #H1
				reset_store_0.remove( cand_1 );
				// Join Task: IntroCompre Remote NoPrior Mono (L::2) (Ls::1) [(L::2)]empty()
				SimpMultiset<Integer>  comp_0 = ls;
				for(int idx=0; idx<comp_0.size(); idx++) {
					l = comp_0.get(idx);
					send( new Empty(l) ); 
				}
				clear_rule_count++;
				return false;
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule end ****
	Rule Head Variables: (X::0), (I::1), (Ns::3)
	Rule Head Compre Binders: 
	Active #H0 [(X::0)]src((I::1))
	LookupAtom #H1 5:0:hash<[+]transScore(-,-,-)|.>  (X::0) [(X::0)]transScore(uscore,(Ns::3),uscore)
	CheckGuard length((Ns::3)) == 0
	DeleteHead #H1
	IntroAtom Remote NoPrior Mono [(I::1)]completed()
	*/
	protected boolean execute_src_join_ordering_1(Src act) {
		
		int x;
		int i;
		int anon__2;
		LinkedList<String>  ns;
		int anon__4;
		// Join Task: Active #H0 [(X::0)]src((I::1))
		if (act.is_alive()) {
			x = act.loc;
			i = act.arg1;
			// Join Task: LookupAtom #H1 5:0:hash<[+]transScore(-,-,-)|.>  (X::0) [(X::0)]transScore(uscore,(Ns::3),uscore)
			StoreIter<TransScore> candidates_1 = transscore_store_0.lookup_candidates(index0TransScore(x));
			TransScore cand_1 = candidates_1.get_next_alive();
			while(cand_1 != null) {
				int x__1;
				x__1 = cand_1.loc;
				anon__2 = cand_1.arg1;
				ns = cand_1.arg2;
				anon__4 = cand_1.arg3;
				if (true) {
					// Join Task: CheckGuard length((Ns::3)) == 0
					if (Equality.is_eq(ExtLib.length(ns),0)) {
						// Join Task: DeleteHead #H1
						transscore_store_0.remove( cand_1 );
						// Join Task: IntroAtom Remote NoPrior Mono [(I::1)]completed()
						send( new Completed(i) ); 
						end_rule_count++;
					}
				}
				cand_1 = candidates_1.get_next_alive();
			}
		}
		return true;
	}
	
	/*
	**** 3 Join Ordering of Rule empty ****
	Rule Head Variables: (X::0)
	Rule Head Compre Binders: 
	Active #H0 [(X::0)]src(uscore)
	LookupAtom #H1 13:0:hash<[+]empty()|.>  (X::0) [(X::0)]empty()
	LookupAll #H2 3:0:hash<[+]src(-)|.>  (X::0) [(X::0)]src(uscore)
	LookupAll #H3 4:0:hash<[+]edge(-)|.>  (X::0) [(X::0)]edge(uscore)
	LookupAll #H4 7:0:hash<[+]fire(-)|.>  (X::0) [(X::0)]fire(uscore)
	LookupAll #H5 8:0:hash<[+]playLog(-,-)|.>  (X::0) [(X::0)]playLog(uscore,uscore)
	DeleteHead #H1
	DeleteHead #H2
	DeleteHead #H3
	DeleteHead #H4
	DeleteHead #H5
	*/
	protected boolean execute_src_join_ordering_2(Src act) {
		
		int x;
		String anon__1;
		long anon__2;
		int anon__3;
		int anon__4;
		long anon__5;
		// Join Task: Active #H0 [(X::0)]src(uscore)
		if (act.is_alive()) {
			x = act.loc;
			anon__4 = act.arg1;
			// Join Task: LookupAtom #H1 13:0:hash<[+]empty()|.>  (X::0) [(X::0)]empty()
			StoreIter<Empty> candidates_1 = empty_store_0.lookup_candidates(index0Empty(x));
			Empty cand_1 = candidates_1.get_next_alive();
			while(cand_1 != null) {
				int x__1;
				x__1 = cand_1.loc;
				if (true) {
					// Join Task: LookupAll #H2 3:0:hash<[+]src(-)|.>  (X::0) [(X::0)]src(uscore)
					StoreIter<Src> candidates_2 = src_store_0.lookup_candidates(index0Src(x));
					// Join Task: LookupAll #H3 4:0:hash<[+]edge(-)|.>  (X::0) [(X::0)]edge(uscore)
					StoreIter<Edge> candidates_3 = edge_store_0.lookup_candidates(index0Edge(x));
					// Join Task: LookupAll #H4 7:0:hash<[+]fire(-)|.>  (X::0) [(X::0)]fire(uscore)
					StoreIter<Fire> candidates_4 = fire_store_0.lookup_candidates(index0Fire(x));
					// Join Task: LookupAll #H5 8:0:hash<[+]playLog(-,-)|.>  (X::0) [(X::0)]playLog(uscore,uscore)
					StoreIter<PlayLog> candidates_5 = playlog_store_0.lookup_candidates(index0PlayLog(x));
					// Join Task: DeleteHead #H1
					empty_store_0.remove( cand_1 );
					// Join Task: DeleteHead #H2
					Src cand_2_0 = candidates_2.get_next_alive();
					while(cand_2_0 != null) {
						src_store_0.remove( cand_2_0 );
						cand_2_0 = candidates_2.get_next_alive();
					}
					// Join Task: DeleteHead #H3
					Edge cand_3_0 = candidates_3.get_next_alive();
					while(cand_3_0 != null) {
						edge_store_0.remove( cand_3_0 );
						cand_3_0 = candidates_3.get_next_alive();
					}
					// Join Task: DeleteHead #H4
					Fire cand_4_0 = candidates_4.get_next_alive();
					while(cand_4_0 != null) {
						fire_store_0.remove( cand_4_0 );
						cand_4_0 = candidates_4.get_next_alive();
					}
					// Join Task: DeleteHead #H5
					PlayLog cand_5_0 = candidates_5.get_next_alive();
					while(cand_5_0 != null) {
						playlog_store_0.remove( cand_5_0 );
						cand_5_0 = candidates_5.get_next_alive();
					}
					empty_rule_count++;
					return false;
				}
				cand_1 = candidates_1.get_next_alive();
			}
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule fwd ****
	Rule Head Variables: (Ys::0), (X::2), (Z::3), (Ns::4), (P::5)
	Rule Head Compre Binders: (Y::1)
	Active #H0 [(X::2)]edge((Y::1))
	LookupAtom #H1 5:0:hash<[+]transScore(-,-,-)|.>  (X::2) [(X::2)]transScore((Z::3),(Ns::4),(P::5))
	CheckGuard length((Ns::4)) > 0
	LookupAll #H2 4:0:hash<[+]edge(-)|.>  (X::2) [(X::2)]edge((Y::1))
	CompreDomain #H2 (Y::1) (Ys::0) [(X::2)]edge((Y::1))
	CheckGuard size(diff(((Ys::0),{(Z::3)}))) > 0
	DeleteHead #H1
	LetBind ((M::6),(Ms::7)) uncons((Ns::4))
	LetBind (Ws::8) diff(((Ys::0),{(Z::3)}))
	IntroAtom Remote NoPrior NonMono [(X::2)]note((M::6),(P::5))
	IntroAtom Remote NoPrior Mono [(X::2)]refresh()
	IntroCompre Remote NoPrior Mono (W::9) (Ws::8) [(W::9)]transScore((X::2),(Ms::7),(P::5) + 1)
	*/
	protected boolean execute_edge_join_ordering_1(Edge act) {
		
		SimpMultiset<Integer>  ys;
		int y;
		int x;
		int z;
		LinkedList<String>  ns;
		int p;
		String m;
		LinkedList<String>  ms;
		SimpMultiset<Integer>  ws;
		int w;
		// Join Task: Active #H0 [(X::2)]edge((Y::1))
		if (act.is_alive()) {
			x = act.loc;
			y = act.arg1;
			// Join Task: LookupAtom #H1 5:0:hash<[+]transScore(-,-,-)|.>  (X::2) [(X::2)]transScore((Z::3),(Ns::4),(P::5))
			StoreIter<TransScore> candidates_1 = transscore_store_0.lookup_candidates(index0TransScore(x));
			TransScore cand_1 = candidates_1.get_next_alive();
			while(cand_1 != null) {
				int x__1;
				x__1 = cand_1.loc;
				z = cand_1.arg1;
				ns = cand_1.arg2;
				p = cand_1.arg3;
				if (true) {
					// Join Task: CheckGuard length((Ns::4)) > 0
					if (ExtLib.length(ns) > 0) {
						// Join Task: LookupAll #H2 4:0:hash<[+]edge(-)|.>  (X::2) [(X::2)]edge((Y::1))
						StoreIter<Edge> candidates_2 = edge_store_0.lookup_candidates(index0Edge(x));
						// Join Task: CompreDomain #H2 (Y::1) (Ys::0) [(X::2)]edge((Y::1))
						ys = new SimpMultiset<Integer> ();
						Edge cand_2_0 = candidates_2.get_next_alive();
						while(cand_2_0 != null) {
							x = cand_2_0.loc;
							y = cand_2_0.arg1;
							ys.add( y );
							cand_2_0 = candidates_2.get_next_alive();
						}
						candidates_2.init_iter();
						// Join Task: CheckGuard size(diff(((Ys::0),{(Z::3)}))) > 0
						Integer[] temp0 = { z };
						if (ExtLib.size(ExtLib.diff(ys,Misc.to_mset(temp0))) > 0) {
							// Join Task: DeleteHead #H1
							transscore_store_0.remove( cand_1 );
							// Join Task: LetBind ((M::6),(Ms::7)) uncons((Ns::4))
							Tuple2<String,LinkedList<String> >  tup1;
							tup1 = ExtLib.uncons(ns);
							m = tup1.t1;
							ms = tup1.t2;
							;
							// Join Task: LetBind (Ws::8) diff(((Ys::0),{(Z::3)}))
							Integer[] temp1 = { z };
							ws = ExtLib.diff(ys,Misc.to_mset(temp1));
							;
							// Join Task: IntroAtom Remote NoPrior NonMono [(X::2)]note((M::6),(P::5))
							intro( new Note(x,m,p) );
							// Join Task: IntroAtom Remote NoPrior Mono [(X::2)]refresh()
							intro( new Refresh(x) );
							// Join Task: IntroCompre Remote NoPrior Mono (W::9) (Ws::8) [(W::9)]transScore((X::2),(Ms::7),(P::5) + 1)
							SimpMultiset<Integer>  comp_0 = ws;
							for(int idx=0; idx<comp_0.size(); idx++) {
								w = comp_0.get(idx);
								send( new TransScore(w,x,ms,p + 1) ); 
							}
							fwd_rule_count++;
						}
					}
				}
				cand_1 = candidates_1.get_next_alive();
			}
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule ret ****
	Rule Head Variables: (Ys::0), (X::2), (Z::3), (Ns::4), (P::5)
	Rule Head Compre Binders: (Y::1)
	Active #H0 [(X::2)]edge((Y::1))
	LookupAtom #H1 5:0:hash<[+]transScore(-,-,-)|.>  (X::2) [(X::2)]transScore((Z::3),(Ns::4),(P::5))
	CheckGuard length((Ns::4)) > 0
	LookupAll #H2 4:0:hash<[+]edge(-)|.>  (X::2) [(X::2)]edge((Y::1))
	CompreDomain #H2 (Y::1) (Ys::0) [(X::2)]edge((Y::1))
	CheckGuard size(diff(((Ys::0),{(Z::3)}))) == 0
	DeleteHead #H1
	LetBind ((M::6),(Ms::7)) uncons((Ns::4))
	LetBind (Lvar1::8) (P::5) + 1
	IntroAtom Remote NoPrior NonMono [(X::2)]note((M::6),(P::5))
	IntroAtom Remote NoPrior Mono [(X::2)]refresh()
	IntroAtom Remote NoPrior Mono [(Z::3)]transScore((X::2),(Ms::7),(Lvar1::8))
	*/
	protected boolean execute_edge_join_ordering_2(Edge act) {
		
		SimpMultiset<Integer>  ys;
		int y;
		int x;
		int z;
		LinkedList<String>  ns;
		int p;
		String m;
		LinkedList<String>  ms;
		int lvar1;
		// Join Task: Active #H0 [(X::2)]edge((Y::1))
		if (act.is_alive()) {
			x = act.loc;
			y = act.arg1;
			// Join Task: LookupAtom #H1 5:0:hash<[+]transScore(-,-,-)|.>  (X::2) [(X::2)]transScore((Z::3),(Ns::4),(P::5))
			StoreIter<TransScore> candidates_1 = transscore_store_0.lookup_candidates(index0TransScore(x));
			TransScore cand_1 = candidates_1.get_next_alive();
			while(cand_1 != null) {
				int x__1;
				x__1 = cand_1.loc;
				z = cand_1.arg1;
				ns = cand_1.arg2;
				p = cand_1.arg3;
				if (true) {
					// Join Task: CheckGuard length((Ns::4)) > 0
					if (ExtLib.length(ns) > 0) {
						// Join Task: LookupAll #H2 4:0:hash<[+]edge(-)|.>  (X::2) [(X::2)]edge((Y::1))
						StoreIter<Edge> candidates_2 = edge_store_0.lookup_candidates(index0Edge(x));
						// Join Task: CompreDomain #H2 (Y::1) (Ys::0) [(X::2)]edge((Y::1))
						ys = new SimpMultiset<Integer> ();
						Edge cand_2_0 = candidates_2.get_next_alive();
						while(cand_2_0 != null) {
							x = cand_2_0.loc;
							y = cand_2_0.arg1;
							ys.add( y );
							cand_2_0 = candidates_2.get_next_alive();
						}
						candidates_2.init_iter();
						// Join Task: CheckGuard size(diff(((Ys::0),{(Z::3)}))) == 0
						Integer[] temp2 = { z };
						if (Equality.is_eq(ExtLib.size(ExtLib.diff(ys,Misc.to_mset(temp2))),0)) {
							// Join Task: DeleteHead #H1
							transscore_store_0.remove( cand_1 );
							// Join Task: LetBind ((M::6),(Ms::7)) uncons((Ns::4))
							Tuple2<String,LinkedList<String> >  tup2;
							tup2 = ExtLib.uncons(ns);
							m = tup2.t1;
							ms = tup2.t2;
							;
							// Join Task: LetBind (Lvar1::8) (P::5) + 1
							lvar1 = p + 1;
							;
							// Join Task: IntroAtom Remote NoPrior NonMono [(X::2)]note((M::6),(P::5))
							intro( new Note(x,m,p) );
							// Join Task: IntroAtom Remote NoPrior Mono [(X::2)]refresh()
							intro( new Refresh(x) );
							// Join Task: IntroAtom Remote NoPrior Mono [(Z::3)]transScore((X::2),(Ms::7),(Lvar1::8))
							send( new TransScore(z,x,ms,lvar1) ); 
							ret_rule_count++;
						}
					}
				}
				cand_1 = candidates_1.get_next_alive();
			}
		}
		return true;
	}
	
	/*
	**** 2 Join Ordering of Rule empty ****
	Rule Head Variables: (X::0)
	Rule Head Compre Binders: 
	Active #H0 [(X::0)]edge(uscore)
	LookupAtom #H1 13:0:hash<[+]empty()|.>  (X::0) [(X::0)]empty()
	LookupAll #H2 4:0:hash<[+]edge(-)|.>  (X::0) [(X::0)]edge(uscore)
	LookupAll #H3 3:0:hash<[+]src(-)|.>  (X::0) [(X::0)]src(uscore)
	LookupAll #H4 7:0:hash<[+]fire(-)|.>  (X::0) [(X::0)]fire(uscore)
	LookupAll #H5 8:0:hash<[+]playLog(-,-)|.>  (X::0) [(X::0)]playLog(uscore,uscore)
	DeleteHead #H1
	DeleteHead #H2
	DeleteHead #H3
	DeleteHead #H4
	DeleteHead #H5
	*/
	protected boolean execute_edge_join_ordering_3(Edge act) {
		
		int x;
		String anon__1;
		long anon__2;
		int anon__3;
		int anon__4;
		long anon__5;
		// Join Task: Active #H0 [(X::0)]edge(uscore)
		if (act.is_alive()) {
			x = act.loc;
			anon__3 = act.arg1;
			// Join Task: LookupAtom #H1 13:0:hash<[+]empty()|.>  (X::0) [(X::0)]empty()
			StoreIter<Empty> candidates_1 = empty_store_0.lookup_candidates(index0Empty(x));
			Empty cand_1 = candidates_1.get_next_alive();
			while(cand_1 != null) {
				int x__1;
				x__1 = cand_1.loc;
				if (true) {
					// Join Task: LookupAll #H2 4:0:hash<[+]edge(-)|.>  (X::0) [(X::0)]edge(uscore)
					StoreIter<Edge> candidates_2 = edge_store_0.lookup_candidates(index0Edge(x));
					// Join Task: LookupAll #H3 3:0:hash<[+]src(-)|.>  (X::0) [(X::0)]src(uscore)
					StoreIter<Src> candidates_3 = src_store_0.lookup_candidates(index0Src(x));
					// Join Task: LookupAll #H4 7:0:hash<[+]fire(-)|.>  (X::0) [(X::0)]fire(uscore)
					StoreIter<Fire> candidates_4 = fire_store_0.lookup_candidates(index0Fire(x));
					// Join Task: LookupAll #H5 8:0:hash<[+]playLog(-,-)|.>  (X::0) [(X::0)]playLog(uscore,uscore)
					StoreIter<PlayLog> candidates_5 = playlog_store_0.lookup_candidates(index0PlayLog(x));
					// Join Task: DeleteHead #H1
					empty_store_0.remove( cand_1 );
					// Join Task: DeleteHead #H2
					Edge cand_2_0 = candidates_2.get_next_alive();
					while(cand_2_0 != null) {
						edge_store_0.remove( cand_2_0 );
						cand_2_0 = candidates_2.get_next_alive();
					}
					// Join Task: DeleteHead #H3
					Src cand_3_0 = candidates_3.get_next_alive();
					while(cand_3_0 != null) {
						src_store_0.remove( cand_3_0 );
						cand_3_0 = candidates_3.get_next_alive();
					}
					// Join Task: DeleteHead #H4
					Fire cand_4_0 = candidates_4.get_next_alive();
					while(cand_4_0 != null) {
						fire_store_0.remove( cand_4_0 );
						cand_4_0 = candidates_4.get_next_alive();
					}
					// Join Task: DeleteHead #H5
					PlayLog cand_5_0 = candidates_5.get_next_alive();
					while(cand_5_0 != null) {
						playlog_store_0.remove( cand_5_0 );
						cand_5_0 = candidates_5.get_next_alive();
					}
					empty_rule_count++;
					return false;
				}
				cand_1 = candidates_1.get_next_alive();
			}
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule fwd ****
	Rule Head Variables: (Ys::0), (X::2), (Z::3), (Ns::4), (P::5)
	Rule Head Compre Binders: (Y::1)
	Active #H0 [(X::2)]transScore((Z::3),(Ns::4),(P::5))
	CheckGuard length((Ns::4)) > 0
	LookupAll #H1 4:0:hash<[+]edge(-)|.>  (X::2) [(X::2)]edge((Y::1))
	CompreDomain #H1 (Y::1) (Ys::0) [(X::2)]edge((Y::1))
	CheckGuard size(diff(((Ys::0),{(Z::3)}))) > 0
	DeleteHead #H0
	LetBind ((M::6),(Ms::7)) uncons((Ns::4))
	LetBind (Ws::8) diff(((Ys::0),{(Z::3)}))
	IntroAtom Remote NoPrior NonMono [(X::2)]note((M::6),(P::5))
	IntroAtom Remote NoPrior Mono [(X::2)]refresh()
	IntroCompre Remote NoPrior Mono (W::9) (Ws::8) [(W::9)]transScore((X::2),(Ms::7),(P::5) + 1)
	*/
	protected boolean execute_transscore_join_ordering_1(TransScore act) {
		
		SimpMultiset<Integer>  ys;
		int y;
		int x;
		int z;
		LinkedList<String>  ns;
		int p;
		String m;
		LinkedList<String>  ms;
		SimpMultiset<Integer>  ws;
		int w;
		// Join Task: Active #H0 [(X::2)]transScore((Z::3),(Ns::4),(P::5))
		x = act.loc;
		z = act.arg1;
		ns = act.arg2;
		p = act.arg3;
		// Join Task: CheckGuard length((Ns::4)) > 0
		if (ExtLib.length(ns) > 0) {
			// Join Task: LookupAll #H1 4:0:hash<[+]edge(-)|.>  (X::2) [(X::2)]edge((Y::1))
			StoreIter<Edge> candidates_1 = edge_store_0.lookup_candidates(index0Edge(x));
			// Join Task: CompreDomain #H1 (Y::1) (Ys::0) [(X::2)]edge((Y::1))
			ys = new SimpMultiset<Integer> ();
			Edge cand_1_0 = candidates_1.get_next_alive();
			while(cand_1_0 != null) {
				x = cand_1_0.loc;
				y = cand_1_0.arg1;
				ys.add( y );
				cand_1_0 = candidates_1.get_next_alive();
			}
			candidates_1.init_iter();
			// Join Task: CheckGuard size(diff(((Ys::0),{(Z::3)}))) > 0
			Integer[] temp3 = { z };
			if (ExtLib.size(ExtLib.diff(ys,Misc.to_mset(temp3))) > 0) {
				// Join Task: DeleteHead #H0
				// H0 is active and monotone, no delete required
				// Join Task: LetBind ((M::6),(Ms::7)) uncons((Ns::4))
				Tuple2<String,LinkedList<String> >  tup3;
				tup3 = ExtLib.uncons(ns);
				m = tup3.t1;
				ms = tup3.t2;
				;
				// Join Task: LetBind (Ws::8) diff(((Ys::0),{(Z::3)}))
				Integer[] temp4 = { z };
				ws = ExtLib.diff(ys,Misc.to_mset(temp4));
				;
				// Join Task: IntroAtom Remote NoPrior NonMono [(X::2)]note((M::6),(P::5))
				intro( new Note(x,m,p) );
				// Join Task: IntroAtom Remote NoPrior Mono [(X::2)]refresh()
				intro( new Refresh(x) );
				// Join Task: IntroCompre Remote NoPrior Mono (W::9) (Ws::8) [(W::9)]transScore((X::2),(Ms::7),(P::5) + 1)
				SimpMultiset<Integer>  comp_0 = ws;
				for(int idx=0; idx<comp_0.size(); idx++) {
					w = comp_0.get(idx);
					send( new TransScore(w,x,ms,p + 1) ); 
				}
				fwd_rule_count++;
				return false;
			}
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule ret ****
	Rule Head Variables: (Ys::0), (X::2), (Z::3), (Ns::4), (P::5)
	Rule Head Compre Binders: (Y::1)
	Active #H0 [(X::2)]transScore((Z::3),(Ns::4),(P::5))
	CheckGuard length((Ns::4)) > 0
	LookupAll #H1 4:0:hash<[+]edge(-)|.>  (X::2) [(X::2)]edge((Y::1))
	CompreDomain #H1 (Y::1) (Ys::0) [(X::2)]edge((Y::1))
	CheckGuard size(diff(((Ys::0),{(Z::3)}))) == 0
	DeleteHead #H0
	LetBind ((M::6),(Ms::7)) uncons((Ns::4))
	LetBind (Lvar1::8) (P::5) + 1
	IntroAtom Remote NoPrior NonMono [(X::2)]note((M::6),(P::5))
	IntroAtom Remote NoPrior Mono [(X::2)]refresh()
	IntroAtom Remote NoPrior Mono [(Z::3)]transScore((X::2),(Ms::7),(Lvar1::8))
	*/
	protected boolean execute_transscore_join_ordering_2(TransScore act) {
		
		SimpMultiset<Integer>  ys;
		int y;
		int x;
		int z;
		LinkedList<String>  ns;
		int p;
		String m;
		LinkedList<String>  ms;
		int lvar1;
		// Join Task: Active #H0 [(X::2)]transScore((Z::3),(Ns::4),(P::5))
		x = act.loc;
		z = act.arg1;
		ns = act.arg2;
		p = act.arg3;
		// Join Task: CheckGuard length((Ns::4)) > 0
		if (ExtLib.length(ns) > 0) {
			// Join Task: LookupAll #H1 4:0:hash<[+]edge(-)|.>  (X::2) [(X::2)]edge((Y::1))
			StoreIter<Edge> candidates_1 = edge_store_0.lookup_candidates(index0Edge(x));
			// Join Task: CompreDomain #H1 (Y::1) (Ys::0) [(X::2)]edge((Y::1))
			ys = new SimpMultiset<Integer> ();
			Edge cand_1_0 = candidates_1.get_next_alive();
			while(cand_1_0 != null) {
				x = cand_1_0.loc;
				y = cand_1_0.arg1;
				ys.add( y );
				cand_1_0 = candidates_1.get_next_alive();
			}
			candidates_1.init_iter();
			// Join Task: CheckGuard size(diff(((Ys::0),{(Z::3)}))) == 0
			Integer[] temp5 = { z };
			if (Equality.is_eq(ExtLib.size(ExtLib.diff(ys,Misc.to_mset(temp5))),0)) {
				// Join Task: DeleteHead #H0
				// H0 is active and monotone, no delete required
				// Join Task: LetBind ((M::6),(Ms::7)) uncons((Ns::4))
				Tuple2<String,LinkedList<String> >  tup4;
				tup4 = ExtLib.uncons(ns);
				m = tup4.t1;
				ms = tup4.t2;
				;
				// Join Task: LetBind (Lvar1::8) (P::5) + 1
				lvar1 = p + 1;
				;
				// Join Task: IntroAtom Remote NoPrior NonMono [(X::2)]note((M::6),(P::5))
				intro( new Note(x,m,p) );
				// Join Task: IntroAtom Remote NoPrior Mono [(X::2)]refresh()
				intro( new Refresh(x) );
				// Join Task: IntroAtom Remote NoPrior Mono [(Z::3)]transScore((X::2),(Ms::7),(Lvar1::8))
				send( new TransScore(z,x,ms,lvar1) ); 
				ret_rule_count++;
				return false;
			}
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule end ****
	Rule Head Variables: (X::0), (I::1), (Ns::3)
	Rule Head Compre Binders: 
	Active #H0 [(X::0)]transScore(uscore,(Ns::3),uscore)
	CheckGuard length((Ns::3)) == 0
	LookupAtom #H1 3:0:hash<[+]src(-)|.>  (X::0) [(X::0)]src((I::1))
	DeleteHead #H0
	IntroAtom Remote NoPrior Mono [(I::1)]completed()
	*/
	protected boolean execute_transscore_join_ordering_3(TransScore act) {
		
		int x;
		int i;
		int anon__2;
		LinkedList<String>  ns;
		int anon__4;
		// Join Task: Active #H0 [(X::0)]transScore(uscore,(Ns::3),uscore)
		x = act.loc;
		anon__2 = act.arg1;
		ns = act.arg2;
		anon__4 = act.arg3;
		// Join Task: CheckGuard length((Ns::3)) == 0
		if (Equality.is_eq(ExtLib.length(ns),0)) {
			// Join Task: LookupAtom #H1 3:0:hash<[+]src(-)|.>  (X::0) [(X::0)]src((I::1))
			StoreIter<Src> candidates_1 = src_store_0.lookup_candidates(index0Src(x));
			Src cand_1 = candidates_1.get_next_alive();
			while(cand_1 != null) {
				int x__1;
				x__1 = cand_1.loc;
				i = cand_1.arg1;
				if (true) {
					// Join Task: DeleteHead #H0
					// H0 is active and monotone, no delete required
					// Join Task: IntroAtom Remote NoPrior Mono [(I::1)]completed()
					send( new Completed(i) ); 
					end_rule_count++;
					return false;
				}
				cand_1 = candidates_1.get_next_alive();
			}
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule note ****
	Rule Head Variables: (X::0), (Tn::1), (M::2), (P::3)
	Rule Head Compre Binders: 
	Active #H0 [(X::0)]note((M::2),(P::3))
	LookupAtom #H1 7:0:hash<[+]fire(-)|.>  (X::0) [(X::0)]fire((Tn::1))
	LookupAll #H2 6:0:hash<[+]note(+,+)|.>  (X::0),(M::2),(P::3) [(X::0)]note((M::2),(P::3))
	FilterHead #H2 #H0
	DeleteHead #H0
	DeleteHead #H2
	LetBind (Tm::4) addSeconds(((Tn::1),(P::3)))
	IntroAtom Local NoPrior Mono [(X::0)]play((M::2),(Tm::4))
	IntroAtom Local NoPrior NonMono [(X::0)]playLog((M::2),(Tm::4))
	*/
	protected boolean execute_note_join_ordering_1(Note act) {
		
		int x;
		long tn;
		String m;
		int p;
		long tm;
		// Join Task: Active #H0 [(X::0)]note((M::2),(P::3))
		if (act.is_alive()) {
			x = act.loc;
			m = act.arg1;
			p = act.arg2;
			// Join Task: LookupAtom #H1 7:0:hash<[+]fire(-)|.>  (X::0) [(X::0)]fire((Tn::1))
			StoreIter<Fire> candidates_1 = fire_store_0.lookup_candidates(index0Fire(x));
			Fire cand_1 = candidates_1.get_next_alive();
			while(cand_1 != null) {
				int x__1;
				x__1 = cand_1.loc;
				tn = cand_1.arg1;
				if (true) {
					// Join Task: LookupAll #H2 6:0:hash<[+]note(+,+)|.>  (X::0),(M::2),(P::3) [(X::0)]note((M::2),(P::3))
					StoreIter<Note> candidates_2 = note_store_0.lookup_candidates(index0Note(x,m,p));
					ListStoreIter<Note> candidates_2_0 = new ListStoreIter<Note>();
					Note cand_2 = candidates_2.get_next_alive();
					while(cand_2 != null) {
						int x__2;
						String m__2;
						int p__2;
						x__2 = cand_2.loc;
						m__2 = cand_2.arg1;
						p__2 = cand_2.arg2;
						if (Equality.is_eq(x,x__2) && Equality.is_eq(m,m__2) && Equality.is_eq(p,p__2)) {
							candidates_2_0.add( cand_2 );
						}
						cand_2 = candidates_2.get_next_alive();
					}
					candidates_2_0.init_iter();
					// Join Task: FilterHead #H2 #H0
					ListStoreIter<Note> candidates_2_0_1 = new ListStoreIter<Note>();
					Note cand_2_1 = candidates_2_0.get_next_alive();
					while(cand_2_1 != null) {
						x = cand_2_1.loc;
						m = cand_2_1.arg1;
						p = cand_2_1.arg2;
						if ((cand_2_1).identity() != (act).identity() ) {
							candidates_2_0_1.add( cand_2_1 );
						}
						cand_2_1 = candidates_2_0.get_next_alive();
					}
					candidates_2_0_1.init_iter();
					// Join Task: DeleteHead #H0
					note_store_0.remove( act );
					// Join Task: DeleteHead #H2
					Note cand_2_2 = candidates_2_0_1.get_next_alive();
					while(cand_2_2 != null) {
						note_store_0.remove( cand_2_2 );
						cand_2_2 = candidates_2_0_1.get_next_alive();
					}
					// Join Task: LetBind (Tm::4) addSeconds(((Tn::1),(P::3)))
					tm = ExtLib.addSeconds(tn,p);
					;
					// Join Task: IntroAtom Local NoPrior Mono [(X::0)]play((M::2),(Tm::4))
					intro( new Play(x,m,tm) );
					// Join Task: IntroAtom Local NoPrior NonMono [(X::0)]playLog((M::2),(Tm::4))
					intro( new PlayLog(x,m,tm) );
					note_rule_count++;
					return false;
				}
				cand_1 = candidates_1.get_next_alive();
			}
		}
		return true;
	}
	
	/*
	**** 2 Join Ordering of Rule note ****
	Rule Head Variables: (X::0), (Tn::1), (M::2), (P::3)
	Rule Head Compre Binders: 
	Active #H0 [(X::0)]note((M::2),(P::3))
	LookupAtom #H1 6:0:hash<[+]note(+,+)|.>  (X::0),(M::2),(P::3) [(X::0)]note((M::2),(P::3))
	LookupAtom #H2 7:0:hash<[+]fire(-)|.>  (X::0) [(X::0)]fire((Tn::1))
	LookupAll #H3 6:0:hash<[+]note(+,+)|.>  (X::0),(M::2),(P::3) [(X::0)]note((M::2),(P::3))
	FilterHead #H3 #H1
	DeleteHead #H1
	DeleteHead #H3
	LetBind (Tm::4) addSeconds(((Tn::1),(P::3)))
	IntroAtom Local NoPrior Mono [(X::0)]play((M::2),(Tm::4))
	IntroAtom Local NoPrior NonMono [(X::0)]playLog((M::2),(Tm::4))
	*/
	protected boolean execute_note_join_ordering_2(Note act) {
		
		int x;
		long tn;
		String m;
		int p;
		long tm;
		// Join Task: Active #H0 [(X::0)]note((M::2),(P::3))
		if (act.is_alive()) {
			x = act.loc;
			m = act.arg1;
			p = act.arg2;
			// Join Task: LookupAtom #H1 6:0:hash<[+]note(+,+)|.>  (X::0),(M::2),(P::3) [(X::0)]note((M::2),(P::3))
			StoreIter<Note> candidates_1 = note_store_0.lookup_candidates(index0Note(x,m,p));
			Note cand_1 = candidates_1.get_next_alive();
			while(cand_1 != null) {
				int x__1;
				String m__1;
				int p__1;
				x__1 = cand_1.loc;
				m__1 = cand_1.arg1;
				p__1 = cand_1.arg2;
				if (Equality.is_eq(x,x__1) && Equality.is_eq(m,m__1) && Equality.is_eq(p,p__1)) {
					// Join Task: LookupAtom #H2 7:0:hash<[+]fire(-)|.>  (X::0) [(X::0)]fire((Tn::1))
					StoreIter<Fire> candidates_2 = fire_store_0.lookup_candidates(index0Fire(x));
					Fire cand_2 = candidates_2.get_next_alive();
					while(cand_2 != null) {
						int x__2;
						x__2 = cand_2.loc;
						tn = cand_2.arg1;
						if (true) {
							// Join Task: LookupAll #H3 6:0:hash<[+]note(+,+)|.>  (X::0),(M::2),(P::3) [(X::0)]note((M::2),(P::3))
							StoreIter<Note> candidates_3 = note_store_0.lookup_candidates(index0Note(x,m,p));
							ListStoreIter<Note> candidates_3_0 = new ListStoreIter<Note>();
							Note cand_3 = candidates_3.get_next_alive();
							while(cand_3 != null) {
								int x__3;
								String m__3;
								int p__3;
								x__3 = cand_3.loc;
								m__3 = cand_3.arg1;
								p__3 = cand_3.arg2;
								if (Equality.is_eq(x,x__3) && Equality.is_eq(m,m__3) && Equality.is_eq(p,p__3)) {
									candidates_3_0.add( cand_3 );
								}
								cand_3 = candidates_3.get_next_alive();
							}
							candidates_3_0.init_iter();
							// Join Task: FilterHead #H3 #H1
							ListStoreIter<Note> candidates_3_0_1 = new ListStoreIter<Note>();
							Note cand_3_1 = candidates_3_0.get_next_alive();
							while(cand_3_1 != null) {
								x = cand_3_1.loc;
								m = cand_3_1.arg1;
								p = cand_3_1.arg2;
								if ((cand_3_1).identity() != (cand_1).identity() ) {
									candidates_3_0_1.add( cand_3_1 );
								}
								cand_3_1 = candidates_3_0.get_next_alive();
							}
							candidates_3_0_1.init_iter();
							// Join Task: DeleteHead #H1
							note_store_0.remove( cand_1 );
							// Join Task: DeleteHead #H3
							Note cand_3_2 = candidates_3_0_1.get_next_alive();
							while(cand_3_2 != null) {
								note_store_0.remove( cand_3_2 );
								cand_3_2 = candidates_3_0_1.get_next_alive();
							}
							// Join Task: LetBind (Tm::4) addSeconds(((Tn::1),(P::3)))
							tm = ExtLib.addSeconds(tn,p);
							;
							// Join Task: IntroAtom Local NoPrior Mono [(X::0)]play((M::2),(Tm::4))
							intro( new Play(x,m,tm) );
							// Join Task: IntroAtom Local NoPrior NonMono [(X::0)]playLog((M::2),(Tm::4))
							intro( new PlayLog(x,m,tm) );
							note_rule_count++;
							return false;
						}
						cand_2 = candidates_2.get_next_alive();
					}
				} else {
				}
				cand_1 = candidates_1.get_next_alive();
			}
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule note ****
	Rule Head Variables: (X::0), (Tn::1), (M::2), (P::3)
	Rule Head Compre Binders: 
	Active #H0 [(X::0)]fire((Tn::1))
	LookupAtom #H1 6:1:hash<[+]note(-,-)|.>  (X::0) [(X::0)]note((M::2),(P::3))
	LookupAll #H2 6:0:hash<[+]note(+,+)|.>  (X::0),(M::2),(P::3) [(X::0)]note((M::2),(P::3))
	FilterHead #H2 #H1
	DeleteHead #H1
	DeleteHead #H2
	LetBind (Tm::4) addSeconds(((Tn::1),(P::3)))
	IntroAtom Local NoPrior Mono [(X::0)]play((M::2),(Tm::4))
	IntroAtom Local NoPrior NonMono [(X::0)]playLog((M::2),(Tm::4))
	*/
	protected boolean execute_fire_join_ordering_1(Fire act) {
		
		int x;
		long tn;
		String m;
		int p;
		long tm;
		// Join Task: Active #H0 [(X::0)]fire((Tn::1))
		if (act.is_alive()) {
			x = act.loc;
			tn = act.arg1;
			// Join Task: LookupAtom #H1 6:1:hash<[+]note(-,-)|.>  (X::0) [(X::0)]note((M::2),(P::3))
			StoreIter<Note> candidates_1 = note_store_1.lookup_candidates(index1Note(x));
			Note cand_1 = candidates_1.get_next_alive();
			while(cand_1 != null) {
				int x__1;
				x__1 = cand_1.loc;
				m = cand_1.arg1;
				p = cand_1.arg2;
				if (true) {
					// Join Task: LookupAll #H2 6:0:hash<[+]note(+,+)|.>  (X::0),(M::2),(P::3) [(X::0)]note((M::2),(P::3))
					StoreIter<Note> candidates_2 = note_store_0.lookup_candidates(index0Note(x,m,p));
					ListStoreIter<Note> candidates_2_0 = new ListStoreIter<Note>();
					Note cand_2 = candidates_2.get_next_alive();
					while(cand_2 != null) {
						int x__2;
						String m__2;
						int p__2;
						x__2 = cand_2.loc;
						m__2 = cand_2.arg1;
						p__2 = cand_2.arg2;
						if (Equality.is_eq(x,x__2) && Equality.is_eq(m,m__2) && Equality.is_eq(p,p__2)) {
							candidates_2_0.add( cand_2 );
						}
						cand_2 = candidates_2.get_next_alive();
					}
					candidates_2_0.init_iter();
					// Join Task: FilterHead #H2 #H1
					ListStoreIter<Note> candidates_2_0_1 = new ListStoreIter<Note>();
					Note cand_2_1 = candidates_2_0.get_next_alive();
					while(cand_2_1 != null) {
						x = cand_2_1.loc;
						m = cand_2_1.arg1;
						p = cand_2_1.arg2;
						if ((cand_2_1).identity() != (cand_1).identity() ) {
							candidates_2_0_1.add( cand_2_1 );
						}
						cand_2_1 = candidates_2_0.get_next_alive();
					}
					candidates_2_0_1.init_iter();
					// Join Task: DeleteHead #H1
					note_store_0.remove( cand_1 );
					// Join Task: DeleteHead #H2
					Note cand_2_2 = candidates_2_0_1.get_next_alive();
					while(cand_2_2 != null) {
						note_store_0.remove( cand_2_2 );
						cand_2_2 = candidates_2_0_1.get_next_alive();
					}
					// Join Task: LetBind (Tm::4) addSeconds(((Tn::1),(P::3)))
					tm = ExtLib.addSeconds(tn,p);
					;
					// Join Task: IntroAtom Local NoPrior Mono [(X::0)]play((M::2),(Tm::4))
					intro( new Play(x,m,tm) );
					// Join Task: IntroAtom Local NoPrior NonMono [(X::0)]playLog((M::2),(Tm::4))
					intro( new PlayLog(x,m,tm) );
					note_rule_count++;
				}
				cand_1 = candidates_1.get_next_alive();
			}
		}
		return true;
	}
	
	/*
	**** 4 Join Ordering of Rule empty ****
	Rule Head Variables: (X::0)
	Rule Head Compre Binders: 
	Active #H0 [(X::0)]fire(uscore)
	LookupAtom #H1 13:0:hash<[+]empty()|.>  (X::0) [(X::0)]empty()
	LookupAll #H2 7:0:hash<[+]fire(-)|.>  (X::0) [(X::0)]fire(uscore)
	LookupAll #H3 4:0:hash<[+]edge(-)|.>  (X::0) [(X::0)]edge(uscore)
	LookupAll #H4 3:0:hash<[+]src(-)|.>  (X::0) [(X::0)]src(uscore)
	LookupAll #H5 8:0:hash<[+]playLog(-,-)|.>  (X::0) [(X::0)]playLog(uscore,uscore)
	DeleteHead #H1
	DeleteHead #H2
	DeleteHead #H3
	DeleteHead #H4
	DeleteHead #H5
	*/
	protected boolean execute_fire_join_ordering_2(Fire act) {
		
		int x;
		String anon__1;
		long anon__2;
		int anon__3;
		int anon__4;
		long anon__5;
		// Join Task: Active #H0 [(X::0)]fire(uscore)
		if (act.is_alive()) {
			x = act.loc;
			anon__5 = act.arg1;
			// Join Task: LookupAtom #H1 13:0:hash<[+]empty()|.>  (X::0) [(X::0)]empty()
			StoreIter<Empty> candidates_1 = empty_store_0.lookup_candidates(index0Empty(x));
			Empty cand_1 = candidates_1.get_next_alive();
			while(cand_1 != null) {
				int x__1;
				x__1 = cand_1.loc;
				if (true) {
					// Join Task: LookupAll #H2 7:0:hash<[+]fire(-)|.>  (X::0) [(X::0)]fire(uscore)
					StoreIter<Fire> candidates_2 = fire_store_0.lookup_candidates(index0Fire(x));
					// Join Task: LookupAll #H3 4:0:hash<[+]edge(-)|.>  (X::0) [(X::0)]edge(uscore)
					StoreIter<Edge> candidates_3 = edge_store_0.lookup_candidates(index0Edge(x));
					// Join Task: LookupAll #H4 3:0:hash<[+]src(-)|.>  (X::0) [(X::0)]src(uscore)
					StoreIter<Src> candidates_4 = src_store_0.lookup_candidates(index0Src(x));
					// Join Task: LookupAll #H5 8:0:hash<[+]playLog(-,-)|.>  (X::0) [(X::0)]playLog(uscore,uscore)
					StoreIter<PlayLog> candidates_5 = playlog_store_0.lookup_candidates(index0PlayLog(x));
					// Join Task: DeleteHead #H1
					empty_store_0.remove( cand_1 );
					// Join Task: DeleteHead #H2
					Fire cand_2_0 = candidates_2.get_next_alive();
					while(cand_2_0 != null) {
						fire_store_0.remove( cand_2_0 );
						cand_2_0 = candidates_2.get_next_alive();
					}
					// Join Task: DeleteHead #H3
					Edge cand_3_0 = candidates_3.get_next_alive();
					while(cand_3_0 != null) {
						edge_store_0.remove( cand_3_0 );
						cand_3_0 = candidates_3.get_next_alive();
					}
					// Join Task: DeleteHead #H4
					Src cand_4_0 = candidates_4.get_next_alive();
					while(cand_4_0 != null) {
						src_store_0.remove( cand_4_0 );
						cand_4_0 = candidates_4.get_next_alive();
					}
					// Join Task: DeleteHead #H5
					PlayLog cand_5_0 = candidates_5.get_next_alive();
					while(cand_5_0 != null) {
						playlog_store_0.remove( cand_5_0 );
						cand_5_0 = candidates_5.get_next_alive();
					}
					empty_rule_count++;
					return false;
				}
				cand_1 = candidates_1.get_next_alive();
			}
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule empty ****
	Rule Head Variables: (X::0)
	Rule Head Compre Binders: 
	Active #H0 [(X::0)]playLog(uscore,uscore)
	LookupAtom #H1 13:0:hash<[+]empty()|.>  (X::0) [(X::0)]empty()
	LookupAll #H2 8:0:hash<[+]playLog(-,-)|.>  (X::0) [(X::0)]playLog(uscore,uscore)
	LookupAll #H3 4:0:hash<[+]edge(-)|.>  (X::0) [(X::0)]edge(uscore)
	LookupAll #H4 3:0:hash<[+]src(-)|.>  (X::0) [(X::0)]src(uscore)
	LookupAll #H5 7:0:hash<[+]fire(-)|.>  (X::0) [(X::0)]fire(uscore)
	DeleteHead #H1
	DeleteHead #H2
	DeleteHead #H3
	DeleteHead #H4
	DeleteHead #H5
	*/
	protected boolean execute_playlog_join_ordering_1(PlayLog act) {
		
		int x;
		String anon__1;
		long anon__2;
		int anon__3;
		int anon__4;
		long anon__5;
		// Join Task: Active #H0 [(X::0)]playLog(uscore,uscore)
		if (act.is_alive()) {
			x = act.loc;
			anon__1 = act.arg1;
			anon__2 = act.arg2;
			// Join Task: LookupAtom #H1 13:0:hash<[+]empty()|.>  (X::0) [(X::0)]empty()
			StoreIter<Empty> candidates_1 = empty_store_0.lookup_candidates(index0Empty(x));
			Empty cand_1 = candidates_1.get_next_alive();
			while(cand_1 != null) {
				int x__1;
				x__1 = cand_1.loc;
				if (true) {
					// Join Task: LookupAll #H2 8:0:hash<[+]playLog(-,-)|.>  (X::0) [(X::0)]playLog(uscore,uscore)
					StoreIter<PlayLog> candidates_2 = playlog_store_0.lookup_candidates(index0PlayLog(x));
					// Join Task: LookupAll #H3 4:0:hash<[+]edge(-)|.>  (X::0) [(X::0)]edge(uscore)
					StoreIter<Edge> candidates_3 = edge_store_0.lookup_candidates(index0Edge(x));
					// Join Task: LookupAll #H4 3:0:hash<[+]src(-)|.>  (X::0) [(X::0)]src(uscore)
					StoreIter<Src> candidates_4 = src_store_0.lookup_candidates(index0Src(x));
					// Join Task: LookupAll #H5 7:0:hash<[+]fire(-)|.>  (X::0) [(X::0)]fire(uscore)
					StoreIter<Fire> candidates_5 = fire_store_0.lookup_candidates(index0Fire(x));
					// Join Task: DeleteHead #H1
					empty_store_0.remove( cand_1 );
					// Join Task: DeleteHead #H2
					PlayLog cand_2_0 = candidates_2.get_next_alive();
					while(cand_2_0 != null) {
						playlog_store_0.remove( cand_2_0 );
						cand_2_0 = candidates_2.get_next_alive();
					}
					// Join Task: DeleteHead #H3
					Edge cand_3_0 = candidates_3.get_next_alive();
					while(cand_3_0 != null) {
						edge_store_0.remove( cand_3_0 );
						cand_3_0 = candidates_3.get_next_alive();
					}
					// Join Task: DeleteHead #H4
					Src cand_4_0 = candidates_4.get_next_alive();
					while(cand_4_0 != null) {
						src_store_0.remove( cand_4_0 );
						cand_4_0 = candidates_4.get_next_alive();
					}
					// Join Task: DeleteHead #H5
					Fire cand_5_0 = candidates_5.get_next_alive();
					while(cand_5_0 != null) {
						fire_store_0.remove( cand_5_0 );
						cand_5_0 = candidates_5.get_next_alive();
					}
					empty_rule_count++;
					return false;
				}
				cand_1 = candidates_1.get_next_alive();
			}
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule clear ****
	Rule Head Variables: (I::0), (Ls::1)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]reset()
	LookupAtom #H1 2:0:hash<[+]all(-)|.>  (I::0) [(I::0)]all((Ls::1))
	DeleteHead #H0
	DeleteHead #H1
	IntroCompre Remote NoPrior Mono (L::2) (Ls::1) [(L::2)]empty()
	*/
	protected boolean execute_reset_join_ordering_1(Reset act) {
		
		int i;
		SimpMultiset<Integer>  ls;
		int l;
		// Join Task: Active #H0 [(I::0)]reset()
		i = act.loc;
		// Join Task: LookupAtom #H1 2:0:hash<[+]all(-)|.>  (I::0) [(I::0)]all((Ls::1))
		StoreIter<All> candidates_1 = all_store_0.lookup_candidates(index0All(i));
		All cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int i__1;
			i__1 = cand_1.loc;
			ls = cand_1.arg1;
			if (true) {
				// Join Task: DeleteHead #H0
				// H0 is active and monotone, no delete required
				// Join Task: DeleteHead #H1
				all_store_0.remove( cand_1 );
				// Join Task: IntroCompre Remote NoPrior Mono (L::2) (Ls::1) [(L::2)]empty()
				SimpMultiset<Integer>  comp_0 = ls;
				for(int idx=0; idx<comp_0.size(); idx++) {
					l = comp_0.get(idx);
					send( new Empty(l) ); 
				}
				clear_rule_count++;
				return false;
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule empty ****
	Rule Head Variables: (X::0)
	Rule Head Compre Binders: 
	Active #H0 [(X::0)]empty()
	LookupAll #H1 4:0:hash<[+]edge(-)|.>  (X::0) [(X::0)]edge(uscore)
	LookupAll #H2 3:0:hash<[+]src(-)|.>  (X::0) [(X::0)]src(uscore)
	LookupAll #H3 7:0:hash<[+]fire(-)|.>  (X::0) [(X::0)]fire(uscore)
	LookupAll #H4 8:0:hash<[+]playLog(-,-)|.>  (X::0) [(X::0)]playLog(uscore,uscore)
	DeleteHead #H0
	DeleteHead #H1
	DeleteHead #H2
	DeleteHead #H3
	DeleteHead #H4
	*/
	protected boolean execute_empty_join_ordering_1(Empty act) {
		
		int x;
		String anon__1;
		long anon__2;
		int anon__3;
		int anon__4;
		long anon__5;
		// Join Task: Active #H0 [(X::0)]empty()
		x = act.loc;
		// Join Task: LookupAll #H1 4:0:hash<[+]edge(-)|.>  (X::0) [(X::0)]edge(uscore)
		StoreIter<Edge> candidates_1 = edge_store_0.lookup_candidates(index0Edge(x));
		// Join Task: LookupAll #H2 3:0:hash<[+]src(-)|.>  (X::0) [(X::0)]src(uscore)
		StoreIter<Src> candidates_2 = src_store_0.lookup_candidates(index0Src(x));
		// Join Task: LookupAll #H3 7:0:hash<[+]fire(-)|.>  (X::0) [(X::0)]fire(uscore)
		StoreIter<Fire> candidates_3 = fire_store_0.lookup_candidates(index0Fire(x));
		// Join Task: LookupAll #H4 8:0:hash<[+]playLog(-,-)|.>  (X::0) [(X::0)]playLog(uscore,uscore)
		StoreIter<PlayLog> candidates_4 = playlog_store_0.lookup_candidates(index0PlayLog(x));
		// Join Task: DeleteHead #H0
		// H0 is active and monotone, no delete required
		// Join Task: DeleteHead #H1
		Edge cand_1_0 = candidates_1.get_next_alive();
		while(cand_1_0 != null) {
			edge_store_0.remove( cand_1_0 );
			cand_1_0 = candidates_1.get_next_alive();
		}
		// Join Task: DeleteHead #H2
		Src cand_2_0 = candidates_2.get_next_alive();
		while(cand_2_0 != null) {
			src_store_0.remove( cand_2_0 );
			cand_2_0 = candidates_2.get_next_alive();
		}
		// Join Task: DeleteHead #H3
		Fire cand_3_0 = candidates_3.get_next_alive();
		while(cand_3_0 != null) {
			fire_store_0.remove( cand_3_0 );
			cand_3_0 = candidates_3.get_next_alive();
		}
		// Join Task: DeleteHead #H4
		PlayLog cand_4_0 = candidates_4.get_next_alive();
		while(cand_4_0 != null) {
			playlog_store_0.remove( cand_4_0 );
			cand_4_0 = candidates_4.get_next_alive();
		}
		empty_rule_count++;
		return false;
		
	}
	

	protected void execute(Distribute distribute) {
		if( execute_distribute_join_ordering_1(distribute) ) {
			store( distribute );
		}
	}
	
	protected void execute(Start start) {
		if( execute_start_join_ordering_1(start) ) {
			store( start );
		}
	}
	
	protected void execute(All all) {
		execute_all_join_ordering_1( all );
		if( execute_all_join_ordering_2(all) ) {
			store( all );
		}
	}
	
	protected void execute(Src src) {
		execute_src_join_ordering_1( src );
		if( execute_src_join_ordering_2(src) ) {
		}
	}
	
	protected void execute(Edge edge) {
		execute_edge_join_ordering_1( edge );
		execute_edge_join_ordering_2( edge );
		if( execute_edge_join_ordering_3(edge) ) {
		}
	}
	
	protected void execute(TransScore transscore) {
		if( execute_transscore_join_ordering_1(transscore) ) {
			if( execute_transscore_join_ordering_2(transscore) ) {
				if( execute_transscore_join_ordering_3(transscore) ) {
					store( transscore );
				}
			}
		}
	}
	
	protected void execute(Note note) {
		if( execute_note_join_ordering_1(note) ) {
			if( execute_note_join_ordering_2(note) ) {
			}
		}
	}
	
	protected void execute(Fire fire) {
		execute_fire_join_ordering_1( fire );
		if( execute_fire_join_ordering_2(fire) ) {
		}
	}
	
	protected void execute(PlayLog playlog) {
		if( execute_playlog_join_ordering_1(playlog) ) {
		}
	}
	
	protected void execute(Reset reset) {
		if( execute_reset_join_ordering_1(reset) ) {
			store( reset );
		}
	}
	
	protected void execute(Empty empty) {
		if( execute_empty_join_ordering_1(empty) ) {
			store( empty );
		}
	}
	

	@Override
	public void init() {
	}

}


