package dragracing;

import java.io.Serializable;
import java.util.LinkedList;
import java.util.ListIterator;

import comingle.goals.*;
import comingle.store.*;
import comingle.facts.*;
import comingle.rewrite.*;
import comingle.hash.*;
import comingle.tuple.*;
import comingle.misc.*;
import comingle.mset.*;
import comingle.actuation.*;

import comingle.lib.ExtLib;

import comingle.dragracing.RacerLib;




/**
**  
** Generated by Comingle: Distributed Logic Programming for Decentralized Mobile Ensembles
** Visit https://github.com/sllam/comingle for more information.
** Or contact us:      
**      Edmund Lam          sllam@qatar.cmu.edu
**      Iliano Cervesato    iliano@cmu.edu
**
**/

/**
** This Comingle Runtime is generated from the following Comingle specifications:
ensem dragracing {

	module comingle.lib.ExtLib import {
		mset :: [A] -> {A}.
	}

	module comingle.dragracing.RacerLib import {
		makeChain :: (A,[A]) -> ({(A,A)},A).
	}

	predicate initRace :: [loc] -> trigger.
	predicate go       :: trigger.
	predicate sendTap  :: trigger.
	predicate exiting  :: loc  -> trigger.

	predicate at   :: loc -> fact.
	predicate rmAt :: loc -> fact.
	predicate next :: loc -> fact.
	predicate last :: fact.
	predicate all  :: {loc} -> fact.

	predicate renderTrack :: [loc] -> actuator.
	predicate release   :: actuator.
	predicate recvTap   :: loc -> actuator.
	predicate has       :: loc -> actuator.
	predicate decWinner :: loc -> actuator.

	rule start :: [I]initRace(Ls) 
                         --o { [A]next(B) | (A,B) <- Cs }, [E]last(),
                             { [I]has(P), [P]all(Ps), [P]at(I), [P]renderTrack(Ls) | P <- Ps }
                             where (Cs,E) = makeChain(I,Ls),
                                   Ps = mset(Ls).

	rule go :: [X]all(Ls) \ [X]go() 
                         --o { [L]release() | L <- Ls }. 

	rule update :: [X]rmAt(Y), [X]at(Y) --o 1.

	rule tap :: [X]at(Y) \ [X]sendTap() 
                         --o [Y]recvTap(X).

	rule trans :: [X]next(Z) \ [X]exiting(Y)
                         --o [Z]has(Y), [Y]rmAt(X), [Y]at(Z).
	
	rule win :: [X]last() \ [X]all(Ps), [X]exiting(Y)
                         --o { [P]decWinner(Y) | P <- Ps }.

}
**/


public class Dragracing extends RewriteMachine {

	public class Actuations {
		public static final String rendertrack = "rendertrack";
		public static final String release = "release";
		public static final String recvtap = "recvtap";
		public static final String has = "has";
		public static final String decwinner = "decwinner";
		public static final String delay = "delay";
		public static final String beep = "beep";
		public static final String toast = "toast";
	}

	abstract class DragracingFact extends Fact {
		public DragracingFact(int l) { super(l); }
		public void execute(Dragracing ensem) { }
		public void intro(Dragracing ensem) { }
	}

	public class InitRace extends DragracingFact {
		public LinkedList<Integer>  arg1;
	
		public InitRace(int l, LinkedList<Integer>  a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 0; }
	
		@Override
		public void execute(Dragracing ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Dragracing ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 0, arguments);
		}
	
		public String toString() { return String.format("[%s]InitRace(%s)",loc,arg1); }
	
	}
	
	public class Go extends DragracingFact {
		
	
		public Go(int l) { super(l); }
	
		public int fact_idx() { return 1; }
	
		@Override
		public void execute(Dragracing ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Dragracing ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = {  };
			return new SerializedFact(loc, 1, arguments);
		}
	
		public String toString() { return String.format("[%s]Go()",loc); }
	
	}
	
	public class SendTap extends DragracingFact {
		
	
		public SendTap(int l) { super(l); }
	
		public int fact_idx() { return 2; }
	
		@Override
		public void execute(Dragracing ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Dragracing ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = {  };
			return new SerializedFact(loc, 2, arguments);
		}
	
		public String toString() { return String.format("[%s]SendTap()",loc); }
	
	}
	
	public class Exiting extends DragracingFact {
		public int arg1;
	
		public Exiting(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 3; }
	
		@Override
		public void execute(Dragracing ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Dragracing ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 3, arguments);
		}
	
		public String toString() { return String.format("[%s]Exiting(%s)",loc,arg1); }
	
	}
	
	public class At extends DragracingFact {
		public int arg1;
	
		public At(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 4; }
	
		@Override
		public void execute(Dragracing ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Dragracing ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 4, arguments);
		}
	
		public String toString() { return String.format("[%s]At(%s)",loc,arg1); }
	
	}
	
	public class RmAt extends DragracingFact {
		public int arg1;
	
		public RmAt(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 5; }
	
		@Override
		public void execute(Dragracing ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Dragracing ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 5, arguments);
		}
	
		public String toString() { return String.format("[%s]RmAt(%s)",loc,arg1); }
	
	}
	
	public class Next extends DragracingFact {
		public int arg1;
	
		public Next(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 6; }
	
		@Override
		public void execute(Dragracing ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Dragracing ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 6, arguments);
		}
	
		public String toString() { return String.format("[%s]Next(%s)",loc,arg1); }
	
	}
	
	public class Last extends DragracingFact {
		
	
		public Last(int l) { super(l); }
	
		public int fact_idx() { return 7; }
	
		@Override
		public void execute(Dragracing ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Dragracing ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = {  };
			return new SerializedFact(loc, 7, arguments);
		}
	
		public String toString() { return String.format("[%s]Last()",loc); }
	
	}
	
	public class All extends DragracingFact {
		public SimpMultiset<Integer>  arg1;
	
		public All(int l, SimpMultiset<Integer>  a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 8; }
	
		@Override
		public void execute(Dragracing ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Dragracing ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 8, arguments);
		}
	
		public String toString() { return String.format("[%s]All(%s)",loc,arg1); }
	
	}
	
	public class RenderTrack extends DragracingFact {
		public LinkedList<Integer>  arg1;
	
		public RenderTrack(int l, LinkedList<Integer>  a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 9; }
	
		@Override
		public void execute(Dragracing ensem) { ensem.invokeActuator("rendertrack",arg1); }
	
		@Override
		public void intro(Dragracing ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 9, arguments);
		}
	
		public String toString() { return String.format("[%s]RenderTrack(%s)",loc,arg1); }
	
	}
	
	public class Release extends DragracingFact {
		
	
		public Release(int l) { super(l); }
	
		public int fact_idx() { return 10; }
	
		@Override
		public void execute(Dragracing ensem) { ensem.invokeActuator("release",Tuples.make_unit()); }
	
		@Override
		public void intro(Dragracing ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = {  };
			return new SerializedFact(loc, 10, arguments);
		}
	
		public String toString() { return String.format("[%s]Release()",loc); }
	
	}
	
	public class RecvTap extends DragracingFact {
		public int arg1;
	
		public RecvTap(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 11; }
	
		@Override
		public void execute(Dragracing ensem) { ensem.invokeActuator("recvtap",arg1); }
	
		@Override
		public void intro(Dragracing ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 11, arguments);
		}
	
		public String toString() { return String.format("[%s]RecvTap(%s)",loc,arg1); }
	
	}
	
	public class Has extends DragracingFact {
		public int arg1;
	
		public Has(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 12; }
	
		@Override
		public void execute(Dragracing ensem) { ensem.invokeActuator("has",arg1); }
	
		@Override
		public void intro(Dragracing ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 12, arguments);
		}
	
		public String toString() { return String.format("[%s]Has(%s)",loc,arg1); }
	
	}
	
	public class DecWinner extends DragracingFact {
		public int arg1;
	
		public DecWinner(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 13; }
	
		@Override
		public void execute(Dragracing ensem) { ensem.invokeActuator("decwinner",arg1); }
	
		@Override
		public void intro(Dragracing ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 13, arguments);
		}
	
		public String toString() { return String.format("[%s]DecWinner(%s)",loc,arg1); }
	
	}
	
	public class Delay extends DragracingFact {
		public int arg1;
	
		public Delay(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 14; }
	
		@Override
		public void execute(Dragracing ensem) { ensem.invokeActuator("delay",arg1); }
	
		@Override
		public void intro(Dragracing ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 14, arguments);
		}
	
		public String toString() { return String.format("[%s]Delay(%s)",loc,arg1); }
	
	}
	
	public class Beep extends DragracingFact {
		public String arg1;
	
		public Beep(int l, String a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 15; }
	
		@Override
		public void execute(Dragracing ensem) { ensem.invokeActuator("beep",arg1); }
	
		@Override
		public void intro(Dragracing ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 15, arguments);
		}
	
		public String toString() { return String.format("[%s]Beep(%s)",loc,arg1); }
	
	}
	
	public class Toast extends DragracingFact {
		public String arg1;
	
		public Toast(int l, String a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 16; }
	
		@Override
		public void execute(Dragracing ensem) { ensem.invokeActuator("toast",arg1); }
	
		@Override
		public void intro(Dragracing ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 16, arguments);
		}
	
		public String toString() { return String.format("[%s]Toast(%s)",loc,arg1); }
	
	}
	

	protected static int index0Go(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0SendTap(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0Exiting(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0At(int loc, int arg1) {
		return Hash.join(Hash.hash(loc),Hash.hash(arg1));
	}
	protected static int index1At(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0RmAt(int loc, int arg1) {
		return Hash.join(Hash.hash(loc),Hash.hash(arg1));
	}
	protected static int index0Next(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0Last(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0All(int loc) {
		return Hash.hash(loc);
	}

	protected static final int initrace_fact_idx = 0;
	protected static final int go_fact_idx = 1;
	protected static final int sendtap_fact_idx = 2;
	protected static final int exiting_fact_idx = 3;
	protected static final int at_fact_idx = 4;
	protected static final int rmat_fact_idx = 5;
	protected static final int next_fact_idx = 6;
	protected static final int last_fact_idx = 7;
	protected static final int all_fact_idx = 8;
	protected static final int rendertrack_fact_idx = 9;
	protected static final int release_fact_idx = 10;
	protected static final int recvtap_fact_idx = 11;
	protected static final int has_fact_idx = 12;
	protected static final int decwinner_fact_idx = 13;
	protected static final int delay_fact_idx = 14;
	protected static final int beep_fact_idx = 15;
	protected static final int toast_fact_idx = 16;

	protected Goals<DragracingFact> goals;

	protected ListStore<InitRace> initrace_store_0;
	protected MultiMapStore<Go> go_store_0;
	protected ListStore<Go> go_store_1;
	protected MultiMapStore<SendTap> sendtap_store_0;
	protected ListStore<SendTap> sendtap_store_1;
	protected MultiMapStore<Exiting> exiting_store_0;
	protected ListStore<Exiting> exiting_store_1;
	protected MultiMapStore<At> at_store_0;
	protected MultiMapStore<At> at_store_1;
	protected ListStore<At> at_store_2;
	protected MultiMapStore<RmAt> rmat_store_0;
	protected ListStore<RmAt> rmat_store_1;
	protected MultiMapStore<Next> next_store_0;
	protected ListStore<Next> next_store_1;
	protected MultiMapStore<Last> last_store_0;
	protected ListStore<Last> last_store_1;
	protected MultiMapStore<All> all_store_0;
	protected ListStore<All> all_store_1;

	protected int start_rule_count;
	protected int go_rule_count;
	protected int update_rule_count;
	protected int tap_rule_count;
	protected int trans_rule_count;
	protected int win_rule_count;
	protected int rule_app_misses;

	public Dragracing() {
		super();
	
		start_rule_count = 0;
		go_rule_count = 0;
		update_rule_count = 0;
		tap_rule_count = 0;
		trans_rule_count = 0;
		win_rule_count = 0;
		rule_app_misses = 0;
	
		goals = new ListGoals<DragracingFact>();
		set_goal_component( goals );
	
		initrace_store_0 = new ListStore<InitRace>();
		initrace_store_0.set_name("InitRace Store");
		// set_store_component( initrace_store_0 );
		
		go_store_0 = new MultiMapStore<Go>();
		go_store_0.set_name("Go Store");
		// set_store_component( go_store_0 );
		
		go_store_1 = new ListStore<Go>();
		go_store_1.set_name("Go Store");
		// set_store_component( go_store_1 );
		
		sendtap_store_0 = new MultiMapStore<SendTap>();
		sendtap_store_0.set_name("SendTap Store");
		// set_store_component( sendtap_store_0 );
		
		sendtap_store_1 = new ListStore<SendTap>();
		sendtap_store_1.set_name("SendTap Store");
		// set_store_component( sendtap_store_1 );
		
		exiting_store_0 = new MultiMapStore<Exiting>();
		exiting_store_0.set_name("Exiting Store");
		// set_store_component( exiting_store_0 );
		
		exiting_store_1 = new ListStore<Exiting>();
		exiting_store_1.set_name("Exiting Store");
		// set_store_component( exiting_store_1 );
		
		at_store_0 = new MultiMapStore<At>();
		at_store_0.set_name("At Store");
		// set_store_component( at_store_0 );
		
		at_store_1 = new MultiMapStore<At>();
		at_store_1.set_name("At Store");
		// set_store_component( at_store_1 );
		
		at_store_2 = new ListStore<At>();
		at_store_2.set_name("At Store");
		// set_store_component( at_store_2 );
		
		rmat_store_0 = new MultiMapStore<RmAt>();
		rmat_store_0.set_name("RmAt Store");
		// set_store_component( rmat_store_0 );
		
		rmat_store_1 = new ListStore<RmAt>();
		rmat_store_1.set_name("RmAt Store");
		// set_store_component( rmat_store_1 );
		
		next_store_0 = new MultiMapStore<Next>();
		next_store_0.set_name("Next Store");
		// set_store_component( next_store_0 );
		
		next_store_1 = new ListStore<Next>();
		next_store_1.set_name("Next Store");
		// set_store_component( next_store_1 );
		
		last_store_0 = new MultiMapStore<Last>();
		last_store_0.set_name("Last Store");
		// set_store_component( last_store_0 );
		
		last_store_1 = new ListStore<Last>();
		last_store_1.set_name("Last Store");
		// set_store_component( last_store_1 );
		
		all_store_0 = new MultiMapStore<All>();
		all_store_0.set_name("All Store");
		// set_store_component( all_store_0 );
		
		all_store_1 = new ListStore<All>();
		all_store_1.set_name("All Store");
		// set_store_component( all_store_1 );
		
	
		set_store_component( initrace_store_0 );
		set_store_component( go_store_1 );
		set_store_component( sendtap_store_1 );
		set_store_component( exiting_store_1 );
		set_store_component( at_store_2 );
		set_store_component( rmat_store_1 );
		set_store_component( next_store_1 );
		set_store_component( last_store_1 );
		set_store_component( all_store_1 );
	}
	

	@Override
	protected boolean rewrite() {
		boolean done_something = false;
		while(goals.has_goals()) {
			goals.next().execute( this );
			done_something = true;
		}
		return done_something;
	}
	
	@Override
	protected boolean rewrite(int max_steps) {
		int count = 0;
		while(goals.has_goals() && count < max_steps) {
			goals.next().execute( this );
			count++;
		}
		return count > 0;
	}

	protected DragracingFact demultiplex(SerializedFact fact) {
		Serializable[] args = fact.arguments;
		switch(fact.fact_idx) {
			case 0: return new InitRace(fact.loc,(LinkedList<Integer> ) args[0]);
			
			case 1: return new Go(fact.loc);
			
			case 2: return new SendTap(fact.loc);
			
			case 3: return new Exiting(fact.loc,(Integer) args[0]);
			
			case 4: return new At(fact.loc,(Integer) args[0]);
			
			case 5: return new RmAt(fact.loc,(Integer) args[0]);
			
			case 6: return new Next(fact.loc,(Integer) args[0]);
			
			case 7: return new Last(fact.loc);
			
			case 8: return new All(fact.loc,(SimpMultiset<Integer> ) args[0]);
			
			case 9: return new RenderTrack(fact.loc,(LinkedList<Integer> ) args[0]);
			
			case 10: return new Release(fact.loc);
			
			case 11: return new RecvTap(fact.loc,(Integer) args[0]);
			
			case 12: return new Has(fact.loc,(Integer) args[0]);
			
			case 13: return new DecWinner(fact.loc,(Integer) args[0]);
			
			case 14: return new Delay(fact.loc,(Integer) args[0]);
			
			case 15: return new Beep(fact.loc,(String) args[0]);
			
			case 16: return new Toast(fact.loc,(String) args[0]);
			
		}
		return null;
	}
	
	
	@Override
	protected synchronized boolean flushGoals() {
		if (external_goals.size() == 0) { return false; }
		for (SerializedFact new_goal : external_goals) {
			DragracingFact ef_goal = demultiplex( new_goal );
			ef_goal.intro( this ) ;
		}
		external_goals.clear();
		return true;
	}
	
	protected void store(InitRace initrace) {
		initrace_store_0.add( initrace );
	} 				
	
	protected void store(Go go) {
		go_store_0.add( go, index0Go(go.loc) );
		go_store_1.add( go );
	} 				
	
	protected void store(SendTap sendtap) {
		sendtap_store_0.add( sendtap, index0SendTap(sendtap.loc) );
		sendtap_store_1.add( sendtap );
	} 				
	
	protected void store(Exiting exiting) {
		exiting_store_0.add( exiting, index0Exiting(exiting.loc) );
		exiting_store_1.add( exiting );
	} 				
	
	protected void store(At at) {
		at_store_0.add( at, index0At(at.loc,at.arg1) );
		at_store_1.add( at, index1At(at.loc) );
		at_store_2.add( at );
	} 				
	
	protected void store(RmAt rmat) {
		rmat_store_0.add( rmat, index0RmAt(rmat.loc,rmat.arg1) );
		rmat_store_1.add( rmat );
	} 				
	
	protected void store(Next next) {
		next_store_0.add( next, index0Next(next.loc) );
		next_store_1.add( next );
	} 				
	
	protected void store(Last last) {
		last_store_0.add( last, index0Last(last.loc) );
		last_store_1.add( last );
	} 				
	
	protected void store(All all) {
		all_store_0.add( all, index0All(all.loc) );
		all_store_1.add( all );
	} 				
	
	protected void store(RenderTrack rendertrack) {
		
	} 				
	
	protected void store(Release release) {
		
	} 				
	
	protected void store(RecvTap recvtap) {
		
	} 				
	
	protected void store(Has has) {
		
	} 				
	
	protected void store(DecWinner decwinner) {
		
	} 				
	
	protected void store(Delay delay) {
		
	} 				
	
	protected void store(Beep beep) {
		
	} 				
	
	protected void store(Toast toast) {
		
	} 				
	
	public void add_initrace(int loc,LinkedList<Integer>  arg1) {
		if (isSolo || location == loc) {
			intro( new InitRace(loc,arg1) );
		}
	}
	
	public void add_go(int loc) {
		if (isSolo || location == loc) {
			intro( new Go(loc) );
		}
	}
	
	public void add_sendtap(int loc) {
		if (isSolo || location == loc) {
			intro( new SendTap(loc) );
		}
	}
	
	public void add_exiting(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new Exiting(loc,arg1) );
		}
	}
	
	public void add_at(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new At(loc,arg1) );
		}
	}
	
	public void add_rmat(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new RmAt(loc,arg1) );
		}
	}
	
	public void add_next(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new Next(loc,arg1) );
		}
	}
	
	public void add_last(int loc) {
		if (isSolo || location == loc) {
			intro( new Last(loc) );
		}
	}
	
	public void add_all(int loc,SimpMultiset<Integer>  arg1) {
		if (isSolo || location == loc) {
			intro( new All(loc,arg1) );
		}
	}
	
	public void add_rendertrack(int loc,LinkedList<Integer>  arg1) {
		if (isSolo || location == loc) {
			intro( new RenderTrack(loc,arg1) );
		}
	}
	
	public void add_release(int loc) {
		if (isSolo || location == loc) {
			intro( new Release(loc) );
		}
	}
	
	public void add_recvtap(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new RecvTap(loc,arg1) );
		}
	}
	
	public void add_has(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new Has(loc,arg1) );
		}
	}
	
	public void add_decwinner(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new DecWinner(loc,arg1) );
		}
	}
	
	public void add_delay(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new Delay(loc,arg1) );
		}
	}
	
	public void add_beep(int loc,String arg1) {
		if (isSolo || location == loc) {
			intro( new Beep(loc,arg1) );
		}
	}
	
	public void add_toast(int loc,String arg1) {
		if (isSolo || location == loc) {
			intro( new Toast(loc,arg1) );
		}
	}
	
	protected void intro(InitRace initrace) {
		goals.add( initrace );
		notify_new_goals();
	}
	
	protected void intro(Go go) {
		goals.add( go );
		notify_new_goals();
	}
	
	protected void intro(SendTap sendtap) {
		goals.add( sendtap );
		notify_new_goals();
	}
	
	protected void intro(Exiting exiting) {
		goals.add( exiting );
		notify_new_goals();
	}
	
	protected void intro(At at) {
		goals.add( at );
		notify_new_goals();
	}
	
	protected void intro(RmAt rmat) {
		goals.add( rmat );
		notify_new_goals();
	}
	
	protected void intro(Next next) {
		goals.add( next );
		notify_new_goals();
	}
	
	protected void intro(Last last) {
		goals.add( last );
		notify_new_goals();
	}
	
	protected void intro(All all) {
		goals.add( all );
		notify_new_goals();
	}
	
	protected void intro(RenderTrack rendertrack) {
		goals.add( rendertrack );
		notify_new_goals();
	}
	
	protected void intro(Release release) {
		goals.add( release );
		notify_new_goals();
	}
	
	protected void intro(RecvTap recvtap) {
		goals.add( recvtap );
		notify_new_goals();
	}
	
	protected void intro(Has has) {
		goals.add( has );
		notify_new_goals();
	}
	
	protected void intro(DecWinner decwinner) {
		goals.add( decwinner );
		notify_new_goals();
	}
	
	protected void intro(Delay delay) {
		goals.add( delay );
		store( delay );
		notify_new_goals();
	}	
	
	protected void intro(Beep beep) {
		goals.add( beep );
		store( beep );
		notify_new_goals();
	}	
	
	protected void intro(Toast toast) {
		goals.add( toast );
		store( toast );
		notify_new_goals();
	}	
	
	protected void send(InitRace initrace) {
		if(location == initrace.get_loc()) {
			intro(initrace);
		} else {
			send_buffers.add(initrace);
		}
	}
	
	protected void send(Go go) {
		if(location == go.get_loc()) {
			intro(go);
		} else {
			send_buffers.add(go);
		}
	}
	
	protected void send(SendTap sendtap) {
		if(location == sendtap.get_loc()) {
			intro(sendtap);
		} else {
			send_buffers.add(sendtap);
		}
	}
	
	protected void send(Exiting exiting) {
		if(location == exiting.get_loc()) {
			intro(exiting);
		} else {
			send_buffers.add(exiting);
		}
	}
	
	protected void send(At at) {
		if(location == at.get_loc()) {
			intro(at);
		} else {
			send_buffers.add(at);
		}
	}
	
	protected void send(RmAt rmat) {
		if(location == rmat.get_loc()) {
			intro(rmat);
		} else {
			send_buffers.add(rmat);
		}
	}
	
	protected void send(Next next) {
		if(location == next.get_loc()) {
			intro(next);
		} else {
			send_buffers.add(next);
		}
	}
	
	protected void send(Last last) {
		if(location == last.get_loc()) {
			intro(last);
		} else {
			send_buffers.add(last);
		}
	}
	
	protected void send(All all) {
		if(location == all.get_loc()) {
			intro(all);
		} else {
			send_buffers.add(all);
		}
	}
	
	protected void send(RenderTrack rendertrack) {
		if(location == rendertrack.get_loc()) {
			intro(rendertrack);
		} else {
			send_buffers.add(rendertrack);
		}
	}
	
	protected void send(Release release) {
		if(location == release.get_loc()) {
			intro(release);
		} else {
			send_buffers.add(release);
		}
	}
	
	protected void send(RecvTap recvtap) {
		if(location == recvtap.get_loc()) {
			intro(recvtap);
		} else {
			send_buffers.add(recvtap);
		}
	}
	
	protected void send(Has has) {
		if(location == has.get_loc()) {
			intro(has);
		} else {
			send_buffers.add(has);
		}
	}
	
	protected void send(DecWinner decwinner) {
		if(location == decwinner.get_loc()) {
			intro(decwinner);
		} else {
			send_buffers.add(decwinner);
		}
	}
	
	protected void send(Delay delay) {
		if(location == delay.get_loc()) {
			intro(delay);
		} else {
			send_buffers.add(delay);
		}
	}
	
	protected void send(Beep beep) {
		if(location == beep.get_loc()) {
			intro(beep);
		} else {
			send_buffers.add(beep);
		}
	}
	
	protected void send(Toast toast) {
		if(location == toast.get_loc()) {
			intro(toast);
		} else {
			send_buffers.add(toast);
		}
	}
	
	

	public void addInitRace(LinkedList<Integer>  arg1) {
		intro( new InitRace(location,arg1) );
	}
	
	public void addGo() {
		intro( new Go(location) );
	}
	
	public void addSendTap() {
		intro( new SendTap(location) );
	}
	
	public void addExiting(int arg1) {
		intro( new Exiting(location,arg1) );
	}
	

	public void setRenderTrackActuator(ActuatorAction<LinkedList<Integer> > action) {
		setActuator("rendertrack", action);
	}
	
	public void setReleaseActuator(ActuatorAction<Unit> action) {
		setActuator("release", action);
	}
	
	public void setRecvTapActuator(ActuatorAction<Integer> action) {
		setActuator("recvtap", action);
	}
	
	public void setHasActuator(ActuatorAction<Integer> action) {
		setActuator("has", action);
	}
	
	public void setDecWinnerActuator(ActuatorAction<Integer> action) {
		setActuator("decwinner", action);
	}
	
	public void setDelayActuator(ActuatorAction<Integer> action) {
		setActuator("delay", action);
	}
	
	public void setBeepActuator(ActuatorAction<String> action) {
		setActuator("beep", action);
	}
	
	public void setToastActuator(ActuatorAction<String> action) {
		setActuator("toast", action);
	}
	

	

	public ConcListStore[] getLinearStores() {
		ConcListStore[] stores = new ConcListStore[0];
		
		return stores;
	}
	

	/*
	**** 0 Join Ordering of Rule start ****
	Rule Head Variables: I, Ls
	Rule Head Compre Binders: 
	Active #H0 [I]initRace(Ls)
	DeleteHead #H0
	LetBind (Cs,E) makeChain((I,Ls))
	LetBind Ps mset(Ls)
	IntroAtom Remote NoPrior Mono [E]last()
	IntroCompre Remote NoPrior Mono A,B Cs [A]next(B)
	IntroCompre Local NoPrior Mono P Ps [I]has(P)
	*/
	protected boolean execute_initrace_join_ordering_1(InitRace act) {
		
		int a;
		SimpMultiset<Integer>  ps;
		int b;
		int e;
		int i;
		int p;
		LinkedList<Integer>  ls;
		SimpMultiset<Tuple2<Integer,Integer> >  cs;
		// Join Task: Active #H0 [I]initRace(Ls)
		i = act.loc;
		ls = act.arg1;
		// Join Task: DeleteHead #H0
		// H0 is active and monotone, no delete required
		// Join Task: LetBind (Cs,E) makeChain((I,Ls))
		Tuple2<SimpMultiset<Tuple2<Integer,Integer> > ,Integer>  tup0;
		tup0 = RacerLib.makeChain(i,ls);
		cs = tup0.t1;
		e = tup0.t2;
		;
		// Join Task: LetBind Ps mset(Ls)
		ps = ExtLib.mset(ls);
		;
		// Join Task: IntroAtom Remote NoPrior Mono [E]last()
		send( new Last(e) ); 
		// Join Task: IntroCompre Remote NoPrior Mono A,B Cs [A]next(B)
		SimpMultiset<Tuple2<Integer,Integer> >  comp_0 = cs;
		for(int idx=0; idx<comp_0.size(); idx++) {
			Tuple2<Integer,Integer>  tup1;
			tup1 = comp_0.get(idx);
			a = tup1.t1;
			b = tup1.t2;
			send( new Next(a,b) ); 
		}
		// Join Task: IntroCompre Local NoPrior Mono P Ps [I]has(P)
		SimpMultiset<Integer>  comp_1 = ps;
		for(int idx=0; idx<comp_1.size(); idx++) {
			p = comp_1.get(idx);
			intro( new Has(i,p) );
			send( new All(p,ps) ); 
			send( new At(p,i) ); 
			send( new RenderTrack(p,ls) ); 
		}
		start_rule_count++;
		return false;
		
	}
	
	/*
	**** 0 Join Ordering of Rule go ****
	Rule Head Variables: X, Ls
	Rule Head Compre Binders: 
	Active #H0 [X]go()
	LookupAtom #H1 8:0:hash<[+]all(-)|.>  X [X]all(Ls)
	DeleteHead #H0
	IntroCompre Remote NoPrior Mono L Ls [L]release()
	*/
	protected boolean execute_go_join_ordering_1(Go act) {
		
		int x;
		SimpMultiset<Integer>  ls;
		int l;
		// Join Task: Active #H0 [X]go()
		x = act.loc;
		// Join Task: LookupAtom #H1 8:0:hash<[+]all(-)|.>  X [X]all(Ls)
		StoreIter<All> candidates_1 = all_store_0.lookup_candidates(index0All(x));
		All cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int x1;
			x1 = cand_1.loc;
			ls = cand_1.arg1;
			if (true) {
				// Join Task: DeleteHead #H0
				// H0 is active and monotone, no delete required
				// Join Task: IntroCompre Remote NoPrior Mono L Ls [L]release()
				SimpMultiset<Integer>  comp_0 = ls;
				for(int idx=0; idx<comp_0.size(); idx++) {
					l = comp_0.get(idx);
					send( new Release(l) ); 
				}
				go_rule_count++;
				return false;
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule tap ****
	Rule Head Variables: Y, X
	Rule Head Compre Binders: 
	Active #H0 [X]sendTap()
	LookupAtom #H1 4:1:hash<[+]at(-)|.>  X [X]at(Y)
	DeleteHead #H0
	IntroAtom Remote NoPrior Mono [Y]recvTap(X)
	*/
	protected boolean execute_sendtap_join_ordering_1(SendTap act) {
		
		int y;
		int x;
		// Join Task: Active #H0 [X]sendTap()
		x = act.loc;
		// Join Task: LookupAtom #H1 4:1:hash<[+]at(-)|.>  X [X]at(Y)
		StoreIter<At> candidates_1 = at_store_1.lookup_candidates(index1At(x));
		At cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int x1;
			x1 = cand_1.loc;
			y = cand_1.arg1;
			if (true) {
				// Join Task: DeleteHead #H0
				// H0 is active and monotone, no delete required
				// Join Task: IntroAtom Remote NoPrior Mono [Y]recvTap(X)
				send( new RecvTap(y,x) ); 
				tap_rule_count++;
				return false;
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule trans ****
	Rule Head Variables: Y, X, Z
	Rule Head Compre Binders: 
	Active #H0 [X]exiting(Y)
	LookupAtom #H1 6:0:hash<[+]next(-)|.>  X [X]next(Z)
	DeleteHead #H0
	IntroAtom Remote NoPrior Mono [Z]has(Y)
	IntroAtom Remote NoPrior Mono [Y]rmAt(X)
	IntroAtom Remote NoPrior Mono [Y]at(Z)
	*/
	protected boolean execute_exiting_join_ordering_1(Exiting act) {
		
		int y;
		int x;
		int z;
		// Join Task: Active #H0 [X]exiting(Y)
		x = act.loc;
		y = act.arg1;
		// Join Task: LookupAtom #H1 6:0:hash<[+]next(-)|.>  X [X]next(Z)
		StoreIter<Next> candidates_1 = next_store_0.lookup_candidates(index0Next(x));
		Next cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int x1;
			x1 = cand_1.loc;
			z = cand_1.arg1;
			if (true) {
				// Join Task: DeleteHead #H0
				// H0 is active and monotone, no delete required
				// Join Task: IntroAtom Remote NoPrior Mono [Z]has(Y)
				send( new Has(z,y) ); 
				// Join Task: IntroAtom Remote NoPrior Mono [Y]rmAt(X)
				send( new RmAt(y,x) ); 
				// Join Task: IntroAtom Remote NoPrior Mono [Y]at(Z)
				send( new At(y,z) ); 
				trans_rule_count++;
				return false;
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule win ****
	Rule Head Variables: Y, X, Ps
	Rule Head Compre Binders: 
	Active #H0 [X]exiting(Y)
	LookupAtom #H1 7:0:hash<[+]last()|.>  X [X]last()
	LookupAtom #H2 8:0:hash<[+]all(-)|.>  X [X]all(Ps)
	DeleteHead #H0
	DeleteHead #H2
	IntroCompre Remote NoPrior Mono P Ps [P]decWinner(Y)
	*/
	protected boolean execute_exiting_join_ordering_2(Exiting act) {
		
		int y;
		int x;
		int p;
		SimpMultiset<Integer>  ps;
		// Join Task: Active #H0 [X]exiting(Y)
		x = act.loc;
		y = act.arg1;
		// Join Task: LookupAtom #H1 7:0:hash<[+]last()|.>  X [X]last()
		StoreIter<Last> candidates_1 = last_store_0.lookup_candidates(index0Last(x));
		Last cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int x1;
			x1 = cand_1.loc;
			if (true) {
				// Join Task: LookupAtom #H2 8:0:hash<[+]all(-)|.>  X [X]all(Ps)
				StoreIter<All> candidates_2 = all_store_0.lookup_candidates(index0All(x));
				All cand_2 = candidates_2.get_next_alive();
				while(cand_2 != null) {
					int x2;
					x2 = cand_2.loc;
					ps = cand_2.arg1;
					if (true) {
						// Join Task: DeleteHead #H0
						// H0 is active and monotone, no delete required
						// Join Task: DeleteHead #H2
						all_store_0.remove( cand_2 );
						// Join Task: IntroCompre Remote NoPrior Mono P Ps [P]decWinner(Y)
						SimpMultiset<Integer>  comp_0 = ps;
						for(int idx=0; idx<comp_0.size(); idx++) {
							p = comp_0.get(idx);
							send( new DecWinner(p,y) ); 
						}
						win_rule_count++;
						return false;
					}
					cand_2 = candidates_2.get_next_alive();
				}
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule update ****
	Rule Head Variables: Y, X
	Rule Head Compre Binders: 
	Active #H0 [X]at(Y)
	LookupAtom #H1 5:0:hash<[+]rmAt(+)|.>  X,Y [X]rmAt(Y)
	DeleteHead #H0
	DeleteHead #H1
	*/
	protected boolean execute_at_join_ordering_1(At act) {
		
		int y;
		int x;
		// Join Task: Active #H0 [X]at(Y)
		x = act.loc;
		y = act.arg1;
		// Join Task: LookupAtom #H1 5:0:hash<[+]rmAt(+)|.>  X,Y [X]rmAt(Y)
		StoreIter<RmAt> candidates_1 = rmat_store_0.lookup_candidates(index0RmAt(x,y));
		RmAt cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int x1;
			int y1;
			x1 = cand_1.loc;
			y1 = cand_1.arg1;
			if (Equality.is_eq(x,x1) && Equality.is_eq(y,y1)) {
				// Join Task: DeleteHead #H0
				// H0 is active and monotone, no delete required
				// Join Task: DeleteHead #H1
				rmat_store_0.remove( cand_1 );
				update_rule_count++;
				return false;
			} else {
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule tap ****
	Rule Head Variables: Y, X
	Rule Head Compre Binders: 
	Active #H0 [X]at(Y)
	LookupAtom #H1 2:0:hash<[+]sendTap()|.>  X [X]sendTap()
	DeleteHead #H1
	IntroAtom Remote NoPrior Mono [Y]recvTap(X)
	*/
	protected boolean execute_at_join_ordering_2(At act) {
		
		int y;
		int x;
		// Join Task: Active #H0 [X]at(Y)
		x = act.loc;
		y = act.arg1;
		// Join Task: LookupAtom #H1 2:0:hash<[+]sendTap()|.>  X [X]sendTap()
		StoreIter<SendTap> candidates_1 = sendtap_store_0.lookup_candidates(index0SendTap(x));
		SendTap cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int x1;
			x1 = cand_1.loc;
			if (true) {
				// Join Task: DeleteHead #H1
				sendtap_store_0.remove( cand_1 );
				// Join Task: IntroAtom Remote NoPrior Mono [Y]recvTap(X)
				send( new RecvTap(y,x) ); 
				tap_rule_count++;
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule update ****
	Rule Head Variables: Y, X
	Rule Head Compre Binders: 
	Active #H0 [X]rmAt(Y)
	LookupAtom #H1 4:0:hash<[+]at(+)|.>  X,Y [X]at(Y)
	DeleteHead #H0
	DeleteHead #H1
	*/
	protected boolean execute_rmat_join_ordering_1(RmAt act) {
		
		int y;
		int x;
		// Join Task: Active #H0 [X]rmAt(Y)
		x = act.loc;
		y = act.arg1;
		// Join Task: LookupAtom #H1 4:0:hash<[+]at(+)|.>  X,Y [X]at(Y)
		StoreIter<At> candidates_1 = at_store_0.lookup_candidates(index0At(x,y));
		At cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int x1;
			int y1;
			x1 = cand_1.loc;
			y1 = cand_1.arg1;
			if (Equality.is_eq(x,x1) && Equality.is_eq(y,y1)) {
				// Join Task: DeleteHead #H0
				// H0 is active and monotone, no delete required
				// Join Task: DeleteHead #H1
				at_store_0.remove( cand_1 );
				update_rule_count++;
				return false;
			} else {
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule trans ****
	Rule Head Variables: Y, X, Z
	Rule Head Compre Binders: 
	Active #H0 [X]next(Z)
	LookupAtom #H1 3:0:hash<[+]exiting(-)|.>  X [X]exiting(Y)
	DeleteHead #H1
	IntroAtom Remote NoPrior Mono [Z]has(Y)
	IntroAtom Remote NoPrior Mono [Y]rmAt(X)
	IntroAtom Remote NoPrior Mono [Y]at(Z)
	*/
	protected boolean execute_next_join_ordering_1(Next act) {
		
		int y;
		int x;
		int z;
		// Join Task: Active #H0 [X]next(Z)
		x = act.loc;
		z = act.arg1;
		// Join Task: LookupAtom #H1 3:0:hash<[+]exiting(-)|.>  X [X]exiting(Y)
		StoreIter<Exiting> candidates_1 = exiting_store_0.lookup_candidates(index0Exiting(x));
		Exiting cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int x1;
			x1 = cand_1.loc;
			y = cand_1.arg1;
			if (true) {
				// Join Task: DeleteHead #H1
				exiting_store_0.remove( cand_1 );
				// Join Task: IntroAtom Remote NoPrior Mono [Z]has(Y)
				send( new Has(z,y) ); 
				// Join Task: IntroAtom Remote NoPrior Mono [Y]rmAt(X)
				send( new RmAt(y,x) ); 
				// Join Task: IntroAtom Remote NoPrior Mono [Y]at(Z)
				send( new At(y,z) ); 
				trans_rule_count++;
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 2 Join Ordering of Rule win ****
	Rule Head Variables: Y, X, Ps
	Rule Head Compre Binders: 
	Active #H0 [X]last()
	LookupAtom #H1 8:0:hash<[+]all(-)|.>  X [X]all(Ps)
	LookupAtom #H2 3:0:hash<[+]exiting(-)|.>  X [X]exiting(Y)
	DeleteHead #H1
	DeleteHead #H2
	IntroCompre Remote NoPrior Mono P Ps [P]decWinner(Y)
	*/
	protected boolean execute_last_join_ordering_1(Last act) {
		
		int y;
		int x;
		int p;
		SimpMultiset<Integer>  ps;
		// Join Task: Active #H0 [X]last()
		x = act.loc;
		// Join Task: LookupAtom #H1 8:0:hash<[+]all(-)|.>  X [X]all(Ps)
		StoreIter<All> candidates_1 = all_store_0.lookup_candidates(index0All(x));
		All cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int x1;
			x1 = cand_1.loc;
			ps = cand_1.arg1;
			if (true) {
				// Join Task: LookupAtom #H2 3:0:hash<[+]exiting(-)|.>  X [X]exiting(Y)
				StoreIter<Exiting> candidates_2 = exiting_store_0.lookup_candidates(index0Exiting(x));
				Exiting cand_2 = candidates_2.get_next_alive();
				while(cand_2 != null) {
					int x2;
					x2 = cand_2.loc;
					y = cand_2.arg1;
					if (true) {
						// Join Task: DeleteHead #H1
						all_store_0.remove( cand_1 );
						// Join Task: DeleteHead #H2
						exiting_store_0.remove( cand_2 );
						// Join Task: IntroCompre Remote NoPrior Mono P Ps [P]decWinner(Y)
						SimpMultiset<Integer>  comp_0 = ps;
						for(int idx=0; idx<comp_0.size(); idx++) {
							p = comp_0.get(idx);
							send( new DecWinner(p,y) ); 
						}
						win_rule_count++;
					}
					cand_2 = candidates_2.get_next_alive();
				}
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule go ****
	Rule Head Variables: X, Ls
	Rule Head Compre Binders: 
	Active #H0 [X]all(Ls)
	LookupAtom #H1 1:0:hash<[+]go()|.>  X [X]go()
	DeleteHead #H1
	IntroCompre Remote NoPrior Mono L Ls [L]release()
	*/
	protected boolean execute_all_join_ordering_1(All act) {
		
		int x;
		SimpMultiset<Integer>  ls;
		int l;
		// Join Task: Active #H0 [X]all(Ls)
		x = act.loc;
		ls = act.arg1;
		// Join Task: LookupAtom #H1 1:0:hash<[+]go()|.>  X [X]go()
		StoreIter<Go> candidates_1 = go_store_0.lookup_candidates(index0Go(x));
		Go cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int x1;
			x1 = cand_1.loc;
			if (true) {
				// Join Task: DeleteHead #H1
				go_store_0.remove( cand_1 );
				// Join Task: IntroCompre Remote NoPrior Mono L Ls [L]release()
				SimpMultiset<Integer>  comp_0 = ls;
				for(int idx=0; idx<comp_0.size(); idx++) {
					l = comp_0.get(idx);
					send( new Release(l) ); 
				}
				go_rule_count++;
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule win ****
	Rule Head Variables: Y, X, Ps
	Rule Head Compre Binders: 
	Active #H0 [X]all(Ps)
	LookupAtom #H1 7:0:hash<[+]last()|.>  X [X]last()
	LookupAtom #H2 3:0:hash<[+]exiting(-)|.>  X [X]exiting(Y)
	DeleteHead #H0
	DeleteHead #H2
	IntroCompre Remote NoPrior Mono P Ps [P]decWinner(Y)
	*/
	protected boolean execute_all_join_ordering_2(All act) {
		
		int y;
		int x;
		int p;
		SimpMultiset<Integer>  ps;
		// Join Task: Active #H0 [X]all(Ps)
		x = act.loc;
		ps = act.arg1;
		// Join Task: LookupAtom #H1 7:0:hash<[+]last()|.>  X [X]last()
		StoreIter<Last> candidates_1 = last_store_0.lookup_candidates(index0Last(x));
		Last cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int x1;
			x1 = cand_1.loc;
			if (true) {
				// Join Task: LookupAtom #H2 3:0:hash<[+]exiting(-)|.>  X [X]exiting(Y)
				StoreIter<Exiting> candidates_2 = exiting_store_0.lookup_candidates(index0Exiting(x));
				Exiting cand_2 = candidates_2.get_next_alive();
				while(cand_2 != null) {
					int x2;
					x2 = cand_2.loc;
					y = cand_2.arg1;
					if (true) {
						// Join Task: DeleteHead #H0
						// H0 is active and monotone, no delete required
						// Join Task: DeleteHead #H2
						exiting_store_0.remove( cand_2 );
						// Join Task: IntroCompre Remote NoPrior Mono P Ps [P]decWinner(Y)
						SimpMultiset<Integer>  comp_0 = ps;
						for(int idx=0; idx<comp_0.size(); idx++) {
							p = comp_0.get(idx);
							send( new DecWinner(p,y) ); 
						}
						win_rule_count++;
						return false;
					}
					cand_2 = candidates_2.get_next_alive();
				}
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	

	protected void execute(InitRace initrace) {
		if( execute_initrace_join_ordering_1(initrace) ) {
			store( initrace );
		}
	}
	
	protected void execute(Go go) {
		if( execute_go_join_ordering_1(go) ) {
			store( go );
		}
	}
	
	protected void execute(SendTap sendtap) {
		if( execute_sendtap_join_ordering_1(sendtap) ) {
			store( sendtap );
		}
	}
	
	protected void execute(Exiting exiting) {
		if( execute_exiting_join_ordering_1(exiting) ) {
			if( execute_exiting_join_ordering_2(exiting) ) {
				store( exiting );
			}
		}
	}
	
	protected void execute(At at) {
		if( execute_at_join_ordering_1(at) ) {
			execute_at_join_ordering_2( at );
			store( at );
		}
	}
	
	protected void execute(RmAt rmat) {
		if( execute_rmat_join_ordering_1(rmat) ) {
			store( rmat );
		}
	}
	
	protected void execute(Next next) {
		execute_next_join_ordering_1( next );
		store( next );
	}
	
	protected void execute(Last last) {
		execute_last_join_ordering_1( last );
		store( last );
	}
	
	protected void execute(All all) {
		execute_all_join_ordering_1( all );
		if( execute_all_join_ordering_2(all) ) {
			store( all );
		}
	}
	

	@Override
	public void init() {
	}

}


