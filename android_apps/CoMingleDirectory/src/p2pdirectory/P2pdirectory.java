package p2pdirectory;

import java.io.Serializable;
import java.util.LinkedList;
import java.util.ListIterator;

import comingle.goals.*;
import comingle.store.*;
import comingle.facts.*;
import comingle.rewrite.*;
import comingle.hash.*;
import comingle.tuple.*;
import comingle.misc.*;
import comingle.mset.*;
import comingle.actuation.*;

import comingle.lib.ExtLib;

import p2pdirectory.WifiDirectComingleDirectory;




/**
**  
** Generated by Comingle: Distributed Logic Programming for Decentralized Mobile Ensembles
** Visit https://github.com/sllam/comingle for more information.
** Or contact us:      
**      Edmund Lam          sllam@qatar.cmu.edu
**      Iliano Cervesato    iliano@cmu.edu
**
**/

/**
** This Comingle Runtime is generated from the following Comingle specifications:
ensem p2pdirectory {

	module comingle.lib.ExtLib import {
		not  :: bool -> bool.
	}

	module p2pdirectory.WifiDirectComingleDirectory import {
		ownerLoc :: int -> loc.
		lookupIP :: loc -> string.
		retrieveDir :: int -> {(loc,string,string)}.
	}

	predicate startOwner  :: string -> trigger.
	predicate startMember :: string -> trigger.
	predicate quit        :: trigger.
	predicate connect     :: string -> trigger.

	predicate joined      :: loc -> fact.
	predicate member      :: string -> fact.
	predicate owner       :: string -> fact.
	predicate joinRequest :: (string,string,loc) -> fact.
	predicate exit        :: loc -> fact.

	predicate added   :: (loc,string,string) -> actuator.
	predicate removed :: loc -> actuator.
	predicate connected :: actuator.
	predicate ownerQuit :: actuator.
	predicate deleteDir :: actuator.

	rule startOwner  :: [O]startOwner(C) --o [O]owner(C), [O]joined(O).

	rule startMember :: [M]startMember(C) --o [M]member(C).

	rule connect :: [M]member(C) \ [M]connect(N) 
                              --o [O]joinRequest(C,N,M) where O = ownerLoc(0).

	rule join :: [O]owner(C), {[O]joined(M)|M->Ms}
                     \ [O]joinRequest(C,NewN,NewM) | not(NewM in Ms) 
                            --o { [M]added(NewM,NewIP,NewN) | M<-Ms }, 
                                { [NewM]added(M,IP,N) | (M,IP,N)<-Ds }, [NewM]added(NewM,NewIP,NewN),
                                [O]joined(NewM), [NewM]connected()
                                where NewIP = lookupIP(NewM),
                                      Ds = retrieveDir(0).

	rule quitO  :: [O]owner(C), [O]quit(), {[O]joined(P)|P->Ps} 
                                 --o { [P]ownerQuit() | P<-Ps }.

	rule quitM :: [M]member(C) \ [M]quit() --o [O]exit(M) where O = ownerLoc(0).

	rule exit  :: { [O]joined(M) | M->Ms. not(M == N) } \ [O]exit(N), [O]joined(N) 
                            --o { [M]removed(N) | M<-Ms }, [N]deleteDir().

}
**/


public class P2pdirectory extends RewriteMachine {

	public class Actuations {
		public static final String added = "added";
		public static final String removed = "removed";
		public static final String connected = "connected";
		public static final String ownerquit = "ownerquit";
		public static final String deletedir = "deletedir";
		public static final String delay = "delay";
		public static final String beep = "beep";
		public static final String toast = "toast";
	}

	abstract class P2pdirectoryFact extends Fact {
		public P2pdirectoryFact(int l) { super(l); }
		public void execute(P2pdirectory ensem) { }
		public void intro(P2pdirectory ensem) { }
	}

	public class StartOwner extends P2pdirectoryFact {
		public String arg1;
	
		public StartOwner(int l, String a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 0; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 0, arguments);
		}
	
		public String toString() { return String.format("[%s]StartOwner(%s)",loc,arg1); }
	
	}
	
	public class StartMember extends P2pdirectoryFact {
		public String arg1;
	
		public StartMember(int l, String a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 1; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 1, arguments);
		}
	
		public String toString() { return String.format("[%s]StartMember(%s)",loc,arg1); }
	
	}
	
	public class Quit extends P2pdirectoryFact {
		
	
		public Quit(int l) { super(l); }
	
		public int fact_idx() { return 2; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = {  };
			return new SerializedFact(loc, 2, arguments);
		}
	
		public String toString() { return String.format("[%s]Quit()",loc); }
	
	}
	
	public class Connect extends P2pdirectoryFact {
		public String arg1;
	
		public Connect(int l, String a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 3; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 3, arguments);
		}
	
		public String toString() { return String.format("[%s]Connect(%s)",loc,arg1); }
	
	}
	
	public class Joined extends P2pdirectoryFact {
		public int arg1;
	
		public Joined(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 4; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 4, arguments);
		}
	
		public String toString() { return String.format("[%s]Joined(%s)",loc,arg1); }
	
	}
	
	public class Member extends P2pdirectoryFact {
		public String arg1;
	
		public Member(int l, String a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 5; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 5, arguments);
		}
	
		public String toString() { return String.format("[%s]Member(%s)",loc,arg1); }
	
	}
	
	public class Owner extends P2pdirectoryFact {
		public String arg1;
	
		public Owner(int l, String a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 6; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 6, arguments);
		}
	
		public String toString() { return String.format("[%s]Owner(%s)",loc,arg1); }
	
	}
	
	public class JoinRequest extends P2pdirectoryFact {
		public String arg1;
		public String arg2;
		public int arg3;
	
		public JoinRequest(int l, String a1, String a2, int a3) { super(l); arg1=a1; arg2=a2; arg3=a3; }
	
		public int fact_idx() { return 7; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1, (Serializable) arg2, (Serializable) arg3 };
			return new SerializedFact(loc, 7, arguments);
		}
	
		public String toString() { return String.format("[%s]JoinRequest(%s,%s,%s)",loc,arg1,arg2,arg3); }
	
	}
	
	public class Exit extends P2pdirectoryFact {
		public int arg1;
	
		public Exit(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 8; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 8, arguments);
		}
	
		public String toString() { return String.format("[%s]Exit(%s)",loc,arg1); }
	
	}
	
	public class Added extends P2pdirectoryFact {
		public int arg1;
		public String arg2;
		public String arg3;
	
		public Added(int l, int a1, String a2, String a3) { super(l); arg1=a1; arg2=a2; arg3=a3; }
	
		public int fact_idx() { return 9; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.invokeActuator("added",Tuples.make_tuple(arg1,arg2,arg3)); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1, (Serializable) arg2, (Serializable) arg3 };
			return new SerializedFact(loc, 9, arguments);
		}
	
		public String toString() { return String.format("[%s]Added(%s,%s,%s)",loc,arg1,arg2,arg3); }
	
	}
	
	public class Removed extends P2pdirectoryFact {
		public int arg1;
	
		public Removed(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 10; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.invokeActuator("removed",arg1); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 10, arguments);
		}
	
		public String toString() { return String.format("[%s]Removed(%s)",loc,arg1); }
	
	}
	
	public class Connected extends P2pdirectoryFact {
		
	
		public Connected(int l) { super(l); }
	
		public int fact_idx() { return 11; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.invokeActuator("connected",Tuples.make_unit()); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = {  };
			return new SerializedFact(loc, 11, arguments);
		}
	
		public String toString() { return String.format("[%s]Connected()",loc); }
	
	}
	
	public class OwnerQuit extends P2pdirectoryFact {
		
	
		public OwnerQuit(int l) { super(l); }
	
		public int fact_idx() { return 12; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.invokeActuator("ownerquit",Tuples.make_unit()); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = {  };
			return new SerializedFact(loc, 12, arguments);
		}
	
		public String toString() { return String.format("[%s]OwnerQuit()",loc); }
	
	}
	
	public class DeleteDir extends P2pdirectoryFact {
		
	
		public DeleteDir(int l) { super(l); }
	
		public int fact_idx() { return 13; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.invokeActuator("deletedir",Tuples.make_unit()); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = {  };
			return new SerializedFact(loc, 13, arguments);
		}
	
		public String toString() { return String.format("[%s]DeleteDir()",loc); }
	
	}
	
	public class Delay extends P2pdirectoryFact {
		public int arg1;
	
		public Delay(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 14; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.invokeActuator("delay",arg1); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 14, arguments);
		}
	
		public String toString() { return String.format("[%s]Delay(%s)",loc,arg1); }
	
	}
	
	public class Beep extends P2pdirectoryFact {
		public String arg1;
	
		public Beep(int l, String a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 15; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.invokeActuator("beep",arg1); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 15, arguments);
		}
	
		public String toString() { return String.format("[%s]Beep(%s)",loc,arg1); }
	
	}
	
	public class Toast extends P2pdirectoryFact {
		public String arg1;
	
		public Toast(int l, String a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 16; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.invokeActuator("toast",arg1); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 16, arguments);
		}
	
		public String toString() { return String.format("[%s]Toast(%s)",loc,arg1); }
	
	}
	

	protected static int index0Quit(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0Connect(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0Joined(int loc) {
		return Hash.hash(loc);
	}
	protected static int index1Joined(int loc, int arg1) {
		return Hash.join(Hash.hash(loc),Hash.hash(arg1));
	}
	protected static int index0Member(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0Owner(int loc, String arg1) {
		return Hash.join(Hash.hash(loc),Hash.hash(arg1));
	}
	protected static int index1Owner(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0JoinRequest(int loc, String arg1) {
		return Hash.join(Hash.hash(loc),Hash.hash(arg1));
	}
	protected static int index0Exit(int loc, int arg1) {
		return Hash.join(Hash.hash(loc),Hash.hash(arg1));
	}
	protected static int index1Exit(int loc) {
		return Hash.hash(loc);
	}

	protected static final int startowner_fact_idx = 0;
	protected static final int startmember_fact_idx = 1;
	protected static final int quit_fact_idx = 2;
	protected static final int connect_fact_idx = 3;
	protected static final int joined_fact_idx = 4;
	protected static final int member_fact_idx = 5;
	protected static final int owner_fact_idx = 6;
	protected static final int joinrequest_fact_idx = 7;
	protected static final int exit_fact_idx = 8;
	protected static final int added_fact_idx = 9;
	protected static final int removed_fact_idx = 10;
	protected static final int connected_fact_idx = 11;
	protected static final int ownerquit_fact_idx = 12;
	protected static final int deletedir_fact_idx = 13;
	protected static final int delay_fact_idx = 14;
	protected static final int beep_fact_idx = 15;
	protected static final int toast_fact_idx = 16;

	protected Goals<P2pdirectoryFact> goals;

	protected ListStore<StartOwner> startowner_store_0;
	protected ListStore<StartMember> startmember_store_0;
	protected MultiMapStore<Quit> quit_store_0;
	protected ListStore<Quit> quit_store_1;
	protected MultiMapStore<Connect> connect_store_0;
	protected ListStore<Connect> connect_store_1;
	protected MultiMapStore<Joined> joined_store_0;
	protected MultiMapStore<Joined> joined_store_1;
	protected ListStore<Joined> joined_store_2;
	protected MultiMapStore<Member> member_store_0;
	protected ListStore<Member> member_store_1;
	protected MultiMapStore<Owner> owner_store_0;
	protected MultiMapStore<Owner> owner_store_1;
	protected ListStore<Owner> owner_store_2;
	protected MultiMapStore<JoinRequest> joinrequest_store_0;
	protected ListStore<JoinRequest> joinrequest_store_1;
	protected MultiMapStore<Exit> exit_store_0;
	protected MultiMapStore<Exit> exit_store_1;
	protected ListStore<Exit> exit_store_2;

	protected int startOwner_rule_count;
	protected int startMember_rule_count;
	protected int connect_rule_count;
	protected int join_rule_count;
	protected int quitO_rule_count;
	protected int quitM_rule_count;
	protected int exit_rule_count;
	protected int rule_app_misses;

	public P2pdirectory() {
		super();
	
		startOwner_rule_count = 0;
		startMember_rule_count = 0;
		connect_rule_count = 0;
		join_rule_count = 0;
		quitO_rule_count = 0;
		quitM_rule_count = 0;
		exit_rule_count = 0;
		rule_app_misses = 0;
	
		goals = new ListGoals<P2pdirectoryFact>();
		set_goal_component( goals );
	
		startowner_store_0 = new ListStore<StartOwner>();
		startowner_store_0.set_name("StartOwner Store");
		// set_store_component( startowner_store_0 );
		
		startmember_store_0 = new ListStore<StartMember>();
		startmember_store_0.set_name("StartMember Store");
		// set_store_component( startmember_store_0 );
		
		quit_store_0 = new MultiMapStore<Quit>();
		quit_store_0.set_name("Quit Store");
		// set_store_component( quit_store_0 );
		
		quit_store_1 = new ListStore<Quit>();
		quit_store_1.set_name("Quit Store");
		// set_store_component( quit_store_1 );
		
		connect_store_0 = new MultiMapStore<Connect>();
		connect_store_0.set_name("Connect Store");
		// set_store_component( connect_store_0 );
		
		connect_store_1 = new ListStore<Connect>();
		connect_store_1.set_name("Connect Store");
		// set_store_component( connect_store_1 );
		
		joined_store_0 = new MultiMapStore<Joined>();
		joined_store_0.set_name("Joined Store");
		// set_store_component( joined_store_0 );
		
		joined_store_1 = new MultiMapStore<Joined>();
		joined_store_1.set_name("Joined Store");
		// set_store_component( joined_store_1 );
		
		joined_store_2 = new ListStore<Joined>();
		joined_store_2.set_name("Joined Store");
		// set_store_component( joined_store_2 );
		
		member_store_0 = new MultiMapStore<Member>();
		member_store_0.set_name("Member Store");
		// set_store_component( member_store_0 );
		
		member_store_1 = new ListStore<Member>();
		member_store_1.set_name("Member Store");
		// set_store_component( member_store_1 );
		
		owner_store_0 = new MultiMapStore<Owner>();
		owner_store_0.set_name("Owner Store");
		// set_store_component( owner_store_0 );
		
		owner_store_1 = new MultiMapStore<Owner>();
		owner_store_1.set_name("Owner Store");
		// set_store_component( owner_store_1 );
		
		owner_store_2 = new ListStore<Owner>();
		owner_store_2.set_name("Owner Store");
		// set_store_component( owner_store_2 );
		
		joinrequest_store_0 = new MultiMapStore<JoinRequest>();
		joinrequest_store_0.set_name("JoinRequest Store");
		// set_store_component( joinrequest_store_0 );
		
		joinrequest_store_1 = new ListStore<JoinRequest>();
		joinrequest_store_1.set_name("JoinRequest Store");
		// set_store_component( joinrequest_store_1 );
		
		exit_store_0 = new MultiMapStore<Exit>();
		exit_store_0.set_name("Exit Store");
		// set_store_component( exit_store_0 );
		
		exit_store_1 = new MultiMapStore<Exit>();
		exit_store_1.set_name("Exit Store");
		// set_store_component( exit_store_1 );
		
		exit_store_2 = new ListStore<Exit>();
		exit_store_2.set_name("Exit Store");
		// set_store_component( exit_store_2 );
		
	
		set_store_component( startowner_store_0 );
		set_store_component( startmember_store_0 );
		set_store_component( quit_store_1 );
		set_store_component( connect_store_1 );
		set_store_component( joined_store_2 );
		set_store_component( member_store_1 );
		set_store_component( owner_store_2 );
		set_store_component( joinrequest_store_1 );
		set_store_component( exit_store_2 );
	}
	

	@Override
	protected boolean rewrite() {
		boolean done_something = false;
		while(goals.has_goals()) {
			goals.next().execute( this );
			done_something = true;
		}
		return done_something;
	}
	
	@Override
	protected boolean rewrite(int max_steps) {
		int count = 0;
		while(goals.has_goals() && count < max_steps) {
			goals.next().execute( this );
			count++;
		}
		return count > 0;
	}

	protected P2pdirectoryFact demultiplex(SerializedFact fact) {
		Serializable[] args = fact.arguments;
		switch(fact.fact_idx) {
			case 0: return new StartOwner(fact.loc,(String) args[0]);
			
			case 1: return new StartMember(fact.loc,(String) args[0]);
			
			case 2: return new Quit(fact.loc);
			
			case 3: return new Connect(fact.loc,(String) args[0]);
			
			case 4: return new Joined(fact.loc,(Integer) args[0]);
			
			case 5: return new Member(fact.loc,(String) args[0]);
			
			case 6: return new Owner(fact.loc,(String) args[0]);
			
			case 7: return new JoinRequest(fact.loc,(String) args[0],(String) args[1],(Integer) args[2]);
			
			case 8: return new Exit(fact.loc,(Integer) args[0]);
			
			case 9: return new Added(fact.loc,(Integer) args[0],(String) args[1],(String) args[2]);
			
			case 10: return new Removed(fact.loc,(Integer) args[0]);
			
			case 11: return new Connected(fact.loc);
			
			case 12: return new OwnerQuit(fact.loc);
			
			case 13: return new DeleteDir(fact.loc);
			
			case 14: return new Delay(fact.loc,(Integer) args[0]);
			
			case 15: return new Beep(fact.loc,(String) args[0]);
			
			case 16: return new Toast(fact.loc,(String) args[0]);
			
		}
		return null;
	}
	
	
	@Override
	protected synchronized boolean flushGoals() {
		if (external_goals.size() == 0) { return false; }
		for (SerializedFact new_goal : external_goals) {
			P2pdirectoryFact ef_goal = demultiplex( new_goal );
			ef_goal.intro( this ) ;
		}
		external_goals.clear();
		return true;
	}
	
	protected void store(StartOwner startowner) {
		startowner_store_0.add( startowner );
	} 				
	
	protected void store(StartMember startmember) {
		startmember_store_0.add( startmember );
	} 				
	
	protected void store(Quit quit) {
		quit_store_0.add( quit, index0Quit(quit.loc) );
		quit_store_1.add( quit );
	} 				
	
	protected void store(Connect connect) {
		connect_store_0.add( connect, index0Connect(connect.loc) );
		connect_store_1.add( connect );
	} 				
	
	protected void store(Joined joined) {
		joined_store_0.add( joined, index0Joined(joined.loc) );
		joined_store_1.add( joined, index1Joined(joined.loc,joined.arg1) );
		joined_store_2.add( joined );
	} 				
	
	protected void store(Member member) {
		member_store_0.add( member, index0Member(member.loc) );
		member_store_1.add( member );
	} 				
	
	protected void store(Owner owner) {
		owner_store_0.add( owner, index0Owner(owner.loc,owner.arg1) );
		owner_store_1.add( owner, index1Owner(owner.loc) );
		owner_store_2.add( owner );
	} 				
	
	protected void store(JoinRequest joinrequest) {
		joinrequest_store_0.add( joinrequest, index0JoinRequest(joinrequest.loc,joinrequest.arg1) );
		joinrequest_store_1.add( joinrequest );
	} 				
	
	protected void store(Exit exit) {
		exit_store_0.add( exit, index0Exit(exit.loc,exit.arg1) );
		exit_store_1.add( exit, index1Exit(exit.loc) );
		exit_store_2.add( exit );
	} 				
	
	protected void store(Added added) {
		
	} 				
	
	protected void store(Removed removed) {
		
	} 				
	
	protected void store(Connected connected) {
		
	} 				
	
	protected void store(OwnerQuit ownerquit) {
		
	} 				
	
	protected void store(DeleteDir deletedir) {
		
	} 				
	
	protected void store(Delay delay) {
		
	} 				
	
	protected void store(Beep beep) {
		
	} 				
	
	protected void store(Toast toast) {
		
	} 				
	
	public void add_startowner(int loc,String arg1) {
		if (isSolo || location == loc) {
			intro( new StartOwner(loc,arg1) );
		}
	}
	
	public void add_startmember(int loc,String arg1) {
		if (isSolo || location == loc) {
			intro( new StartMember(loc,arg1) );
		}
	}
	
	public void add_quit(int loc) {
		if (isSolo || location == loc) {
			intro( new Quit(loc) );
		}
	}
	
	public void add_connect(int loc,String arg1) {
		if (isSolo || location == loc) {
			intro( new Connect(loc,arg1) );
		}
	}
	
	public void add_joined(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new Joined(loc,arg1) );
		}
	}
	
	public void add_member(int loc,String arg1) {
		if (isSolo || location == loc) {
			intro( new Member(loc,arg1) );
		}
	}
	
	public void add_owner(int loc,String arg1) {
		if (isSolo || location == loc) {
			intro( new Owner(loc,arg1) );
		}
	}
	
	public void add_joinrequest(int loc,String arg1,String arg2,int arg3) {
		if (isSolo || location == loc) {
			intro( new JoinRequest(loc,arg1,arg2,arg3) );
		}
	}
	
	public void add_exit(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new Exit(loc,arg1) );
		}
	}
	
	public void add_added(int loc,int arg1,String arg2,String arg3) {
		if (isSolo || location == loc) {
			intro( new Added(loc,arg1,arg2,arg3) );
		}
	}
	
	public void add_removed(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new Removed(loc,arg1) );
		}
	}
	
	public void add_connected(int loc) {
		if (isSolo || location == loc) {
			intro( new Connected(loc) );
		}
	}
	
	public void add_ownerquit(int loc) {
		if (isSolo || location == loc) {
			intro( new OwnerQuit(loc) );
		}
	}
	
	public void add_deletedir(int loc) {
		if (isSolo || location == loc) {
			intro( new DeleteDir(loc) );
		}
	}
	
	public void add_delay(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new Delay(loc,arg1) );
		}
	}
	
	public void add_beep(int loc,String arg1) {
		if (isSolo || location == loc) {
			intro( new Beep(loc,arg1) );
		}
	}
	
	public void add_toast(int loc,String arg1) {
		if (isSolo || location == loc) {
			intro( new Toast(loc,arg1) );
		}
	}
	
	protected void intro(StartOwner startowner) {
		goals.add( startowner );
		notify_new_goals();
	}
	
	protected void intro(StartMember startmember) {
		goals.add( startmember );
		notify_new_goals();
	}
	
	protected void intro(Quit quit) {
		goals.add( quit );
		notify_new_goals();
	}
	
	protected void intro(Connect connect) {
		goals.add( connect );
		notify_new_goals();
	}
	
	protected void intro(Joined joined) {
		goals.add( joined );
		store( joined );
		notify_new_goals();
	}	
	
	protected void intro(Member member) {
		goals.add( member );
		notify_new_goals();
	}
	
	protected void intro(Owner owner) {
		goals.add( owner );
		notify_new_goals();
	}
	
	protected void intro(JoinRequest joinrequest) {
		goals.add( joinrequest );
		notify_new_goals();
	}
	
	protected void intro(Exit exit) {
		goals.add( exit );
		notify_new_goals();
	}
	
	protected void intro(Added added) {
		goals.add( added );
		notify_new_goals();
	}
	
	protected void intro(Removed removed) {
		goals.add( removed );
		notify_new_goals();
	}
	
	protected void intro(Connected connected) {
		goals.add( connected );
		notify_new_goals();
	}
	
	protected void intro(OwnerQuit ownerquit) {
		goals.add( ownerquit );
		notify_new_goals();
	}
	
	protected void intro(DeleteDir deletedir) {
		goals.add( deletedir );
		notify_new_goals();
	}
	
	protected void intro(Delay delay) {
		goals.add( delay );
		store( delay );
		notify_new_goals();
	}	
	
	protected void intro(Beep beep) {
		goals.add( beep );
		store( beep );
		notify_new_goals();
	}	
	
	protected void intro(Toast toast) {
		goals.add( toast );
		store( toast );
		notify_new_goals();
	}	
	
	protected void send(StartOwner startowner) {
		if(location == startowner.get_loc()) {
			intro(startowner);
		} else {
			send_buffers.add(startowner);
		}
	}
	
	protected void send(StartMember startmember) {
		if(location == startmember.get_loc()) {
			intro(startmember);
		} else {
			send_buffers.add(startmember);
		}
	}
	
	protected void send(Quit quit) {
		if(location == quit.get_loc()) {
			intro(quit);
		} else {
			send_buffers.add(quit);
		}
	}
	
	protected void send(Connect connect) {
		if(location == connect.get_loc()) {
			intro(connect);
		} else {
			send_buffers.add(connect);
		}
	}
	
	protected void send(Joined joined) {
		if(location == joined.get_loc()) {
			intro(joined);
		} else {
			send_buffers.add(joined);
		}
	}
	
	protected void send(Member member) {
		if(location == member.get_loc()) {
			intro(member);
		} else {
			send_buffers.add(member);
		}
	}
	
	protected void send(Owner owner) {
		if(location == owner.get_loc()) {
			intro(owner);
		} else {
			send_buffers.add(owner);
		}
	}
	
	protected void send(JoinRequest joinrequest) {
		if(location == joinrequest.get_loc()) {
			intro(joinrequest);
		} else {
			send_buffers.add(joinrequest);
		}
	}
	
	protected void send(Exit exit) {
		if(location == exit.get_loc()) {
			intro(exit);
		} else {
			send_buffers.add(exit);
		}
	}
	
	protected void send(Added added) {
		if(location == added.get_loc()) {
			intro(added);
		} else {
			send_buffers.add(added);
		}
	}
	
	protected void send(Removed removed) {
		if(location == removed.get_loc()) {
			intro(removed);
		} else {
			send_buffers.add(removed);
		}
	}
	
	protected void send(Connected connected) {
		if(location == connected.get_loc()) {
			intro(connected);
		} else {
			send_buffers.add(connected);
		}
	}
	
	protected void send(OwnerQuit ownerquit) {
		if(location == ownerquit.get_loc()) {
			intro(ownerquit);
		} else {
			send_buffers.add(ownerquit);
		}
	}
	
	protected void send(DeleteDir deletedir) {
		if(location == deletedir.get_loc()) {
			intro(deletedir);
		} else {
			send_buffers.add(deletedir);
		}
	}
	
	protected void send(Delay delay) {
		if(location == delay.get_loc()) {
			intro(delay);
		} else {
			send_buffers.add(delay);
		}
	}
	
	protected void send(Beep beep) {
		if(location == beep.get_loc()) {
			intro(beep);
		} else {
			send_buffers.add(beep);
		}
	}
	
	protected void send(Toast toast) {
		if(location == toast.get_loc()) {
			intro(toast);
		} else {
			send_buffers.add(toast);
		}
	}
	
	

	public void addStartOwner(String arg1) {
		intro( new StartOwner(location,arg1) );
	}
	
	public void addStartMember(String arg1) {
		intro( new StartMember(location,arg1) );
	}
	
	public void addQuit() {
		intro( new Quit(location) );
	}
	
	public void addConnect(String arg1) {
		intro( new Connect(location,arg1) );
	}
	

	public void setAddedActuator(ActuatorAction<Tuple3<Integer,String,String>> action) {
		setActuator("added", action);
	}
	
	public void setRemovedActuator(ActuatorAction<Integer> action) {
		setActuator("removed", action);
	}
	
	public void setConnectedActuator(ActuatorAction<Unit> action) {
		setActuator("connected", action);
	}
	
	public void setOwnerQuitActuator(ActuatorAction<Unit> action) {
		setActuator("ownerquit", action);
	}
	
	public void setDeleteDirActuator(ActuatorAction<Unit> action) {
		setActuator("deletedir", action);
	}
	
	public void setDelayActuator(ActuatorAction<Integer> action) {
		setActuator("delay", action);
	}
	
	public void setBeepActuator(ActuatorAction<String> action) {
		setActuator("beep", action);
	}
	
	public void setToastActuator(ActuatorAction<String> action) {
		setActuator("toast", action);
	}
	

	

	public ConcListStore[] getLinearStores() {
		ConcListStore[] stores = new ConcListStore[0];
		
		return stores;
	}
	

	/*
	**** 0 Join Ordering of Rule startOwner ****
	Rule Head Variables: (C::1), (O::0)
	Rule Head Compre Binders: 
	Active #H0 [(O::0)]startOwner((C::1))
	DeleteHead #H0
	IntroAtom Local NoPrior Mono [(O::0)]owner((C::1))
	IntroAtom Local NoPrior NonMono [(O::0)]joined((O::0))
	*/
	protected boolean execute_startowner_join_ordering_1(StartOwner act) {
		
		String c;
		int o;
		// Join Task: Active #H0 [(O::0)]startOwner((C::1))
		o = act.loc;
		c = act.arg1;
		// Join Task: DeleteHead #H0
		// H0 is active and monotone, no delete required
		// Join Task: IntroAtom Local NoPrior Mono [(O::0)]owner((C::1))
		intro( new Owner(o,c) );
		// Join Task: IntroAtom Local NoPrior NonMono [(O::0)]joined((O::0))
		intro( new Joined(o,o) );
		startOwner_rule_count++;
		return false;
		
	}
	
	/*
	**** 0 Join Ordering of Rule startMember ****
	Rule Head Variables: (C::1), (M::0)
	Rule Head Compre Binders: 
	Active #H0 [(M::0)]startMember((C::1))
	DeleteHead #H0
	IntroAtom Local NoPrior Mono [(M::0)]member((C::1))
	*/
	protected boolean execute_startmember_join_ordering_1(StartMember act) {
		
		String c;
		int m;
		// Join Task: Active #H0 [(M::0)]startMember((C::1))
		m = act.loc;
		c = act.arg1;
		// Join Task: DeleteHead #H0
		// H0 is active and monotone, no delete required
		// Join Task: IntroAtom Local NoPrior Mono [(M::0)]member((C::1))
		intro( new Member(m,c) );
		startMember_rule_count++;
		return false;
		
	}
	
	/*
	**** 1 Join Ordering of Rule quitO ****
	Rule Head Variables: (Ps::2), (C::1), (O::0)
	Rule Head Compre Binders: (P::3)
	Active #H0 [(O::0)]quit()
	LookupAtom #H1 6:1:hash<[+]owner(-)|.>  (O::0) [(O::0)]owner((C::1))
	LookupAll #H2 4:0:hash<[+]joined(-)|.>  (O::0) [(O::0)]joined((P::3))
	CompreDomain #H2 (P::3) (Ps::2) [(O::0)]joined((P::3))
	DeleteHead #H0
	DeleteHead #H1
	DeleteHead #H2
	IntroCompre Remote NoPrior Mono (P::4) (Ps::2) [(P::4)]ownerQuit()
	*/
	protected boolean execute_quit_join_ordering_1(Quit act) {
		
		int p;
		String c;
		int o;
		SimpMultiset<Integer>  ps;
		// Join Task: Active #H0 [(O::0)]quit()
		o = act.loc;
		// Join Task: LookupAtom #H1 6:1:hash<[+]owner(-)|.>  (O::0) [(O::0)]owner((C::1))
		StoreIter<Owner> candidates_1 = owner_store_1.lookup_candidates(index1Owner(o));
		Owner cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int o1;
			o1 = cand_1.loc;
			c = cand_1.arg1;
			if (true) {
				// Join Task: LookupAll #H2 4:0:hash<[+]joined(-)|.>  (O::0) [(O::0)]joined((P::3))
				StoreIter<Joined> candidates_2 = joined_store_0.lookup_candidates(index0Joined(o));
				// Join Task: CompreDomain #H2 (P::3) (Ps::2) [(O::0)]joined((P::3))
				ps = new SimpMultiset<Integer> ();
				Joined cand_2_0 = candidates_2.get_next_alive();
				while(cand_2_0 != null) {
					o = cand_2_0.loc;
					p = cand_2_0.arg1;
					ps.add( p );
					cand_2_0 = candidates_2.get_next_alive();
				}
				candidates_2.init_iter();
				// Join Task: DeleteHead #H0
				// H0 is active and monotone, no delete required
				// Join Task: DeleteHead #H1
				owner_store_0.remove( cand_1 );
				// Join Task: DeleteHead #H2
				Joined cand_2_1 = candidates_2.get_next_alive();
				while(cand_2_1 != null) {
					joined_store_0.remove( cand_2_1 );
					cand_2_1 = candidates_2.get_next_alive();
				}
				// Join Task: IntroCompre Remote NoPrior Mono (P::4) (Ps::2) [(P::4)]ownerQuit()
				SimpMultiset<Integer>  comp_0 = ps;
				for(int idx=0; idx<comp_0.size(); idx++) {
					p = comp_0.get(idx);
					send( new OwnerQuit(p) ); 
				}
				quitO_rule_count++;
				return false;
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule quitM ****
	Rule Head Variables: (C::1), (M::0)
	Rule Head Compre Binders: 
	Active #H0 [(M::0)]quit()
	LookupAtom #H1 5:0:hash<[+]member(-)|.>  (M::0) [(M::0)]member((C::1))
	DeleteHead #H0
	LetBind (O::2) ownerLoc(0)
	IntroAtom Remote NoPrior Mono [(O::2)]exit((M::0))
	*/
	protected boolean execute_quit_join_ordering_2(Quit act) {
		
		String c;
		int m;
		int o;
		// Join Task: Active #H0 [(M::0)]quit()
		m = act.loc;
		// Join Task: LookupAtom #H1 5:0:hash<[+]member(-)|.>  (M::0) [(M::0)]member((C::1))
		StoreIter<Member> candidates_1 = member_store_0.lookup_candidates(index0Member(m));
		Member cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int m1;
			m1 = cand_1.loc;
			c = cand_1.arg1;
			if (true) {
				// Join Task: DeleteHead #H0
				// H0 is active and monotone, no delete required
				// Join Task: LetBind (O::2) ownerLoc(0)
				o = WifiDirectComingleDirectory.ownerLoc(0);
				;
				// Join Task: IntroAtom Remote NoPrior Mono [(O::2)]exit((M::0))
				send( new Exit(o,m) ); 
				quitM_rule_count++;
				return false;
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule connect ****
	Rule Head Variables: (C::1), (M::0), (N::2)
	Rule Head Compre Binders: 
	Active #H0 [(M::0)]connect((N::2))
	LookupAtom #H1 5:0:hash<[+]member(-)|.>  (M::0) [(M::0)]member((C::1))
	DeleteHead #H0
	LetBind (O::3) ownerLoc(0)
	IntroAtom Remote NoPrior Mono [(O::3)]joinRequest((C::1),(N::2),(M::0))
	*/
	protected boolean execute_connect_join_ordering_1(Connect act) {
		
		String c;
		int m;
		int o;
		String n;
		// Join Task: Active #H0 [(M::0)]connect((N::2))
		m = act.loc;
		n = act.arg1;
		// Join Task: LookupAtom #H1 5:0:hash<[+]member(-)|.>  (M::0) [(M::0)]member((C::1))
		StoreIter<Member> candidates_1 = member_store_0.lookup_candidates(index0Member(m));
		Member cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int m1;
			m1 = cand_1.loc;
			c = cand_1.arg1;
			if (true) {
				// Join Task: DeleteHead #H0
				// H0 is active and monotone, no delete required
				// Join Task: LetBind (O::3) ownerLoc(0)
				o = WifiDirectComingleDirectory.ownerLoc(0);
				;
				// Join Task: IntroAtom Remote NoPrior Mono [(O::3)]joinRequest((C::1),(N::2),(M::0))
				send( new JoinRequest(o,c,n,m) ); 
				connect_rule_count++;
				return false;
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 2 Join Ordering of Rule join ****
	Rule Head Variables: (C::1), (NewN::4), (Ms::2), (O::0), (NewM::5)
	Rule Head Compre Binders: (M::3)
	Active #H0 [(O::0)]joined((M::3))
	LookupAtom #H1 6:1:hash<[+]owner(-)|.>  (O::0) [(O::0)]owner((C::1))
	LookupAtom #H2 7:0:hash<[+]joinRequest(+,-,-)|.>  (O::0),(C::1) [(O::0)]joinRequest((C::1),(NewN::4),(NewM::5))
	LookupAll #H3 4:0:hash<[+]joined(-)|.>  (O::0) [(O::0)]joined((M::3))
	CompreDomain #H3 (M::3) (Ms::2) [(O::0)]joined((M::3))
	CheckGuard not((NewM::5) in (Ms::2))
	DeleteHead #H2
	LetBind (NewIP::6) lookupIP((NewM::5))
	LetBind (Ds::7) retrieveDir(0)
	IntroAtom Remote NoPrior Mono [(NewM::5)]added((NewM::5),(NewIP::6),(NewN::4))
	IntroAtom Remote NoPrior NonMono [(O::0)]joined((NewM::5))
	IntroAtom Remote NoPrior Mono [(NewM::5)]connected()
	IntroCompre Remote NoPrior Mono (M::8) (Ms::2) [(M::8)]added((NewM::5),(NewIP::6),(NewN::4))
	IntroCompre Remote NoPrior Mono (M::10),(IP::9),(N::11) (Ds::7) [(NewM::5)]added((M::10),(IP::9),(N::11))
	*/
	protected boolean execute_joined_join_ordering_1(Joined act) {
		
		String newip;
		String c;
		String newn;
		int newm;
		String ip;
		int m;
		int o;
		String n;
		SimpMultiset<Integer>  ms;
		SimpMultiset<Tuple3<Integer,String,String> >  ds;
		// Join Task: Active #H0 [(O::0)]joined((M::3))
		if (act.is_alive()) {
			o = act.loc;
			m = act.arg1;
			// Join Task: LookupAtom #H1 6:1:hash<[+]owner(-)|.>  (O::0) [(O::0)]owner((C::1))
			StoreIter<Owner> candidates_1 = owner_store_1.lookup_candidates(index1Owner(o));
			Owner cand_1 = candidates_1.get_next_alive();
			while(cand_1 != null) {
				int o1;
				o1 = cand_1.loc;
				c = cand_1.arg1;
				if (true) {
					// Join Task: LookupAtom #H2 7:0:hash<[+]joinRequest(+,-,-)|.>  (O::0),(C::1) [(O::0)]joinRequest((C::1),(NewN::4),(NewM::5))
					StoreIter<JoinRequest> candidates_2 = joinrequest_store_0.lookup_candidates(index0JoinRequest(o,c));
					JoinRequest cand_2 = candidates_2.get_next_alive();
					while(cand_2 != null) {
						int o2;
						String c2;
						o2 = cand_2.loc;
						c2 = cand_2.arg1;
						newn = cand_2.arg2;
						newm = cand_2.arg3;
						if (Equality.is_eq(o,o2) && Equality.is_eq(c,c2)) {
							// Join Task: LookupAll #H3 4:0:hash<[+]joined(-)|.>  (O::0) [(O::0)]joined((M::3))
							StoreIter<Joined> candidates_3 = joined_store_0.lookup_candidates(index0Joined(o));
							// Join Task: CompreDomain #H3 (M::3) (Ms::2) [(O::0)]joined((M::3))
							ms = new SimpMultiset<Integer> ();
							Joined cand_3_0 = candidates_3.get_next_alive();
							while(cand_3_0 != null) {
								o = cand_3_0.loc;
								m = cand_3_0.arg1;
								ms.add( m );
								cand_3_0 = candidates_3.get_next_alive();
							}
							candidates_3.init_iter();
							// Join Task: CheckGuard not((NewM::5) in (Ms::2))
							if (ExtLib.not(ExtLib.in(newm,ms))) {
								// Join Task: DeleteHead #H2
								joinrequest_store_0.remove( cand_2 );
								// Join Task: LetBind (NewIP::6) lookupIP((NewM::5))
								newip = WifiDirectComingleDirectory.lookupIP(newm);
								;
								// Join Task: LetBind (Ds::7) retrieveDir(0)
								ds = WifiDirectComingleDirectory.retrieveDir(0);
								;
								// Join Task: IntroAtom Remote NoPrior Mono [(NewM::5)]added((NewM::5),(NewIP::6),(NewN::4))
								send( new Added(newm,newm,newip,newn) ); 
								// Join Task: IntroAtom Remote NoPrior NonMono [(O::0)]joined((NewM::5))
								intro( new Joined(o,newm) );
								// Join Task: IntroAtom Remote NoPrior Mono [(NewM::5)]connected()
								send( new Connected(newm) ); 
								// Join Task: IntroCompre Remote NoPrior Mono (M::8) (Ms::2) [(M::8)]added((NewM::5),(NewIP::6),(NewN::4))
								SimpMultiset<Integer>  comp_0 = ms;
								for(int idx=0; idx<comp_0.size(); idx++) {
									m = comp_0.get(idx);
									send( new Added(m,newm,newip,newn) ); 
								}
								// Join Task: IntroCompre Remote NoPrior Mono (M::10),(IP::9),(N::11) (Ds::7) [(NewM::5)]added((M::10),(IP::9),(N::11))
								SimpMultiset<Tuple3<Integer,String,String> >  comp_1 = ds;
								for(int idx=0; idx<comp_1.size(); idx++) {
									Tuple3<Integer,String,String>  tup0;
									tup0 = comp_1.get(idx);
									m = tup0.t1;
									ip = tup0.t2;
									n = tup0.t3;
									send( new Added(newm,m,ip,n) ); 
								}
								join_rule_count++;
							}
						} else {
						}
						cand_2 = candidates_2.get_next_alive();
					}
				}
				cand_1 = candidates_1.get_next_alive();
			}
		}
		return true;
	}
	
	/*
	**** 2 Join Ordering of Rule quitO ****
	Rule Head Variables: (Ps::2), (C::1), (O::0)
	Rule Head Compre Binders: (P::3)
	Active #H0 [(O::0)]joined((P::3))
	LookupAtom #H1 2:0:hash<[+]quit()|.>  (O::0) [(O::0)]quit()
	LookupAtom #H2 6:1:hash<[+]owner(-)|.>  (O::0) [(O::0)]owner((C::1))
	LookupAll #H3 4:0:hash<[+]joined(-)|.>  (O::0) [(O::0)]joined((P::3))
	CompreDomain #H3 (P::3) (Ps::2) [(O::0)]joined((P::3))
	DeleteHead #H1
	DeleteHead #H2
	DeleteHead #H3
	IntroCompre Remote NoPrior Mono (P::4) (Ps::2) [(P::4)]ownerQuit()
	*/
	protected boolean execute_joined_join_ordering_2(Joined act) {
		
		int p;
		String c;
		int o;
		SimpMultiset<Integer>  ps;
		// Join Task: Active #H0 [(O::0)]joined((P::3))
		if (act.is_alive()) {
			o = act.loc;
			p = act.arg1;
			// Join Task: LookupAtom #H1 2:0:hash<[+]quit()|.>  (O::0) [(O::0)]quit()
			StoreIter<Quit> candidates_1 = quit_store_0.lookup_candidates(index0Quit(o));
			Quit cand_1 = candidates_1.get_next_alive();
			while(cand_1 != null) {
				int o1;
				o1 = cand_1.loc;
				if (true) {
					// Join Task: LookupAtom #H2 6:1:hash<[+]owner(-)|.>  (O::0) [(O::0)]owner((C::1))
					StoreIter<Owner> candidates_2 = owner_store_1.lookup_candidates(index1Owner(o));
					Owner cand_2 = candidates_2.get_next_alive();
					while(cand_2 != null) {
						int o2;
						o2 = cand_2.loc;
						c = cand_2.arg1;
						if (true) {
							// Join Task: LookupAll #H3 4:0:hash<[+]joined(-)|.>  (O::0) [(O::0)]joined((P::3))
							StoreIter<Joined> candidates_3 = joined_store_0.lookup_candidates(index0Joined(o));
							// Join Task: CompreDomain #H3 (P::3) (Ps::2) [(O::0)]joined((P::3))
							ps = new SimpMultiset<Integer> ();
							Joined cand_3_0 = candidates_3.get_next_alive();
							while(cand_3_0 != null) {
								o = cand_3_0.loc;
								p = cand_3_0.arg1;
								ps.add( p );
								cand_3_0 = candidates_3.get_next_alive();
							}
							candidates_3.init_iter();
							// Join Task: DeleteHead #H1
							quit_store_0.remove( cand_1 );
							// Join Task: DeleteHead #H2
							owner_store_0.remove( cand_2 );
							// Join Task: DeleteHead #H3
							Joined cand_3_1 = candidates_3.get_next_alive();
							while(cand_3_1 != null) {
								joined_store_0.remove( cand_3_1 );
								cand_3_1 = candidates_3.get_next_alive();
							}
							// Join Task: IntroCompre Remote NoPrior Mono (P::4) (Ps::2) [(P::4)]ownerQuit()
							SimpMultiset<Integer>  comp_0 = ps;
							for(int idx=0; idx<comp_0.size(); idx++) {
								p = comp_0.get(idx);
								send( new OwnerQuit(p) ); 
							}
							quitO_rule_count++;
							return false;
						}
						cand_2 = candidates_2.get_next_alive();
					}
				}
				cand_1 = candidates_1.get_next_alive();
			}
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule exit ****
	Rule Head Variables: (Ms::0), (O::2), (N::3)
	Rule Head Compre Binders: (M::1)
	Active #H0 [(O::2)]joined((N::3))
	LookupAtom #H1 8:0:hash<[+]exit(+)|.>  (O::2),(N::3) [(O::2)]exit((N::3))
	LookupAll #H2 4:0:hash<[+]joined(-)|.>  (O::2) [(O::2)]joined((M::1))
	FilterHead #H2 #H0
	FilterGuard #H2 not((M::1) == (N::3))
	CompreDomain #H2 (M::1) (Ms::0) [(O::2)]joined((M::1))
	DeleteHead #H0
	DeleteHead #H1
	IntroAtom Remote NoPrior Mono [(N::3)]deleteDir()
	IntroCompre Remote NoPrior Mono (M::4) (Ms::0) [(M::4)]removed((N::3))
	*/
	protected boolean execute_joined_join_ordering_3(Joined act) {
		
		int m;
		SimpMultiset<Integer>  ms;
		int o;
		int n;
		// Join Task: Active #H0 [(O::2)]joined((N::3))
		if (act.is_alive()) {
			o = act.loc;
			n = act.arg1;
			// Join Task: LookupAtom #H1 8:0:hash<[+]exit(+)|.>  (O::2),(N::3) [(O::2)]exit((N::3))
			StoreIter<Exit> candidates_1 = exit_store_0.lookup_candidates(index0Exit(o,n));
			Exit cand_1 = candidates_1.get_next_alive();
			while(cand_1 != null) {
				int o1;
				int n1;
				o1 = cand_1.loc;
				n1 = cand_1.arg1;
				if (Equality.is_eq(o,o1) && Equality.is_eq(n,n1)) {
					// Join Task: LookupAll #H2 4:0:hash<[+]joined(-)|.>  (O::2) [(O::2)]joined((M::1))
					StoreIter<Joined> candidates_2 = joined_store_0.lookup_candidates(index0Joined(o));
					// Join Task: FilterHead #H2 #H0
					ListStoreIter<Joined> candidates_2_0 = new ListStoreIter<Joined>();
					Joined cand_2_0 = candidates_2.get_next_alive();
					while(cand_2_0 != null) {
						o = cand_2_0.loc;
						m = cand_2_0.arg1;
						if ((cand_2_0).identity() != (act).identity() ) {
							candidates_2_0.add( cand_2_0 );
						}
						cand_2_0 = candidates_2.get_next_alive();
					}
					candidates_2_0.init_iter();
					// Join Task: FilterGuard #H2 not((M::1) == (N::3))
					ListStoreIter<Joined> candidates_2_0_1 = new ListStoreIter<Joined>();
					Joined cand_2_1 = candidates_2_0.get_next_alive();
					while(cand_2_1 != null) {
						o = cand_2_1.loc;
						m = cand_2_1.arg1;
						if (ExtLib.not(Equality.is_eq(m,n))) {
							candidates_2_0_1.add( cand_2_1 );
						}
						cand_2_1 = candidates_2_0.get_next_alive();
					}
					candidates_2_0_1.init_iter();
					// Join Task: CompreDomain #H2 (M::1) (Ms::0) [(O::2)]joined((M::1))
					ms = new SimpMultiset<Integer> ();
					Joined cand_2_2 = candidates_2_0_1.get_next_alive();
					while(cand_2_2 != null) {
						o = cand_2_2.loc;
						m = cand_2_2.arg1;
						ms.add( m );
						cand_2_2 = candidates_2_0_1.get_next_alive();
					}
					candidates_2_0_1.init_iter();
					// Join Task: DeleteHead #H0
					joined_store_0.remove( act );
					// Join Task: DeleteHead #H1
					exit_store_0.remove( cand_1 );
					// Join Task: IntroAtom Remote NoPrior Mono [(N::3)]deleteDir()
					send( new DeleteDir(n) ); 
					// Join Task: IntroCompre Remote NoPrior Mono (M::4) (Ms::0) [(M::4)]removed((N::3))
					SimpMultiset<Integer>  comp_0 = ms;
					for(int idx=0; idx<comp_0.size(); idx++) {
						m = comp_0.get(idx);
						send( new Removed(m,n) ); 
					}
					exit_rule_count++;
					return false;
				} else {
				}
				cand_1 = candidates_1.get_next_alive();
			}
		}
		return true;
	}
	
	/*
	**** 2 Join Ordering of Rule exit ****
	Rule Head Variables: (Ms::0), (O::2), (N::3)
	Rule Head Compre Binders: (M::1)
	Active #H0 [(O::2)]joined((M::1))
	LookupAtom #H1 8:1:hash<[+]exit(-)|.>  (O::2) [(O::2)]exit((N::3))
	CheckGuard not((M::1) == (N::3))
	LookupAtom #H2 4:1:hash<[+]joined(+)|.>  (O::2),(N::3) [(O::2)]joined((N::3))
	LookupAll #H3 4:0:hash<[+]joined(-)|.>  (O::2) [(O::2)]joined((M::1))
	FilterHead #H3 #H2
	FilterGuard #H3 not((M::1) == (N::3))
	CompreDomain #H3 (M::1) (Ms::0) [(O::2)]joined((M::1))
	DeleteHead #H1
	DeleteHead #H2
	IntroAtom Remote NoPrior Mono [(N::3)]deleteDir()
	IntroCompre Remote NoPrior Mono (M::4) (Ms::0) [(M::4)]removed((N::3))
	*/
	protected boolean execute_joined_join_ordering_4(Joined act) {
		
		int m;
		SimpMultiset<Integer>  ms;
		int o;
		int n;
		// Join Task: Active #H0 [(O::2)]joined((M::1))
		if (act.is_alive()) {
			o = act.loc;
			m = act.arg1;
			// Join Task: LookupAtom #H1 8:1:hash<[+]exit(-)|.>  (O::2) [(O::2)]exit((N::3))
			StoreIter<Exit> candidates_1 = exit_store_1.lookup_candidates(index1Exit(o));
			Exit cand_1 = candidates_1.get_next_alive();
			while(cand_1 != null) {
				int o1;
				o1 = cand_1.loc;
				n = cand_1.arg1;
				if (true) {
					// Join Task: CheckGuard not((M::1) == (N::3))
					if (ExtLib.not(Equality.is_eq(m,n))) {
						// Join Task: LookupAtom #H2 4:1:hash<[+]joined(+)|.>  (O::2),(N::3) [(O::2)]joined((N::3))
						StoreIter<Joined> candidates_2 = joined_store_1.lookup_candidates(index1Joined(o,n));
						Joined cand_2 = candidates_2.get_next_alive();
						while(cand_2 != null) {
							int o2;
							int n2;
							o2 = cand_2.loc;
							n2 = cand_2.arg1;
							if (Equality.is_eq(o,o2) && Equality.is_eq(n,n2)) {
								// Join Task: LookupAll #H3 4:0:hash<[+]joined(-)|.>  (O::2) [(O::2)]joined((M::1))
								StoreIter<Joined> candidates_3 = joined_store_0.lookup_candidates(index0Joined(o));
								// Join Task: FilterHead #H3 #H2
								ListStoreIter<Joined> candidates_3_0 = new ListStoreIter<Joined>();
								Joined cand_3_0 = candidates_3.get_next_alive();
								while(cand_3_0 != null) {
									o = cand_3_0.loc;
									m = cand_3_0.arg1;
									if ((cand_3_0).identity() != (cand_2).identity() ) {
										candidates_3_0.add( cand_3_0 );
									}
									cand_3_0 = candidates_3.get_next_alive();
								}
								candidates_3_0.init_iter();
								// Join Task: FilterGuard #H3 not((M::1) == (N::3))
								ListStoreIter<Joined> candidates_3_0_1 = new ListStoreIter<Joined>();
								Joined cand_3_1 = candidates_3_0.get_next_alive();
								while(cand_3_1 != null) {
									o = cand_3_1.loc;
									m = cand_3_1.arg1;
									if (ExtLib.not(Equality.is_eq(m,n))) {
										candidates_3_0_1.add( cand_3_1 );
									}
									cand_3_1 = candidates_3_0.get_next_alive();
								}
								candidates_3_0_1.init_iter();
								// Join Task: CompreDomain #H3 (M::1) (Ms::0) [(O::2)]joined((M::1))
								ms = new SimpMultiset<Integer> ();
								Joined cand_3_2 = candidates_3_0_1.get_next_alive();
								while(cand_3_2 != null) {
									o = cand_3_2.loc;
									m = cand_3_2.arg1;
									ms.add( m );
									cand_3_2 = candidates_3_0_1.get_next_alive();
								}
								candidates_3_0_1.init_iter();
								// Join Task: DeleteHead #H1
								exit_store_0.remove( cand_1 );
								// Join Task: DeleteHead #H2
								joined_store_0.remove( cand_2 );
								// Join Task: IntroAtom Remote NoPrior Mono [(N::3)]deleteDir()
								send( new DeleteDir(n) ); 
								// Join Task: IntroCompre Remote NoPrior Mono (M::4) (Ms::0) [(M::4)]removed((N::3))
								SimpMultiset<Integer>  comp_0 = ms;
								for(int idx=0; idx<comp_0.size(); idx++) {
									m = comp_0.get(idx);
									send( new Removed(m,n) ); 
								}
								exit_rule_count++;
							} else {
							}
							cand_2 = candidates_2.get_next_alive();
						}
					}
				}
				cand_1 = candidates_1.get_next_alive();
			}
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule connect ****
	Rule Head Variables: (C::1), (M::0), (N::2)
	Rule Head Compre Binders: 
	Active #H0 [(M::0)]member((C::1))
	LookupAtom #H1 3:0:hash<[+]connect(-)|.>  (M::0) [(M::0)]connect((N::2))
	DeleteHead #H1
	LetBind (O::3) ownerLoc(0)
	IntroAtom Remote NoPrior Mono [(O::3)]joinRequest((C::1),(N::2),(M::0))
	*/
	protected boolean execute_member_join_ordering_1(Member act) {
		
		String c;
		int m;
		int o;
		String n;
		// Join Task: Active #H0 [(M::0)]member((C::1))
		m = act.loc;
		c = act.arg1;
		// Join Task: LookupAtom #H1 3:0:hash<[+]connect(-)|.>  (M::0) [(M::0)]connect((N::2))
		StoreIter<Connect> candidates_1 = connect_store_0.lookup_candidates(index0Connect(m));
		Connect cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int m1;
			m1 = cand_1.loc;
			n = cand_1.arg1;
			if (true) {
				// Join Task: DeleteHead #H1
				connect_store_0.remove( cand_1 );
				// Join Task: LetBind (O::3) ownerLoc(0)
				o = WifiDirectComingleDirectory.ownerLoc(0);
				;
				// Join Task: IntroAtom Remote NoPrior Mono [(O::3)]joinRequest((C::1),(N::2),(M::0))
				send( new JoinRequest(o,c,n,m) ); 
				connect_rule_count++;
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule quitM ****
	Rule Head Variables: (C::1), (M::0)
	Rule Head Compre Binders: 
	Active #H0 [(M::0)]member((C::1))
	LookupAtom #H1 2:0:hash<[+]quit()|.>  (M::0) [(M::0)]quit()
	DeleteHead #H1
	LetBind (O::2) ownerLoc(0)
	IntroAtom Remote NoPrior Mono [(O::2)]exit((M::0))
	*/
	protected boolean execute_member_join_ordering_2(Member act) {
		
		String c;
		int m;
		int o;
		// Join Task: Active #H0 [(M::0)]member((C::1))
		m = act.loc;
		c = act.arg1;
		// Join Task: LookupAtom #H1 2:0:hash<[+]quit()|.>  (M::0) [(M::0)]quit()
		StoreIter<Quit> candidates_1 = quit_store_0.lookup_candidates(index0Quit(m));
		Quit cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int m1;
			m1 = cand_1.loc;
			if (true) {
				// Join Task: DeleteHead #H1
				quit_store_0.remove( cand_1 );
				// Join Task: LetBind (O::2) ownerLoc(0)
				o = WifiDirectComingleDirectory.ownerLoc(0);
				;
				// Join Task: IntroAtom Remote NoPrior Mono [(O::2)]exit((M::0))
				send( new Exit(o,m) ); 
				quitM_rule_count++;
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule join ****
	Rule Head Variables: (C::1), (NewN::4), (Ms::2), (O::0), (NewM::5)
	Rule Head Compre Binders: (M::3)
	Active #H0 [(O::0)]owner((C::1))
	LookupAtom #H1 7:0:hash<[+]joinRequest(+,-,-)|.>  (O::0),(C::1) [(O::0)]joinRequest((C::1),(NewN::4),(NewM::5))
	LookupAll #H2 4:0:hash<[+]joined(-)|.>  (O::0) [(O::0)]joined((M::3))
	CompreDomain #H2 (M::3) (Ms::2) [(O::0)]joined((M::3))
	CheckGuard not((NewM::5) in (Ms::2))
	DeleteHead #H1
	LetBind (NewIP::6) lookupIP((NewM::5))
	LetBind (Ds::7) retrieveDir(0)
	IntroAtom Remote NoPrior Mono [(NewM::5)]added((NewM::5),(NewIP::6),(NewN::4))
	IntroAtom Remote NoPrior NonMono [(O::0)]joined((NewM::5))
	IntroAtom Remote NoPrior Mono [(NewM::5)]connected()
	IntroCompre Remote NoPrior Mono (M::8) (Ms::2) [(M::8)]added((NewM::5),(NewIP::6),(NewN::4))
	IntroCompre Remote NoPrior Mono (M::10),(IP::9),(N::11) (Ds::7) [(NewM::5)]added((M::10),(IP::9),(N::11))
	*/
	protected boolean execute_owner_join_ordering_1(Owner act) {
		
		String newip;
		String c;
		String newn;
		int newm;
		String ip;
		int m;
		int o;
		String n;
		SimpMultiset<Integer>  ms;
		SimpMultiset<Tuple3<Integer,String,String> >  ds;
		// Join Task: Active #H0 [(O::0)]owner((C::1))
		o = act.loc;
		c = act.arg1;
		// Join Task: LookupAtom #H1 7:0:hash<[+]joinRequest(+,-,-)|.>  (O::0),(C::1) [(O::0)]joinRequest((C::1),(NewN::4),(NewM::5))
		StoreIter<JoinRequest> candidates_1 = joinrequest_store_0.lookup_candidates(index0JoinRequest(o,c));
		JoinRequest cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int o1;
			String c1;
			o1 = cand_1.loc;
			c1 = cand_1.arg1;
			newn = cand_1.arg2;
			newm = cand_1.arg3;
			if (Equality.is_eq(o,o1) && Equality.is_eq(c,c1)) {
				// Join Task: LookupAll #H2 4:0:hash<[+]joined(-)|.>  (O::0) [(O::0)]joined((M::3))
				StoreIter<Joined> candidates_2 = joined_store_0.lookup_candidates(index0Joined(o));
				// Join Task: CompreDomain #H2 (M::3) (Ms::2) [(O::0)]joined((M::3))
				ms = new SimpMultiset<Integer> ();
				Joined cand_2_0 = candidates_2.get_next_alive();
				while(cand_2_0 != null) {
					o = cand_2_0.loc;
					m = cand_2_0.arg1;
					ms.add( m );
					cand_2_0 = candidates_2.get_next_alive();
				}
				candidates_2.init_iter();
				// Join Task: CheckGuard not((NewM::5) in (Ms::2))
				if (ExtLib.not(ExtLib.in(newm,ms))) {
					// Join Task: DeleteHead #H1
					joinrequest_store_0.remove( cand_1 );
					// Join Task: LetBind (NewIP::6) lookupIP((NewM::5))
					newip = WifiDirectComingleDirectory.lookupIP(newm);
					;
					// Join Task: LetBind (Ds::7) retrieveDir(0)
					ds = WifiDirectComingleDirectory.retrieveDir(0);
					;
					// Join Task: IntroAtom Remote NoPrior Mono [(NewM::5)]added((NewM::5),(NewIP::6),(NewN::4))
					send( new Added(newm,newm,newip,newn) ); 
					// Join Task: IntroAtom Remote NoPrior NonMono [(O::0)]joined((NewM::5))
					intro( new Joined(o,newm) );
					// Join Task: IntroAtom Remote NoPrior Mono [(NewM::5)]connected()
					send( new Connected(newm) ); 
					// Join Task: IntroCompre Remote NoPrior Mono (M::8) (Ms::2) [(M::8)]added((NewM::5),(NewIP::6),(NewN::4))
					SimpMultiset<Integer>  comp_0 = ms;
					for(int idx=0; idx<comp_0.size(); idx++) {
						m = comp_0.get(idx);
						send( new Added(m,newm,newip,newn) ); 
					}
					// Join Task: IntroCompre Remote NoPrior Mono (M::10),(IP::9),(N::11) (Ds::7) [(NewM::5)]added((M::10),(IP::9),(N::11))
					SimpMultiset<Tuple3<Integer,String,String> >  comp_1 = ds;
					for(int idx=0; idx<comp_1.size(); idx++) {
						Tuple3<Integer,String,String>  tup1;
						tup1 = comp_1.get(idx);
						m = tup1.t1;
						ip = tup1.t2;
						n = tup1.t3;
						send( new Added(newm,m,ip,n) ); 
					}
					join_rule_count++;
				}
			} else {
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule quitO ****
	Rule Head Variables: (Ps::2), (C::1), (O::0)
	Rule Head Compre Binders: (P::3)
	Active #H0 [(O::0)]owner((C::1))
	LookupAtom #H1 2:0:hash<[+]quit()|.>  (O::0) [(O::0)]quit()
	LookupAll #H2 4:0:hash<[+]joined(-)|.>  (O::0) [(O::0)]joined((P::3))
	CompreDomain #H2 (P::3) (Ps::2) [(O::0)]joined((P::3))
	DeleteHead #H0
	DeleteHead #H1
	DeleteHead #H2
	IntroCompre Remote NoPrior Mono (P::4) (Ps::2) [(P::4)]ownerQuit()
	*/
	protected boolean execute_owner_join_ordering_2(Owner act) {
		
		int p;
		String c;
		int o;
		SimpMultiset<Integer>  ps;
		// Join Task: Active #H0 [(O::0)]owner((C::1))
		o = act.loc;
		c = act.arg1;
		// Join Task: LookupAtom #H1 2:0:hash<[+]quit()|.>  (O::0) [(O::0)]quit()
		StoreIter<Quit> candidates_1 = quit_store_0.lookup_candidates(index0Quit(o));
		Quit cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int o1;
			o1 = cand_1.loc;
			if (true) {
				// Join Task: LookupAll #H2 4:0:hash<[+]joined(-)|.>  (O::0) [(O::0)]joined((P::3))
				StoreIter<Joined> candidates_2 = joined_store_0.lookup_candidates(index0Joined(o));
				// Join Task: CompreDomain #H2 (P::3) (Ps::2) [(O::0)]joined((P::3))
				ps = new SimpMultiset<Integer> ();
				Joined cand_2_0 = candidates_2.get_next_alive();
				while(cand_2_0 != null) {
					o = cand_2_0.loc;
					p = cand_2_0.arg1;
					ps.add( p );
					cand_2_0 = candidates_2.get_next_alive();
				}
				candidates_2.init_iter();
				// Join Task: DeleteHead #H0
				// H0 is active and monotone, no delete required
				// Join Task: DeleteHead #H1
				quit_store_0.remove( cand_1 );
				// Join Task: DeleteHead #H2
				Joined cand_2_1 = candidates_2.get_next_alive();
				while(cand_2_1 != null) {
					joined_store_0.remove( cand_2_1 );
					cand_2_1 = candidates_2.get_next_alive();
				}
				// Join Task: IntroCompre Remote NoPrior Mono (P::4) (Ps::2) [(P::4)]ownerQuit()
				SimpMultiset<Integer>  comp_0 = ps;
				for(int idx=0; idx<comp_0.size(); idx++) {
					p = comp_0.get(idx);
					send( new OwnerQuit(p) ); 
				}
				quitO_rule_count++;
				return false;
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule join ****
	Rule Head Variables: (C::1), (NewN::4), (Ms::2), (O::0), (NewM::5)
	Rule Head Compre Binders: (M::3)
	Active #H0 [(O::0)]joinRequest((C::1),(NewN::4),(NewM::5))
	LookupAtom #H1 6:0:hash<[+]owner(+)|.>  (O::0),(C::1) [(O::0)]owner((C::1))
	LookupAll #H2 4:0:hash<[+]joined(-)|.>  (O::0) [(O::0)]joined((M::3))
	CompreDomain #H2 (M::3) (Ms::2) [(O::0)]joined((M::3))
	CheckGuard not((NewM::5) in (Ms::2))
	DeleteHead #H0
	LetBind (NewIP::6) lookupIP((NewM::5))
	LetBind (Ds::7) retrieveDir(0)
	IntroAtom Remote NoPrior Mono [(NewM::5)]added((NewM::5),(NewIP::6),(NewN::4))
	IntroAtom Remote NoPrior NonMono [(O::0)]joined((NewM::5))
	IntroAtom Remote NoPrior Mono [(NewM::5)]connected()
	IntroCompre Remote NoPrior Mono (M::8) (Ms::2) [(M::8)]added((NewM::5),(NewIP::6),(NewN::4))
	IntroCompre Remote NoPrior Mono (M::10),(IP::9),(N::11) (Ds::7) [(NewM::5)]added((M::10),(IP::9),(N::11))
	*/
	protected boolean execute_joinrequest_join_ordering_1(JoinRequest act) {
		
		String newip;
		String c;
		String newn;
		int newm;
		String ip;
		int m;
		int o;
		String n;
		SimpMultiset<Integer>  ms;
		SimpMultiset<Tuple3<Integer,String,String> >  ds;
		// Join Task: Active #H0 [(O::0)]joinRequest((C::1),(NewN::4),(NewM::5))
		o = act.loc;
		c = act.arg1;
		newn = act.arg2;
		newm = act.arg3;
		// Join Task: LookupAtom #H1 6:0:hash<[+]owner(+)|.>  (O::0),(C::1) [(O::0)]owner((C::1))
		StoreIter<Owner> candidates_1 = owner_store_0.lookup_candidates(index0Owner(o,c));
		Owner cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int o1;
			String c1;
			o1 = cand_1.loc;
			c1 = cand_1.arg1;
			if (Equality.is_eq(o,o1) && Equality.is_eq(c,c1)) {
				// Join Task: LookupAll #H2 4:0:hash<[+]joined(-)|.>  (O::0) [(O::0)]joined((M::3))
				StoreIter<Joined> candidates_2 = joined_store_0.lookup_candidates(index0Joined(o));
				// Join Task: CompreDomain #H2 (M::3) (Ms::2) [(O::0)]joined((M::3))
				ms = new SimpMultiset<Integer> ();
				Joined cand_2_0 = candidates_2.get_next_alive();
				while(cand_2_0 != null) {
					o = cand_2_0.loc;
					m = cand_2_0.arg1;
					ms.add( m );
					cand_2_0 = candidates_2.get_next_alive();
				}
				candidates_2.init_iter();
				// Join Task: CheckGuard not((NewM::5) in (Ms::2))
				if (ExtLib.not(ExtLib.in(newm,ms))) {
					// Join Task: DeleteHead #H0
					// H0 is active and monotone, no delete required
					// Join Task: LetBind (NewIP::6) lookupIP((NewM::5))
					newip = WifiDirectComingleDirectory.lookupIP(newm);
					;
					// Join Task: LetBind (Ds::7) retrieveDir(0)
					ds = WifiDirectComingleDirectory.retrieveDir(0);
					;
					// Join Task: IntroAtom Remote NoPrior Mono [(NewM::5)]added((NewM::5),(NewIP::6),(NewN::4))
					send( new Added(newm,newm,newip,newn) ); 
					// Join Task: IntroAtom Remote NoPrior NonMono [(O::0)]joined((NewM::5))
					intro( new Joined(o,newm) );
					// Join Task: IntroAtom Remote NoPrior Mono [(NewM::5)]connected()
					send( new Connected(newm) ); 
					// Join Task: IntroCompre Remote NoPrior Mono (M::8) (Ms::2) [(M::8)]added((NewM::5),(NewIP::6),(NewN::4))
					SimpMultiset<Integer>  comp_0 = ms;
					for(int idx=0; idx<comp_0.size(); idx++) {
						m = comp_0.get(idx);
						send( new Added(m,newm,newip,newn) ); 
					}
					// Join Task: IntroCompre Remote NoPrior Mono (M::10),(IP::9),(N::11) (Ds::7) [(NewM::5)]added((M::10),(IP::9),(N::11))
					SimpMultiset<Tuple3<Integer,String,String> >  comp_1 = ds;
					for(int idx=0; idx<comp_1.size(); idx++) {
						Tuple3<Integer,String,String>  tup2;
						tup2 = comp_1.get(idx);
						m = tup2.t1;
						ip = tup2.t2;
						n = tup2.t3;
						send( new Added(newm,m,ip,n) ); 
					}
					join_rule_count++;
					return false;
				}
			} else {
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule exit ****
	Rule Head Variables: (Ms::0), (O::2), (N::3)
	Rule Head Compre Binders: (M::1)
	Active #H0 [(O::2)]exit((N::3))
	LookupAtom #H1 4:1:hash<[+]joined(+)|.>  (O::2),(N::3) [(O::2)]joined((N::3))
	LookupAll #H2 4:0:hash<[+]joined(-)|.>  (O::2) [(O::2)]joined((M::1))
	FilterHead #H2 #H1
	FilterGuard #H2 not((M::1) == (N::3))
	CompreDomain #H2 (M::1) (Ms::0) [(O::2)]joined((M::1))
	DeleteHead #H0
	DeleteHead #H1
	IntroAtom Remote NoPrior Mono [(N::3)]deleteDir()
	IntroCompre Remote NoPrior Mono (M::4) (Ms::0) [(M::4)]removed((N::3))
	*/
	protected boolean execute_exit_join_ordering_1(Exit act) {
		
		int m;
		SimpMultiset<Integer>  ms;
		int o;
		int n;
		// Join Task: Active #H0 [(O::2)]exit((N::3))
		o = act.loc;
		n = act.arg1;
		// Join Task: LookupAtom #H1 4:1:hash<[+]joined(+)|.>  (O::2),(N::3) [(O::2)]joined((N::3))
		StoreIter<Joined> candidates_1 = joined_store_1.lookup_candidates(index1Joined(o,n));
		Joined cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int o1;
			int n1;
			o1 = cand_1.loc;
			n1 = cand_1.arg1;
			if (Equality.is_eq(o,o1) && Equality.is_eq(n,n1)) {
				// Join Task: LookupAll #H2 4:0:hash<[+]joined(-)|.>  (O::2) [(O::2)]joined((M::1))
				StoreIter<Joined> candidates_2 = joined_store_0.lookup_candidates(index0Joined(o));
				// Join Task: FilterHead #H2 #H1
				ListStoreIter<Joined> candidates_2_0 = new ListStoreIter<Joined>();
				Joined cand_2_0 = candidates_2.get_next_alive();
				while(cand_2_0 != null) {
					o = cand_2_0.loc;
					m = cand_2_0.arg1;
					if ((cand_2_0).identity() != (cand_1).identity() ) {
						candidates_2_0.add( cand_2_0 );
					}
					cand_2_0 = candidates_2.get_next_alive();
				}
				candidates_2_0.init_iter();
				// Join Task: FilterGuard #H2 not((M::1) == (N::3))
				ListStoreIter<Joined> candidates_2_0_1 = new ListStoreIter<Joined>();
				Joined cand_2_1 = candidates_2_0.get_next_alive();
				while(cand_2_1 != null) {
					o = cand_2_1.loc;
					m = cand_2_1.arg1;
					if (ExtLib.not(Equality.is_eq(m,n))) {
						candidates_2_0_1.add( cand_2_1 );
					}
					cand_2_1 = candidates_2_0.get_next_alive();
				}
				candidates_2_0_1.init_iter();
				// Join Task: CompreDomain #H2 (M::1) (Ms::0) [(O::2)]joined((M::1))
				ms = new SimpMultiset<Integer> ();
				Joined cand_2_2 = candidates_2_0_1.get_next_alive();
				while(cand_2_2 != null) {
					o = cand_2_2.loc;
					m = cand_2_2.arg1;
					ms.add( m );
					cand_2_2 = candidates_2_0_1.get_next_alive();
				}
				candidates_2_0_1.init_iter();
				// Join Task: DeleteHead #H0
				// H0 is active and monotone, no delete required
				// Join Task: DeleteHead #H1
				joined_store_0.remove( cand_1 );
				// Join Task: IntroAtom Remote NoPrior Mono [(N::3)]deleteDir()
				send( new DeleteDir(n) ); 
				// Join Task: IntroCompre Remote NoPrior Mono (M::4) (Ms::0) [(M::4)]removed((N::3))
				SimpMultiset<Integer>  comp_0 = ms;
				for(int idx=0; idx<comp_0.size(); idx++) {
					m = comp_0.get(idx);
					send( new Removed(m,n) ); 
				}
				exit_rule_count++;
				return false;
			} else {
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	

	protected void execute(StartOwner startowner) {
		if( execute_startowner_join_ordering_1(startowner) ) {
			store( startowner );
		}
	}
	
	protected void execute(StartMember startmember) {
		if( execute_startmember_join_ordering_1(startmember) ) {
			store( startmember );
		}
	}
	
	protected void execute(Quit quit) {
		if( execute_quit_join_ordering_1(quit) ) {
			if( execute_quit_join_ordering_2(quit) ) {
				store( quit );
			}
		}
	}
	
	protected void execute(Connect connect) {
		if( execute_connect_join_ordering_1(connect) ) {
			store( connect );
		}
	}
	
	protected void execute(Joined joined) {
		execute_joined_join_ordering_1( joined );
		if( execute_joined_join_ordering_2(joined) ) {
			if( execute_joined_join_ordering_3(joined) ) {
				execute_joined_join_ordering_4( joined );
			}
		}
	}
	
	protected void execute(Member member) {
		execute_member_join_ordering_1( member );
		execute_member_join_ordering_2( member );
		store( member );
	}
	
	protected void execute(Owner owner) {
		execute_owner_join_ordering_1( owner );
		if( execute_owner_join_ordering_2(owner) ) {
			store( owner );
		}
	}
	
	protected void execute(JoinRequest joinrequest) {
		if( execute_joinrequest_join_ordering_1(joinrequest) ) {
			store( joinrequest );
		}
	}
	
	protected void execute(Exit exit) {
		if( execute_exit_join_ordering_1(exit) ) {
			store( exit );
		}
	}
	

	@Override
	public void init() {
	}

}


