package p2pdirectory;

import java.io.Serializable;
import java.util.LinkedList;
import java.util.ListIterator;

import comingle.goals.*;
import comingle.store.*;
import comingle.facts.*;
import comingle.rewrite.*;
import comingle.hash.*;
import comingle.tuple.*;
import comingle.misc.*;
import comingle.mset.*;
import comingle.actuation.*;

import comingle.lib.ExtLib;

import p2pdirectory.WifiDirectComingleDirectory;




/**
**  
** Generated by Comingle: Distributed Logic Programming for Decentralized Mobile Ensembles
** Visit https://github.com/sllam/comingle for more information.
** Or contact us:      
**      Edmund Lam          sllam@qatar.cmu.edu
**      Iliano Cervesato    iliano@cmu.edu
**
**/

/**
** This Comingle Runtime is generated from the following Comingle specifications:
ensem p2pdirectory {

	module comingle.lib.ExtLib import {
		diff :: ({A},{A}) -> {A}.
		not  :: bool -> bool.
	}

	module p2pdirectory.WifiDirectComingleDirectory import {
		next :: loc -> loc.
		lookupIP :: string -> string.
	}

	predicate startOwner  :: (string,loc) -> trigger.
	predicate startMember :: (string,loc) -> trigger.
	predicate quit        :: trigger.
	predicate connect     :: (string,string) -> trigger.

	predicate node        :: loc -> fact.
	predicate seen        :: string -> fact.
	predicate member      :: fact.
	predicate owner       :: fact.
	predicate ownerAt     :: loc -> fact.
	predicate joinRequest :: (string,string,string) -> fact.
	predicate reqCode     :: string -> fact.
	predicate nextLoc     :: loc -> fact.
	predicate remove      :: loc -> fact.

	predicate notifyNodeAdded   :: (loc,string,string,string) -> actuator.
	predicate notifyNodeRemoved :: loc -> actuator.
	predicate notifyLocAssign   :: loc -> actuator.
	predicate notifyOwnerQuit   :: actuator.

	rule startOwner  :: [O]startOwner(Code,LocO) 
                                   --o [O]owner(), [O]node(LocO), [O]reqCode(Code), [O]nextLoc(LocN)
                                       where LocN = next(LocO).
	rule startMember :: [M]startMember(Code,LocO) 
                                   --o [M]member(), [M]reqCode(Code), [M]ownerAt(LocO).

	rule connect :: [M]member(), [M]ownerAt(O), [M]reqCode(C) \ [M]connect(NameM,MacM) 
                              --o [O]joinRequest(C,NameM,MacM).

	rule join :: [O]owner(), [O]reqCode(C), { [O]node(L) | L -> Ls }, { [O]seen(M) | M -> Ms }
                     \ [O]joinRequest(C,Name,Mac), [O]nextLoc(LocN)
                           | not(Mac in Ms) --o { [L]notifyNodeAdded(LocN,Inet,Name,Mac) | L <- Ls }, 
                                                [LocN]notifyNodeAdded(LocN,Inet,Name,Mac), [LocN]notifyLocAssign(LocN), 
                                                [O]nextLoc(LocU), [O]node(LocN), [O]seen(Mac)
                                                where LocU = next(LocN),
                                                      Inet = lookupIP(Mac).

	rule quitO  :: [O]owner(), { [O]node(M) | M -> Ms } \ [M]quit() 
                                 --o { [M]notifyOwnerQuit() | M <- Ms } .

	rule quitM  :: [M]member(), [M]ownerAt(O) \ [M]quit() --o [O]remove(M).
	rule remove :: [O]remove(M), { [O]node(N) | N -> Ns } 
                            --o { [O]node(N) | N <- Ms },
                                { [M]notifyNodeRemoved(N) | N <- Ms }
                                where Ms = diff(Ns,{M}).

}
**/


public class P2pdirectory extends RewriteMachine {

	public class Actuations {
		public static final String notifynodeadded = "notifynodeadded";
		public static final String notifynoderemoved = "notifynoderemoved";
		public static final String notifylocassign = "notifylocassign";
		public static final String notifyownerquit = "notifyownerquit";
		public static final String delay = "delay";
		public static final String beep = "beep";
		public static final String toast = "toast";
	}

	abstract class P2pdirectoryFact extends Fact {
		public P2pdirectoryFact(int l) { super(l); }
		public void execute(P2pdirectory ensem) { }
		public void intro(P2pdirectory ensem) { }
	}

	public class StartOwner extends P2pdirectoryFact {
		public String arg1;
		public int arg2;
	
		public StartOwner(int l, String a1, int a2) { super(l); arg1=a1; arg2=a2; }
	
		public int fact_idx() { return 0; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1, (Serializable) arg2 };
			return new SerializedFact(loc, 0, arguments);
		}
	
		public String toString() { return String.format("[%s]StartOwner(%s,%s)",loc,arg1,arg2); }
	
	}
	
	public class StartMember extends P2pdirectoryFact {
		public String arg1;
		public int arg2;
	
		public StartMember(int l, String a1, int a2) { super(l); arg1=a1; arg2=a2; }
	
		public int fact_idx() { return 1; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1, (Serializable) arg2 };
			return new SerializedFact(loc, 1, arguments);
		}
	
		public String toString() { return String.format("[%s]StartMember(%s,%s)",loc,arg1,arg2); }
	
	}
	
	public class Quit extends P2pdirectoryFact {
		
	
		public Quit(int l) { super(l); }
	
		public int fact_idx() { return 2; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = {  };
			return new SerializedFact(loc, 2, arguments);
		}
	
		public String toString() { return String.format("[%s]Quit()",loc); }
	
	}
	
	public class Connect extends P2pdirectoryFact {
		public String arg1;
		public String arg2;
	
		public Connect(int l, String a1, String a2) { super(l); arg1=a1; arg2=a2; }
	
		public int fact_idx() { return 3; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1, (Serializable) arg2 };
			return new SerializedFact(loc, 3, arguments);
		}
	
		public String toString() { return String.format("[%s]Connect(%s,%s)",loc,arg1,arg2); }
	
	}
	
	public class Node extends P2pdirectoryFact {
		public int arg1;
	
		public Node(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 4; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 4, arguments);
		}
	
		public String toString() { return String.format("[%s]Node(%s)",loc,arg1); }
	
	}
	
	public class Seen extends P2pdirectoryFact {
		public String arg1;
	
		public Seen(int l, String a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 5; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 5, arguments);
		}
	
		public String toString() { return String.format("[%s]Seen(%s)",loc,arg1); }
	
	}
	
	public class Member extends P2pdirectoryFact {
		
	
		public Member(int l) { super(l); }
	
		public int fact_idx() { return 6; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = {  };
			return new SerializedFact(loc, 6, arguments);
		}
	
		public String toString() { return String.format("[%s]Member()",loc); }
	
	}
	
	public class Owner extends P2pdirectoryFact {
		
	
		public Owner(int l) { super(l); }
	
		public int fact_idx() { return 7; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = {  };
			return new SerializedFact(loc, 7, arguments);
		}
	
		public String toString() { return String.format("[%s]Owner()",loc); }
	
	}
	
	public class OwnerAt extends P2pdirectoryFact {
		public int arg1;
	
		public OwnerAt(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 8; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 8, arguments);
		}
	
		public String toString() { return String.format("[%s]OwnerAt(%s)",loc,arg1); }
	
	}
	
	public class JoinRequest extends P2pdirectoryFact {
		public String arg1;
		public String arg2;
		public String arg3;
	
		public JoinRequest(int l, String a1, String a2, String a3) { super(l); arg1=a1; arg2=a2; arg3=a3; }
	
		public int fact_idx() { return 9; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1, (Serializable) arg2, (Serializable) arg3 };
			return new SerializedFact(loc, 9, arguments);
		}
	
		public String toString() { return String.format("[%s]JoinRequest(%s,%s,%s)",loc,arg1,arg2,arg3); }
	
	}
	
	public class ReqCode extends P2pdirectoryFact {
		public String arg1;
	
		public ReqCode(int l, String a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 10; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 10, arguments);
		}
	
		public String toString() { return String.format("[%s]ReqCode(%s)",loc,arg1); }
	
	}
	
	public class NextLoc extends P2pdirectoryFact {
		public int arg1;
	
		public NextLoc(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 11; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 11, arguments);
		}
	
		public String toString() { return String.format("[%s]NextLoc(%s)",loc,arg1); }
	
	}
	
	public class Remove extends P2pdirectoryFact {
		public int arg1;
	
		public Remove(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 12; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 12, arguments);
		}
	
		public String toString() { return String.format("[%s]Remove(%s)",loc,arg1); }
	
	}
	
	public class NotifyNodeAdded extends P2pdirectoryFact {
		public int arg1;
		public String arg2;
		public String arg3;
		public String arg4;
	
		public NotifyNodeAdded(int l, int a1, String a2, String a3, String a4) { super(l); arg1=a1; arg2=a2; arg3=a3; arg4=a4; }
	
		public int fact_idx() { return 13; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.invokeActuator("notifynodeadded",Tuples.make_tuple(arg1,arg2,arg3,arg4)); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1, (Serializable) arg2, (Serializable) arg3, (Serializable) arg4 };
			return new SerializedFact(loc, 13, arguments);
		}
	
		public String toString() { return String.format("[%s]NotifyNodeAdded(%s,%s,%s,%s)",loc,arg1,arg2,arg3,arg4); }
	
	}
	
	public class NotifyNodeRemoved extends P2pdirectoryFact {
		public int arg1;
	
		public NotifyNodeRemoved(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 14; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.invokeActuator("notifynoderemoved",arg1); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 14, arguments);
		}
	
		public String toString() { return String.format("[%s]NotifyNodeRemoved(%s)",loc,arg1); }
	
	}
	
	public class NotifyLocAssign extends P2pdirectoryFact {
		public int arg1;
	
		public NotifyLocAssign(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 15; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.invokeActuator("notifylocassign",arg1); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 15, arguments);
		}
	
		public String toString() { return String.format("[%s]NotifyLocAssign(%s)",loc,arg1); }
	
	}
	
	public class NotifyOwnerQuit extends P2pdirectoryFact {
		
	
		public NotifyOwnerQuit(int l) { super(l); }
	
		public int fact_idx() { return 16; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.invokeActuator("notifyownerquit",Tuples.make_unit()); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = {  };
			return new SerializedFact(loc, 16, arguments);
		}
	
		public String toString() { return String.format("[%s]NotifyOwnerQuit()",loc); }
	
	}
	
	public class Delay extends P2pdirectoryFact {
		public int arg1;
	
		public Delay(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 17; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.invokeActuator("delay",arg1); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 17, arguments);
		}
	
		public String toString() { return String.format("[%s]Delay(%s)",loc,arg1); }
	
	}
	
	public class Beep extends P2pdirectoryFact {
		public String arg1;
	
		public Beep(int l, String a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 18; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.invokeActuator("beep",arg1); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 18, arguments);
		}
	
		public String toString() { return String.format("[%s]Beep(%s)",loc,arg1); }
	
	}
	
	public class Toast extends P2pdirectoryFact {
		public String arg1;
	
		public Toast(int l, String a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 19; }
	
		@Override
		public void execute(P2pdirectory ensem) { ensem.invokeActuator("toast",arg1); }
	
		@Override
		public void intro(P2pdirectory ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 19, arguments);
		}
	
		public String toString() { return String.format("[%s]Toast(%s)",loc,arg1); }
	
	}
	

	protected static int index1Quit(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0Connect(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0Node(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0Seen(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0Member(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0Owner(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0OwnerAt(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0JoinRequest(int loc, String arg1) {
		return Hash.join(Hash.hash(loc),Hash.hash(arg1));
	}
	protected static int index0ReqCode(int loc) {
		return Hash.hash(loc);
	}
	protected static int index1ReqCode(int loc, String arg1) {
		return Hash.join(Hash.hash(loc),Hash.hash(arg1));
	}
	protected static int index0NextLoc(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0Remove(int loc) {
		return Hash.hash(loc);
	}

	protected static final int startowner_fact_idx = 0;
	protected static final int startmember_fact_idx = 1;
	protected static final int quit_fact_idx = 2;
	protected static final int connect_fact_idx = 3;
	protected static final int node_fact_idx = 4;
	protected static final int seen_fact_idx = 5;
	protected static final int member_fact_idx = 6;
	protected static final int owner_fact_idx = 7;
	protected static final int ownerat_fact_idx = 8;
	protected static final int joinrequest_fact_idx = 9;
	protected static final int reqcode_fact_idx = 10;
	protected static final int nextloc_fact_idx = 11;
	protected static final int remove_fact_idx = 12;
	protected static final int notifynodeadded_fact_idx = 13;
	protected static final int notifynoderemoved_fact_idx = 14;
	protected static final int notifylocassign_fact_idx = 15;
	protected static final int notifyownerquit_fact_idx = 16;
	protected static final int delay_fact_idx = 17;
	protected static final int beep_fact_idx = 18;
	protected static final int toast_fact_idx = 19;

	protected Goals<P2pdirectoryFact> goals;

	protected ListStore<StartOwner> startowner_store_0;
	protected ListStore<StartMember> startmember_store_0;
	protected ListStore<Quit> quit_store_0;
	protected MultiMapStore<Quit> quit_store_1;
	protected MultiMapStore<Connect> connect_store_0;
	protected ListStore<Connect> connect_store_1;
	protected MultiMapStore<Node> node_store_0;
	protected ListStore<Node> node_store_1;
	protected MultiMapStore<Seen> seen_store_0;
	protected ListStore<Seen> seen_store_1;
	protected MultiMapStore<Member> member_store_0;
	protected ListStore<Member> member_store_1;
	protected MultiMapStore<Owner> owner_store_0;
	protected ListStore<Owner> owner_store_1;
	protected MultiMapStore<OwnerAt> ownerat_store_0;
	protected ListStore<OwnerAt> ownerat_store_1;
	protected MultiMapStore<JoinRequest> joinrequest_store_0;
	protected ListStore<JoinRequest> joinrequest_store_1;
	protected MultiMapStore<ReqCode> reqcode_store_0;
	protected MultiMapStore<ReqCode> reqcode_store_1;
	protected ListStore<ReqCode> reqcode_store_2;
	protected MultiMapStore<NextLoc> nextloc_store_0;
	protected ListStore<NextLoc> nextloc_store_1;
	protected MultiMapStore<Remove> remove_store_0;
	protected ListStore<Remove> remove_store_1;

	protected int startOwner_rule_count;
	protected int startMember_rule_count;
	protected int connect_rule_count;
	protected int join_rule_count;
	protected int quitO_rule_count;
	protected int quitM_rule_count;
	protected int remove_rule_count;
	protected int rule_app_misses;

	public P2pdirectory() {
		super();
	
		startOwner_rule_count = 0;
		startMember_rule_count = 0;
		connect_rule_count = 0;
		join_rule_count = 0;
		quitO_rule_count = 0;
		quitM_rule_count = 0;
		remove_rule_count = 0;
		rule_app_misses = 0;
	
		goals = new ListGoals<P2pdirectoryFact>();
		set_goal_component( goals );
	
		startowner_store_0 = new ListStore<StartOwner>();
		startowner_store_0.set_name("StartOwner Store");
		// set_store_component( startowner_store_0 );
		
		startmember_store_0 = new ListStore<StartMember>();
		startmember_store_0.set_name("StartMember Store");
		// set_store_component( startmember_store_0 );
		
		quit_store_0 = new ListStore<Quit>();
		quit_store_0.set_name("Quit Store");
		// set_store_component( quit_store_0 );
		
		quit_store_1 = new MultiMapStore<Quit>();
		quit_store_1.set_name("Quit Store");
		// set_store_component( quit_store_1 );
		
		connect_store_0 = new MultiMapStore<Connect>();
		connect_store_0.set_name("Connect Store");
		// set_store_component( connect_store_0 );
		
		connect_store_1 = new ListStore<Connect>();
		connect_store_1.set_name("Connect Store");
		// set_store_component( connect_store_1 );
		
		node_store_0 = new MultiMapStore<Node>();
		node_store_0.set_name("Node Store");
		// set_store_component( node_store_0 );
		
		node_store_1 = new ListStore<Node>();
		node_store_1.set_name("Node Store");
		// set_store_component( node_store_1 );
		
		seen_store_0 = new MultiMapStore<Seen>();
		seen_store_0.set_name("Seen Store");
		// set_store_component( seen_store_0 );
		
		seen_store_1 = new ListStore<Seen>();
		seen_store_1.set_name("Seen Store");
		// set_store_component( seen_store_1 );
		
		member_store_0 = new MultiMapStore<Member>();
		member_store_0.set_name("Member Store");
		// set_store_component( member_store_0 );
		
		member_store_1 = new ListStore<Member>();
		member_store_1.set_name("Member Store");
		// set_store_component( member_store_1 );
		
		owner_store_0 = new MultiMapStore<Owner>();
		owner_store_0.set_name("Owner Store");
		// set_store_component( owner_store_0 );
		
		owner_store_1 = new ListStore<Owner>();
		owner_store_1.set_name("Owner Store");
		// set_store_component( owner_store_1 );
		
		ownerat_store_0 = new MultiMapStore<OwnerAt>();
		ownerat_store_0.set_name("OwnerAt Store");
		// set_store_component( ownerat_store_0 );
		
		ownerat_store_1 = new ListStore<OwnerAt>();
		ownerat_store_1.set_name("OwnerAt Store");
		// set_store_component( ownerat_store_1 );
		
		joinrequest_store_0 = new MultiMapStore<JoinRequest>();
		joinrequest_store_0.set_name("JoinRequest Store");
		// set_store_component( joinrequest_store_0 );
		
		joinrequest_store_1 = new ListStore<JoinRequest>();
		joinrequest_store_1.set_name("JoinRequest Store");
		// set_store_component( joinrequest_store_1 );
		
		reqcode_store_0 = new MultiMapStore<ReqCode>();
		reqcode_store_0.set_name("ReqCode Store");
		// set_store_component( reqcode_store_0 );
		
		reqcode_store_1 = new MultiMapStore<ReqCode>();
		reqcode_store_1.set_name("ReqCode Store");
		// set_store_component( reqcode_store_1 );
		
		reqcode_store_2 = new ListStore<ReqCode>();
		reqcode_store_2.set_name("ReqCode Store");
		// set_store_component( reqcode_store_2 );
		
		nextloc_store_0 = new MultiMapStore<NextLoc>();
		nextloc_store_0.set_name("NextLoc Store");
		// set_store_component( nextloc_store_0 );
		
		nextloc_store_1 = new ListStore<NextLoc>();
		nextloc_store_1.set_name("NextLoc Store");
		// set_store_component( nextloc_store_1 );
		
		remove_store_0 = new MultiMapStore<Remove>();
		remove_store_0.set_name("Remove Store");
		// set_store_component( remove_store_0 );
		
		remove_store_1 = new ListStore<Remove>();
		remove_store_1.set_name("Remove Store");
		// set_store_component( remove_store_1 );
		
	
		set_store_component( startowner_store_0 );
		set_store_component( startmember_store_0 );
		set_store_component( quit_store_0 );
		set_store_component( connect_store_1 );
		set_store_component( node_store_1 );
		set_store_component( seen_store_1 );
		set_store_component( member_store_1 );
		set_store_component( owner_store_1 );
		set_store_component( ownerat_store_1 );
		set_store_component( joinrequest_store_1 );
		set_store_component( reqcode_store_2 );
		set_store_component( nextloc_store_1 );
		set_store_component( remove_store_1 );
	}
	

	@Override
	protected boolean rewrite() {
		boolean done_something = false;
		while(goals.has_goals()) {
			goals.next().execute( this );
			done_something = true;
		}
		return done_something;
	}
	
	@Override
	protected boolean rewrite(int max_steps) {
		int count = 0;
		while(goals.has_goals() && count < max_steps) {
			goals.next().execute( this );
			count++;
		}
		return count > 0;
	}

	protected P2pdirectoryFact demultiplex(SerializedFact fact) {
		Serializable[] args = fact.arguments;
		switch(fact.fact_idx) {
			case 0: return new StartOwner(fact.loc,(String) args[0],(Integer) args[1]);
			
			case 1: return new StartMember(fact.loc,(String) args[0],(Integer) args[1]);
			
			case 2: return new Quit(fact.loc);
			
			case 3: return new Connect(fact.loc,(String) args[0],(String) args[1]);
			
			case 4: return new Node(fact.loc,(Integer) args[0]);
			
			case 5: return new Seen(fact.loc,(String) args[0]);
			
			case 6: return new Member(fact.loc);
			
			case 7: return new Owner(fact.loc);
			
			case 8: return new OwnerAt(fact.loc,(Integer) args[0]);
			
			case 9: return new JoinRequest(fact.loc,(String) args[0],(String) args[1],(String) args[2]);
			
			case 10: return new ReqCode(fact.loc,(String) args[0]);
			
			case 11: return new NextLoc(fact.loc,(Integer) args[0]);
			
			case 12: return new Remove(fact.loc,(Integer) args[0]);
			
			case 13: return new NotifyNodeAdded(fact.loc,(Integer) args[0],(String) args[1],(String) args[2],(String) args[3]);
			
			case 14: return new NotifyNodeRemoved(fact.loc,(Integer) args[0]);
			
			case 15: return new NotifyLocAssign(fact.loc,(Integer) args[0]);
			
			case 16: return new NotifyOwnerQuit(fact.loc);
			
			case 17: return new Delay(fact.loc,(Integer) args[0]);
			
			case 18: return new Beep(fact.loc,(String) args[0]);
			
			case 19: return new Toast(fact.loc,(String) args[0]);
			
		}
		return null;
	}
	
	
	@Override
	protected synchronized boolean flushGoals() {
		if (external_goals.size() == 0) { return false; }
		for (SerializedFact new_goal : external_goals) {
			P2pdirectoryFact ef_goal = demultiplex( new_goal );
			ef_goal.intro( this ) ;
		}
		external_goals.clear();
		return true;
	}
	
	protected void store(StartOwner startowner) {
		startowner_store_0.add( startowner );
	} 				
	
	protected void store(StartMember startmember) {
		startmember_store_0.add( startmember );
	} 				
	
	protected void store(Quit quit) {
		quit_store_0.add( quit );
		quit_store_1.add( quit, index1Quit(quit.loc) );
	} 				
	
	protected void store(Connect connect) {
		connect_store_0.add( connect, index0Connect(connect.loc) );
		connect_store_1.add( connect );
	} 				
	
	protected void store(Node node) {
		node_store_0.add( node, index0Node(node.loc) );
		node_store_1.add( node );
	} 				
	
	protected void store(Seen seen) {
		seen_store_0.add( seen, index0Seen(seen.loc) );
		seen_store_1.add( seen );
	} 				
	
	protected void store(Member member) {
		member_store_0.add( member, index0Member(member.loc) );
		member_store_1.add( member );
	} 				
	
	protected void store(Owner owner) {
		owner_store_0.add( owner, index0Owner(owner.loc) );
		owner_store_1.add( owner );
	} 				
	
	protected void store(OwnerAt ownerat) {
		ownerat_store_0.add( ownerat, index0OwnerAt(ownerat.loc) );
		ownerat_store_1.add( ownerat );
	} 				
	
	protected void store(JoinRequest joinrequest) {
		joinrequest_store_0.add( joinrequest, index0JoinRequest(joinrequest.loc,joinrequest.arg1) );
		joinrequest_store_1.add( joinrequest );
	} 				
	
	protected void store(ReqCode reqcode) {
		reqcode_store_0.add( reqcode, index0ReqCode(reqcode.loc) );
		reqcode_store_1.add( reqcode, index1ReqCode(reqcode.loc,reqcode.arg1) );
		reqcode_store_2.add( reqcode );
	} 				
	
	protected void store(NextLoc nextloc) {
		nextloc_store_0.add( nextloc, index0NextLoc(nextloc.loc) );
		nextloc_store_1.add( nextloc );
	} 				
	
	protected void store(Remove remove) {
		remove_store_0.add( remove, index0Remove(remove.loc) );
		remove_store_1.add( remove );
	} 				
	
	protected void store(NotifyNodeAdded notifynodeadded) {
		
	} 				
	
	protected void store(NotifyNodeRemoved notifynoderemoved) {
		
	} 				
	
	protected void store(NotifyLocAssign notifylocassign) {
		
	} 				
	
	protected void store(NotifyOwnerQuit notifyownerquit) {
		
	} 				
	
	protected void store(Delay delay) {
		
	} 				
	
	protected void store(Beep beep) {
		
	} 				
	
	protected void store(Toast toast) {
		
	} 				
	
	public void add_startowner(int loc,String arg1,int arg2) {
		if (isSolo || location == loc) {
			intro( new StartOwner(loc,arg1,arg2) );
		}
	}
	
	public void add_startmember(int loc,String arg1,int arg2) {
		if (isSolo || location == loc) {
			intro( new StartMember(loc,arg1,arg2) );
		}
	}
	
	public void add_quit(int loc) {
		if (isSolo || location == loc) {
			intro( new Quit(loc) );
		}
	}
	
	public void add_connect(int loc,String arg1,String arg2) {
		if (isSolo || location == loc) {
			intro( new Connect(loc,arg1,arg2) );
		}
	}
	
	public void add_node(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new Node(loc,arg1) );
		}
	}
	
	public void add_seen(int loc,String arg1) {
		if (isSolo || location == loc) {
			intro( new Seen(loc,arg1) );
		}
	}
	
	public void add_member(int loc) {
		if (isSolo || location == loc) {
			intro( new Member(loc) );
		}
	}
	
	public void add_owner(int loc) {
		if (isSolo || location == loc) {
			intro( new Owner(loc) );
		}
	}
	
	public void add_ownerat(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new OwnerAt(loc,arg1) );
		}
	}
	
	public void add_joinrequest(int loc,String arg1,String arg2,String arg3) {
		if (isSolo || location == loc) {
			intro( new JoinRequest(loc,arg1,arg2,arg3) );
		}
	}
	
	public void add_reqcode(int loc,String arg1) {
		if (isSolo || location == loc) {
			intro( new ReqCode(loc,arg1) );
		}
	}
	
	public void add_nextloc(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new NextLoc(loc,arg1) );
		}
	}
	
	public void add_remove(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new Remove(loc,arg1) );
		}
	}
	
	public void add_notifynodeadded(int loc,int arg1,String arg2,String arg3,String arg4) {
		if (isSolo || location == loc) {
			intro( new NotifyNodeAdded(loc,arg1,arg2,arg3,arg4) );
		}
	}
	
	public void add_notifynoderemoved(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new NotifyNodeRemoved(loc,arg1) );
		}
	}
	
	public void add_notifylocassign(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new NotifyLocAssign(loc,arg1) );
		}
	}
	
	public void add_notifyownerquit(int loc) {
		if (isSolo || location == loc) {
			intro( new NotifyOwnerQuit(loc) );
		}
	}
	
	public void add_delay(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new Delay(loc,arg1) );
		}
	}
	
	public void add_beep(int loc,String arg1) {
		if (isSolo || location == loc) {
			intro( new Beep(loc,arg1) );
		}
	}
	
	public void add_toast(int loc,String arg1) {
		if (isSolo || location == loc) {
			intro( new Toast(loc,arg1) );
		}
	}
	
	protected void intro(StartOwner startowner) {
		goals.add( startowner );
		notify_new_goals();
	}
	
	protected void intro(StartMember startmember) {
		goals.add( startmember );
		notify_new_goals();
	}
	
	protected void intro(Quit quit) {
		goals.add( quit );
		notify_new_goals();
	}
	
	protected void intro(Connect connect) {
		goals.add( connect );
		notify_new_goals();
	}
	
	protected void intro(Node node) {
		goals.add( node );
		store( node );
		notify_new_goals();
	}	
	
	protected void intro(Seen seen) {
		goals.add( seen );
		store( seen );
		notify_new_goals();
	}	
	
	protected void intro(Member member) {
		goals.add( member );
		notify_new_goals();
	}
	
	protected void intro(Owner owner) {
		goals.add( owner );
		notify_new_goals();
	}
	
	protected void intro(OwnerAt ownerat) {
		goals.add( ownerat );
		notify_new_goals();
	}
	
	protected void intro(JoinRequest joinrequest) {
		goals.add( joinrequest );
		notify_new_goals();
	}
	
	protected void intro(ReqCode reqcode) {
		goals.add( reqcode );
		notify_new_goals();
	}
	
	protected void intro(NextLoc nextloc) {
		goals.add( nextloc );
		notify_new_goals();
	}
	
	protected void intro(Remove remove) {
		goals.add( remove );
		notify_new_goals();
	}
	
	protected void intro(NotifyNodeAdded notifynodeadded) {
		goals.add( notifynodeadded );
		notify_new_goals();
	}
	
	protected void intro(NotifyNodeRemoved notifynoderemoved) {
		goals.add( notifynoderemoved );
		notify_new_goals();
	}
	
	protected void intro(NotifyLocAssign notifylocassign) {
		goals.add( notifylocassign );
		notify_new_goals();
	}
	
	protected void intro(NotifyOwnerQuit notifyownerquit) {
		goals.add( notifyownerquit );
		notify_new_goals();
	}
	
	protected void intro(Delay delay) {
		goals.add( delay );
		store( delay );
		notify_new_goals();
	}	
	
	protected void intro(Beep beep) {
		goals.add( beep );
		store( beep );
		notify_new_goals();
	}	
	
	protected void intro(Toast toast) {
		goals.add( toast );
		store( toast );
		notify_new_goals();
	}	
	
	protected void send(StartOwner startowner) {
		if(location == startowner.get_loc()) {
			intro(startowner);
		} else {
			send_buffers.add(startowner);
		}
	}
	
	protected void send(StartMember startmember) {
		if(location == startmember.get_loc()) {
			intro(startmember);
		} else {
			send_buffers.add(startmember);
		}
	}
	
	protected void send(Quit quit) {
		if(location == quit.get_loc()) {
			intro(quit);
		} else {
			send_buffers.add(quit);
		}
	}
	
	protected void send(Connect connect) {
		if(location == connect.get_loc()) {
			intro(connect);
		} else {
			send_buffers.add(connect);
		}
	}
	
	protected void send(Node node) {
		if(location == node.get_loc()) {
			intro(node);
		} else {
			send_buffers.add(node);
		}
	}
	
	protected void send(Seen seen) {
		if(location == seen.get_loc()) {
			intro(seen);
		} else {
			send_buffers.add(seen);
		}
	}
	
	protected void send(Member member) {
		if(location == member.get_loc()) {
			intro(member);
		} else {
			send_buffers.add(member);
		}
	}
	
	protected void send(Owner owner) {
		if(location == owner.get_loc()) {
			intro(owner);
		} else {
			send_buffers.add(owner);
		}
	}
	
	protected void send(OwnerAt ownerat) {
		if(location == ownerat.get_loc()) {
			intro(ownerat);
		} else {
			send_buffers.add(ownerat);
		}
	}
	
	protected void send(JoinRequest joinrequest) {
		if(location == joinrequest.get_loc()) {
			intro(joinrequest);
		} else {
			send_buffers.add(joinrequest);
		}
	}
	
	protected void send(ReqCode reqcode) {
		if(location == reqcode.get_loc()) {
			intro(reqcode);
		} else {
			send_buffers.add(reqcode);
		}
	}
	
	protected void send(NextLoc nextloc) {
		if(location == nextloc.get_loc()) {
			intro(nextloc);
		} else {
			send_buffers.add(nextloc);
		}
	}
	
	protected void send(Remove remove) {
		if(location == remove.get_loc()) {
			intro(remove);
		} else {
			send_buffers.add(remove);
		}
	}
	
	protected void send(NotifyNodeAdded notifynodeadded) {
		if(location == notifynodeadded.get_loc()) {
			intro(notifynodeadded);
		} else {
			send_buffers.add(notifynodeadded);
		}
	}
	
	protected void send(NotifyNodeRemoved notifynoderemoved) {
		if(location == notifynoderemoved.get_loc()) {
			intro(notifynoderemoved);
		} else {
			send_buffers.add(notifynoderemoved);
		}
	}
	
	protected void send(NotifyLocAssign notifylocassign) {
		if(location == notifylocassign.get_loc()) {
			intro(notifylocassign);
		} else {
			send_buffers.add(notifylocassign);
		}
	}
	
	protected void send(NotifyOwnerQuit notifyownerquit) {
		if(location == notifyownerquit.get_loc()) {
			intro(notifyownerquit);
		} else {
			send_buffers.add(notifyownerquit);
		}
	}
	
	protected void send(Delay delay) {
		if(location == delay.get_loc()) {
			intro(delay);
		} else {
			send_buffers.add(delay);
		}
	}
	
	protected void send(Beep beep) {
		if(location == beep.get_loc()) {
			intro(beep);
		} else {
			send_buffers.add(beep);
		}
	}
	
	protected void send(Toast toast) {
		if(location == toast.get_loc()) {
			intro(toast);
		} else {
			send_buffers.add(toast);
		}
	}
	
	

	public void addStartOwner(String arg1,int arg2) {
		intro( new StartOwner(location,arg1,arg2) );
	}
	
	public void addStartMember(String arg1,int arg2) {
		intro( new StartMember(location,arg1,arg2) );
	}
	
	public void addQuit() {
		intro( new Quit(location) );
	}
	
	public void addConnect(String arg1,String arg2) {
		intro( new Connect(location,arg1,arg2) );
	}
	

	public void setNotifyNodeAddedActuator(ActuatorAction<Tuple4<Integer,String,String,String>> action) {
		setActuator("notifynodeadded", action);
	}
	
	public void setNotifyNodeRemovedActuator(ActuatorAction<Integer> action) {
		setActuator("notifynoderemoved", action);
	}
	
	public void setNotifyLocAssignActuator(ActuatorAction<Integer> action) {
		setActuator("notifylocassign", action);
	}
	
	public void setNotifyOwnerQuitActuator(ActuatorAction<Unit> action) {
		setActuator("notifyownerquit", action);
	}
	
	public void setDelayActuator(ActuatorAction<Integer> action) {
		setActuator("delay", action);
	}
	
	public void setBeepActuator(ActuatorAction<String> action) {
		setActuator("beep", action);
	}
	
	public void setToastActuator(ActuatorAction<String> action) {
		setActuator("toast", action);
	}
	

	

	public ConcListStore[] getLinearStores() {
		ConcListStore[] stores = new ConcListStore[0];
		
		return stores;
	}
	

	/*
	**** 0 Join Ordering of Rule startOwner ****
	Rule Head Variables: Code, LocO, O
	Rule Head Compre Binders: 
	Active #H0 [O]startOwner(Code,LocO)
	DeleteHead #H0
	LetBind LocN next(LocO)
	IntroAtom Local NoPrior Mono [O]owner()
	IntroAtom Local NoPrior NonMono [O]node(LocO)
	IntroAtom Local NoPrior Mono [O]reqCode(Code)
	IntroAtom Local NoPrior Mono [O]nextLoc(LocN)
	*/
	protected boolean execute_startowner_join_ordering_1(StartOwner act) {
		
		String code;
		int locn;
		int loco;
		int o;
		// Join Task: Active #H0 [O]startOwner(Code,LocO)
		o = act.loc;
		code = act.arg1;
		loco = act.arg2;
		// Join Task: DeleteHead #H0
		// H0 is active and monotone, no delete required
		// Join Task: LetBind LocN next(LocO)
		locn = WifiDirectComingleDirectory.next(loco);
		;
		// Join Task: IntroAtom Local NoPrior Mono [O]owner()
		intro( new Owner(o) );
		// Join Task: IntroAtom Local NoPrior NonMono [O]node(LocO)
		intro( new Node(o,loco) );
		// Join Task: IntroAtom Local NoPrior Mono [O]reqCode(Code)
		intro( new ReqCode(o,code) );
		// Join Task: IntroAtom Local NoPrior Mono [O]nextLoc(LocN)
		intro( new NextLoc(o,locn) );
		startOwner_rule_count++;
		return false;
		
	}
	
	/*
	**** 0 Join Ordering of Rule startMember ****
	Rule Head Variables: Code, M, LocO
	Rule Head Compre Binders: 
	Active #H0 [M]startMember(Code,LocO)
	DeleteHead #H0
	IntroAtom Local NoPrior Mono [M]member()
	IntroAtom Local NoPrior Mono [M]reqCode(Code)
	IntroAtom Local NoPrior Mono [M]ownerAt(LocO)
	*/
	protected boolean execute_startmember_join_ordering_1(StartMember act) {
		
		String code;
		int m;
		int loco;
		// Join Task: Active #H0 [M]startMember(Code,LocO)
		m = act.loc;
		code = act.arg1;
		loco = act.arg2;
		// Join Task: DeleteHead #H0
		// H0 is active and monotone, no delete required
		// Join Task: IntroAtom Local NoPrior Mono [M]member()
		intro( new Member(m) );
		// Join Task: IntroAtom Local NoPrior Mono [M]reqCode(Code)
		intro( new ReqCode(m,code) );
		// Join Task: IntroAtom Local NoPrior Mono [M]ownerAt(LocO)
		intro( new OwnerAt(m,loco) );
		startMember_rule_count++;
		return false;
		
	}
	
	/*
	**** 0 Join Ordering of Rule quitO ****
	Rule Head Variables: M, Ms, O
	Rule Head Compre Binders: M
	Active #H0 [M]quit()
	LookupAtom #H1 7:1:linear<[-]owner()|.>   [O]owner()
	LookupAll #H2 4:0:hash<[+]node(-)|.>  O [O]node(M)
	CompreDomain #H2 M Ms [O]node(M)
	DeleteHead #H0
	IntroCompre Remote NoPrior Mono M Ms [M]notifyOwnerQuit()
	*/
	protected boolean execute_quit_join_ordering_1(Quit act) {
		
		int m;
		SimpMultiset<Integer>  ms;
		int o;
		// Join Task: Active #H0 [M]quit()
		m = act.loc;
		// Join Task: LookupAtom #H1 7:1:linear<[-]owner()|.>   [O]owner()
		StoreIter<Owner> candidates_1 = owner_store_1.lookup_candidates();
		Owner cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			o = cand_1.loc;
			if (true) {
				// Join Task: LookupAll #H2 4:0:hash<[+]node(-)|.>  O [O]node(M)
				StoreIter<Node> candidates_2 = node_store_0.lookup_candidates(index0Node(o));
				// Join Task: CompreDomain #H2 M Ms [O]node(M)
				ms = new SimpMultiset<Integer> ();
				Node cand_2_0 = candidates_2.get_next_alive();
				while(cand_2_0 != null) {
					o = cand_2_0.loc;
					m = cand_2_0.arg1;
					ms.add( m );
					cand_2_0 = candidates_2.get_next_alive();
				}
				candidates_2.init_iter();
				// Join Task: DeleteHead #H0
				// H0 is active and monotone, no delete required
				// Join Task: IntroCompre Remote NoPrior Mono M Ms [M]notifyOwnerQuit()
				SimpMultiset<Integer>  comp_0 = ms;
				for(int idx=0; idx<comp_0.size(); idx++) {
					m = comp_0.get(idx);
					intro( new NotifyOwnerQuit(m) );
				}
				quitO_rule_count++;
				return false;
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule quitM ****
	Rule Head Variables: M, O
	Rule Head Compre Binders: 
	Active #H0 [M]quit()
	LookupAtom #H1 6:0:hash<[+]member()|.>  M [M]member()
	LookupAtom #H2 8:0:hash<[+]ownerAt(-)|.>  M [M]ownerAt(O)
	DeleteHead #H0
	IntroAtom Remote NoPrior Mono [O]remove(M)
	*/
	protected boolean execute_quit_join_ordering_2(Quit act) {
		
		int m;
		int o;
		// Join Task: Active #H0 [M]quit()
		m = act.loc;
		// Join Task: LookupAtom #H1 6:0:hash<[+]member()|.>  M [M]member()
		StoreIter<Member> candidates_1 = member_store_0.lookup_candidates(index0Member(m));
		Member cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int m1;
			m1 = cand_1.loc;
			if (true) {
				// Join Task: LookupAtom #H2 8:0:hash<[+]ownerAt(-)|.>  M [M]ownerAt(O)
				StoreIter<OwnerAt> candidates_2 = ownerat_store_0.lookup_candidates(index0OwnerAt(m));
				OwnerAt cand_2 = candidates_2.get_next();
				while(cand_2 != null) {
					int m2;
					m2 = cand_2.loc;
					o = cand_2.arg1;
					if (true) {
						// Join Task: DeleteHead #H0
						// H0 is active and monotone, no delete required
						// Join Task: IntroAtom Remote NoPrior Mono [O]remove(M)
						send( new Remove(o,m) ); 
						quitM_rule_count++;
						return false;
					}
					cand_2 = candidates_2.get_next();
				}
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule connect ****
	Rule Head Variables: MacM, NameM, M, C, O
	Rule Head Compre Binders: 
	Active #H0 [M]connect(NameM,MacM)
	LookupAtom #H1 6:0:hash<[+]member()|.>  M [M]member()
	LookupAtom #H2 8:0:hash<[+]ownerAt(-)|.>  M [M]ownerAt(O)
	LookupAtom #H3 10:0:hash<[+]reqCode(-)|.>  M [M]reqCode(C)
	DeleteHead #H0
	IntroAtom Remote NoPrior Mono [O]joinRequest(C,NameM,MacM)
	*/
	protected boolean execute_connect_join_ordering_1(Connect act) {
		
		String macm;
		String namem;
		int m;
		String c;
		int o;
		// Join Task: Active #H0 [M]connect(NameM,MacM)
		m = act.loc;
		namem = act.arg1;
		macm = act.arg2;
		// Join Task: LookupAtom #H1 6:0:hash<[+]member()|.>  M [M]member()
		StoreIter<Member> candidates_1 = member_store_0.lookup_candidates(index0Member(m));
		Member cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int m1;
			m1 = cand_1.loc;
			if (true) {
				// Join Task: LookupAtom #H2 8:0:hash<[+]ownerAt(-)|.>  M [M]ownerAt(O)
				StoreIter<OwnerAt> candidates_2 = ownerat_store_0.lookup_candidates(index0OwnerAt(m));
				OwnerAt cand_2 = candidates_2.get_next();
				while(cand_2 != null) {
					int m2;
					m2 = cand_2.loc;
					o = cand_2.arg1;
					if (true) {
						// Join Task: LookupAtom #H3 10:0:hash<[+]reqCode(-)|.>  M [M]reqCode(C)
						StoreIter<ReqCode> candidates_3 = reqcode_store_0.lookup_candidates(index0ReqCode(m));
						ReqCode cand_3 = candidates_3.get_next();
						while(cand_3 != null) {
							int m3;
							m3 = cand_3.loc;
							c = cand_3.arg1;
							if (true) {
								// Join Task: DeleteHead #H0
								// H0 is active and monotone, no delete required
								// Join Task: IntroAtom Remote NoPrior Mono [O]joinRequest(C,NameM,MacM)
								send( new JoinRequest(o,c,namem,macm) ); 
								connect_rule_count++;
								return false;
							}
							cand_3 = candidates_3.get_next();
						}
					}
					cand_2 = candidates_2.get_next();
				}
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 4 Join Ordering of Rule join ****
	Rule Head Variables: C, Name, LocN, O, Mac, Ls, Ms
	Rule Head Compre Binders: M, L
	Active #H0 [O]node(L)
	LookupAtom #H1 7:0:hash<[+]owner()|.>  O [O]owner()
	LookupAtom #H2 11:0:hash<[+]nextLoc(-)|.>  O [O]nextLoc(LocN)
	LookupAtom #H3 10:0:hash<[+]reqCode(-)|.>  O [O]reqCode(C)
	LookupAtom #H4 9:0:hash<[+]joinRequest(+,-,-)|.>  O,C [O]joinRequest(C,Name,Mac)
	LookupAll #H5 4:0:hash<[+]node(-)|.>  O [O]node(L)
	CompreDomain #H5 L Ls [O]node(L)
	LookupAll #H6 5:0:hash<[+]seen(-)|.>  O [O]seen(M)
	CompreDomain #H6 M Ms [O]seen(M)
	CheckGuard not(Mac in Ms)
	DeleteHead #H2
	DeleteHead #H4
	LetBind LocU next(LocN)
	LetBind Inet lookupIP(Mac)
	IntroAtom Remote NoPrior Mono [LocN]notifyNodeAdded(LocN,Inet,Name,Mac)
	IntroAtom Remote NoPrior Mono [LocN]notifyLocAssign(LocN)
	IntroAtom Remote NoPrior Mono [O]nextLoc(LocU)
	IntroAtom Remote NoPrior NonMono [O]node(LocN)
	IntroAtom Remote NoPrior NonMono [O]seen(Mac)
	IntroCompre Remote NoPrior Mono L Ls [L]notifyNodeAdded(LocN,Inet,Name,Mac)
	*/
	protected boolean execute_node_join_ordering_1(Node act) {
		
		String c;
		String name;
		String m;
		int locn;
		int l;
		int o;
		String mac;
		SimpMultiset<Integer>  ls;
		SimpMultiset<String>  ms;
		int locu;
		String inet;
		// Join Task: Active #H0 [O]node(L)
		if (act.is_alive()) {
			o = act.loc;
			l = act.arg1;
			// Join Task: LookupAtom #H1 7:0:hash<[+]owner()|.>  O [O]owner()
			StoreIter<Owner> candidates_1 = owner_store_0.lookup_candidates(index0Owner(o));
			Owner cand_1 = candidates_1.get_next();
			while(cand_1 != null) {
				int o1;
				o1 = cand_1.loc;
				if (true) {
					// Join Task: LookupAtom #H2 11:0:hash<[+]nextLoc(-)|.>  O [O]nextLoc(LocN)
					StoreIter<NextLoc> candidates_2 = nextloc_store_0.lookup_candidates(index0NextLoc(o));
					NextLoc cand_2 = candidates_2.get_next_alive();
					while(cand_2 != null) {
						int o2;
						o2 = cand_2.loc;
						locn = cand_2.arg1;
						if (true) {
							// Join Task: LookupAtom #H3 10:0:hash<[+]reqCode(-)|.>  O [O]reqCode(C)
							StoreIter<ReqCode> candidates_3 = reqcode_store_0.lookup_candidates(index0ReqCode(o));
							ReqCode cand_3 = candidates_3.get_next();
							while(cand_3 != null) {
								int o3;
								o3 = cand_3.loc;
								c = cand_3.arg1;
								if (true) {
									// Join Task: LookupAtom #H4 9:0:hash<[+]joinRequest(+,-,-)|.>  O,C [O]joinRequest(C,Name,Mac)
									StoreIter<JoinRequest> candidates_4 = joinrequest_store_0.lookup_candidates(index0JoinRequest(o,c));
									JoinRequest cand_4 = candidates_4.get_next_alive();
									while(cand_4 != null) {
										int o4;
										String c4;
										o4 = cand_4.loc;
										c4 = cand_4.arg1;
										name = cand_4.arg2;
										mac = cand_4.arg3;
										if (Equality.is_eq(o,o4) && Equality.is_eq(c,c4)) {
											// Join Task: LookupAll #H5 4:0:hash<[+]node(-)|.>  O [O]node(L)
											StoreIter<Node> candidates_5 = node_store_0.lookup_candidates(index0Node(o));
											// Join Task: CompreDomain #H5 L Ls [O]node(L)
											ls = new SimpMultiset<Integer> ();
											Node cand_5_0 = candidates_5.get_next_alive();
											while(cand_5_0 != null) {
												o = cand_5_0.loc;
												l = cand_5_0.arg1;
												ls.add( l );
												cand_5_0 = candidates_5.get_next_alive();
											}
											candidates_5.init_iter();
											// Join Task: LookupAll #H6 5:0:hash<[+]seen(-)|.>  O [O]seen(M)
											StoreIter<Seen> candidates_6 = seen_store_0.lookup_candidates(index0Seen(o));
											// Join Task: CompreDomain #H6 M Ms [O]seen(M)
											ms = new SimpMultiset<String> ();
											Seen cand_6_0 = candidates_6.get_next();
											while(cand_6_0 != null) {
												o = cand_6_0.loc;
												m = cand_6_0.arg1;
												ms.add( m );
												cand_6_0 = candidates_6.get_next();
											}
											candidates_6.init_iter();
											// Join Task: CheckGuard not(Mac in Ms)
											if (ExtLib.not(ExtLib.in(mac,ms))) {
												// Join Task: DeleteHead #H2
												nextloc_store_0.remove( cand_2 );
												// Join Task: DeleteHead #H4
												joinrequest_store_0.remove( cand_4 );
												// Join Task: LetBind LocU next(LocN)
												locu = WifiDirectComingleDirectory.next(locn);
												;
												// Join Task: LetBind Inet lookupIP(Mac)
												inet = WifiDirectComingleDirectory.lookupIP(mac);
												;
												// Join Task: IntroAtom Remote NoPrior Mono [LocN]notifyNodeAdded(LocN,Inet,Name,Mac)
												send( new NotifyNodeAdded(locn,locn,inet,name,mac) ); 
												// Join Task: IntroAtom Remote NoPrior Mono [LocN]notifyLocAssign(LocN)
												send( new NotifyLocAssign(locn,locn) ); 
												// Join Task: IntroAtom Remote NoPrior Mono [O]nextLoc(LocU)
												intro( new NextLoc(o,locu) );
												// Join Task: IntroAtom Remote NoPrior NonMono [O]node(LocN)
												intro( new Node(o,locn) );
												// Join Task: IntroAtom Remote NoPrior NonMono [O]seen(Mac)
												intro( new Seen(o,mac) );
												// Join Task: IntroCompre Remote NoPrior Mono L Ls [L]notifyNodeAdded(LocN,Inet,Name,Mac)
												SimpMultiset<Integer>  comp_0 = ls;
												for(int idx=0; idx<comp_0.size(); idx++) {
													l = comp_0.get(idx);
													send( new NotifyNodeAdded(l,locn,inet,name,mac) ); 
												}
												join_rule_count++;
											}
										} else {
										}
										cand_4 = candidates_4.get_next_alive();
									}
								}
								cand_3 = candidates_3.get_next();
							}
						}
						cand_2 = candidates_2.get_next_alive();
					}
				}
				cand_1 = candidates_1.get_next();
			}
		}
		return true;
	}
	
	/*
	**** 2 Join Ordering of Rule quitO ****
	Rule Head Variables: M, Ms, O
	Rule Head Compre Binders: M
	Active #H0 [O]node(M)
	LookupAtom #H1 7:0:hash<[+]owner()|.>  O [O]owner()
	LookupAtom #H2 2:0:linear<[-]quit()|.>   [M]quit()
	LookupAll #H3 4:0:hash<[+]node(-)|.>  O [O]node(M)
	CompreDomain #H3 M Ms [O]node(M)
	DeleteHead #H2
	IntroCompre Remote NoPrior Mono M Ms [M]notifyOwnerQuit()
	*/
	protected boolean execute_node_join_ordering_2(Node act) {
		
		int m;
		SimpMultiset<Integer>  ms;
		int o;
		// Join Task: Active #H0 [O]node(M)
		if (act.is_alive()) {
			o = act.loc;
			m = act.arg1;
			// Join Task: LookupAtom #H1 7:0:hash<[+]owner()|.>  O [O]owner()
			StoreIter<Owner> candidates_1 = owner_store_0.lookup_candidates(index0Owner(o));
			Owner cand_1 = candidates_1.get_next();
			while(cand_1 != null) {
				int o1;
				o1 = cand_1.loc;
				if (true) {
					// Join Task: LookupAtom #H2 2:0:linear<[-]quit()|.>   [M]quit()
					StoreIter<Quit> candidates_2 = quit_store_0.lookup_candidates();
					Quit cand_2 = candidates_2.get_next_alive();
					while(cand_2 != null) {
						int m2;
						m2 = cand_2.loc;
						if (true) {
							// Join Task: LookupAll #H3 4:0:hash<[+]node(-)|.>  O [O]node(M)
							StoreIter<Node> candidates_3 = node_store_0.lookup_candidates(index0Node(o));
							// Join Task: CompreDomain #H3 M Ms [O]node(M)
							ms = new SimpMultiset<Integer> ();
							Node cand_3_0 = candidates_3.get_next_alive();
							while(cand_3_0 != null) {
								o = cand_3_0.loc;
								m = cand_3_0.arg1;
								ms.add( m );
								cand_3_0 = candidates_3.get_next_alive();
							}
							candidates_3.init_iter();
							// Join Task: DeleteHead #H2
							quit_store_0.remove( cand_2 );
							// Join Task: IntroCompre Remote NoPrior Mono M Ms [M]notifyOwnerQuit()
							SimpMultiset<Integer>  comp_0 = ms;
							for(int idx=0; idx<comp_0.size(); idx++) {
								m = comp_0.get(idx);
								send( new NotifyOwnerQuit(m) ); 
							}
							quitO_rule_count++;
						}
						cand_2 = candidates_2.get_next_alive();
					}
				}
				cand_1 = candidates_1.get_next();
			}
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule remove ****
	Rule Head Variables: Ns, M, O
	Rule Head Compre Binders: N
	Active #H0 [O]node(N)
	LookupAtom #H1 12:0:hash<[+]remove(-)|.>  O [O]remove(M)
	LookupAll #H2 4:0:hash<[+]node(-)|.>  O [O]node(N)
	CompreDomain #H2 N Ns [O]node(N)
	DeleteHead #H1
	DeleteHead #H2
	LetBind Ms diff((Ns,{M}))
	IntroCompre Remote NoPrior NonMono N Ms [O]node(N)
	IntroCompre Remote NoPrior Mono N Ms [M]notifyNodeRemoved(N)
	*/
	protected boolean execute_node_join_ordering_3(Node act) {
		
		SimpMultiset<Integer>  ns;
		int m;
		SimpMultiset<Integer>  ms;
		int o;
		int n;
		// Join Task: Active #H0 [O]node(N)
		if (act.is_alive()) {
			o = act.loc;
			n = act.arg1;
			// Join Task: LookupAtom #H1 12:0:hash<[+]remove(-)|.>  O [O]remove(M)
			StoreIter<Remove> candidates_1 = remove_store_0.lookup_candidates(index0Remove(o));
			Remove cand_1 = candidates_1.get_next_alive();
			while(cand_1 != null) {
				int o1;
				o1 = cand_1.loc;
				m = cand_1.arg1;
				if (true) {
					// Join Task: LookupAll #H2 4:0:hash<[+]node(-)|.>  O [O]node(N)
					StoreIter<Node> candidates_2 = node_store_0.lookup_candidates(index0Node(o));
					// Join Task: CompreDomain #H2 N Ns [O]node(N)
					ns = new SimpMultiset<Integer> ();
					Node cand_2_0 = candidates_2.get_next_alive();
					while(cand_2_0 != null) {
						o = cand_2_0.loc;
						n = cand_2_0.arg1;
						ns.add( n );
						cand_2_0 = candidates_2.get_next_alive();
					}
					candidates_2.init_iter();
					// Join Task: DeleteHead #H1
					remove_store_0.remove( cand_1 );
					// Join Task: DeleteHead #H2
					Node cand_2_1 = candidates_2.get_next_alive();
					while(cand_2_1 != null) {
						node_store_0.remove( cand_2_1 );
						cand_2_1 = candidates_2.get_next_alive();
					}
					// Join Task: LetBind Ms diff((Ns,{M}))
					Integer[] temp0 = { m };
					ms = ExtLib.diff(ns,Misc.to_mset(temp0));
					;
					// Join Task: IntroCompre Remote NoPrior NonMono N Ms [O]node(N)
					SimpMultiset<Integer>  comp_0 = ms;
					for(int idx=0; idx<comp_0.size(); idx++) {
						n = comp_0.get(idx);
						intro( new Node(o,n) );
					}
					// Join Task: IntroCompre Remote NoPrior Mono N Ms [M]notifyNodeRemoved(N)
					SimpMultiset<Integer>  comp_1 = ms;
					for(int idx=0; idx<comp_1.size(); idx++) {
						n = comp_1.get(idx);
						send( new NotifyNodeRemoved(m,n) ); 
					}
					remove_rule_count++;
					return false;
				}
				cand_1 = candidates_1.get_next_alive();
			}
		}
		return true;
	}
	
	/*
	**** 5 Join Ordering of Rule join ****
	Rule Head Variables: C, Name, LocN, O, Mac, Ls, Ms
	Rule Head Compre Binders: M, L
	Active #H0 [O]seen(M)
	LookupAtom #H1 7:0:hash<[+]owner()|.>  O [O]owner()
	LookupAtom #H2 11:0:hash<[+]nextLoc(-)|.>  O [O]nextLoc(LocN)
	LookupAtom #H3 10:0:hash<[+]reqCode(-)|.>  O [O]reqCode(C)
	LookupAtom #H4 9:0:hash<[+]joinRequest(+,-,-)|.>  O,C [O]joinRequest(C,Name,Mac)
	LookupAll #H5 5:0:hash<[+]seen(-)|.>  O [O]seen(M)
	CompreDomain #H5 M Ms [O]seen(M)
	CheckGuard not(Mac in Ms)
	LookupAll #H6 4:0:hash<[+]node(-)|.>  O [O]node(L)
	CompreDomain #H6 L Ls [O]node(L)
	DeleteHead #H2
	DeleteHead #H4
	LetBind LocU next(LocN)
	LetBind Inet lookupIP(Mac)
	IntroAtom Remote NoPrior Mono [LocN]notifyNodeAdded(LocN,Inet,Name,Mac)
	IntroAtom Remote NoPrior Mono [LocN]notifyLocAssign(LocN)
	IntroAtom Remote NoPrior Mono [O]nextLoc(LocU)
	IntroAtom Remote NoPrior NonMono [O]node(LocN)
	IntroAtom Remote NoPrior NonMono [O]seen(Mac)
	IntroCompre Remote NoPrior Mono L Ls [L]notifyNodeAdded(LocN,Inet,Name,Mac)
	*/
	protected boolean execute_seen_join_ordering_1(Seen act) {
		
		String c;
		String name;
		String m;
		int locn;
		int l;
		int o;
		String mac;
		SimpMultiset<Integer>  ls;
		SimpMultiset<String>  ms;
		int locu;
		String inet;
		// Join Task: Active #H0 [O]seen(M)
		if (act.is_alive()) {
			o = act.loc;
			m = act.arg1;
			// Join Task: LookupAtom #H1 7:0:hash<[+]owner()|.>  O [O]owner()
			StoreIter<Owner> candidates_1 = owner_store_0.lookup_candidates(index0Owner(o));
			Owner cand_1 = candidates_1.get_next();
			while(cand_1 != null) {
				int o1;
				o1 = cand_1.loc;
				if (true) {
					// Join Task: LookupAtom #H2 11:0:hash<[+]nextLoc(-)|.>  O [O]nextLoc(LocN)
					StoreIter<NextLoc> candidates_2 = nextloc_store_0.lookup_candidates(index0NextLoc(o));
					NextLoc cand_2 = candidates_2.get_next_alive();
					while(cand_2 != null) {
						int o2;
						o2 = cand_2.loc;
						locn = cand_2.arg1;
						if (true) {
							// Join Task: LookupAtom #H3 10:0:hash<[+]reqCode(-)|.>  O [O]reqCode(C)
							StoreIter<ReqCode> candidates_3 = reqcode_store_0.lookup_candidates(index0ReqCode(o));
							ReqCode cand_3 = candidates_3.get_next();
							while(cand_3 != null) {
								int o3;
								o3 = cand_3.loc;
								c = cand_3.arg1;
								if (true) {
									// Join Task: LookupAtom #H4 9:0:hash<[+]joinRequest(+,-,-)|.>  O,C [O]joinRequest(C,Name,Mac)
									StoreIter<JoinRequest> candidates_4 = joinrequest_store_0.lookup_candidates(index0JoinRequest(o,c));
									JoinRequest cand_4 = candidates_4.get_next_alive();
									while(cand_4 != null) {
										int o4;
										String c4;
										o4 = cand_4.loc;
										c4 = cand_4.arg1;
										name = cand_4.arg2;
										mac = cand_4.arg3;
										if (Equality.is_eq(o,o4) && Equality.is_eq(c,c4)) {
											// Join Task: LookupAll #H5 5:0:hash<[+]seen(-)|.>  O [O]seen(M)
											StoreIter<Seen> candidates_5 = seen_store_0.lookup_candidates(index0Seen(o));
											// Join Task: CompreDomain #H5 M Ms [O]seen(M)
											ms = new SimpMultiset<String> ();
											Seen cand_5_0 = candidates_5.get_next();
											while(cand_5_0 != null) {
												o = cand_5_0.loc;
												m = cand_5_0.arg1;
												ms.add( m );
												cand_5_0 = candidates_5.get_next();
											}
											candidates_5.init_iter();
											// Join Task: CheckGuard not(Mac in Ms)
											if (ExtLib.not(ExtLib.in(mac,ms))) {
												// Join Task: LookupAll #H6 4:0:hash<[+]node(-)|.>  O [O]node(L)
												StoreIter<Node> candidates_6 = node_store_0.lookup_candidates(index0Node(o));
												// Join Task: CompreDomain #H6 L Ls [O]node(L)
												ls = new SimpMultiset<Integer> ();
												Node cand_6_0 = candidates_6.get_next_alive();
												while(cand_6_0 != null) {
													o = cand_6_0.loc;
													l = cand_6_0.arg1;
													ls.add( l );
													cand_6_0 = candidates_6.get_next_alive();
												}
												candidates_6.init_iter();
												// Join Task: DeleteHead #H2
												nextloc_store_0.remove( cand_2 );
												// Join Task: DeleteHead #H4
												joinrequest_store_0.remove( cand_4 );
												// Join Task: LetBind LocU next(LocN)
												locu = WifiDirectComingleDirectory.next(locn);
												;
												// Join Task: LetBind Inet lookupIP(Mac)
												inet = WifiDirectComingleDirectory.lookupIP(mac);
												;
												// Join Task: IntroAtom Remote NoPrior Mono [LocN]notifyNodeAdded(LocN,Inet,Name,Mac)
												send( new NotifyNodeAdded(locn,locn,inet,name,mac) ); 
												// Join Task: IntroAtom Remote NoPrior Mono [LocN]notifyLocAssign(LocN)
												send( new NotifyLocAssign(locn,locn) ); 
												// Join Task: IntroAtom Remote NoPrior Mono [O]nextLoc(LocU)
												intro( new NextLoc(o,locu) );
												// Join Task: IntroAtom Remote NoPrior NonMono [O]node(LocN)
												intro( new Node(o,locn) );
												// Join Task: IntroAtom Remote NoPrior NonMono [O]seen(Mac)
												intro( new Seen(o,mac) );
												// Join Task: IntroCompre Remote NoPrior Mono L Ls [L]notifyNodeAdded(LocN,Inet,Name,Mac)
												SimpMultiset<Integer>  comp_0 = ls;
												for(int idx=0; idx<comp_0.size(); idx++) {
													l = comp_0.get(idx);
													send( new NotifyNodeAdded(l,locn,inet,name,mac) ); 
												}
												join_rule_count++;
											}
										} else {
										}
										cand_4 = candidates_4.get_next_alive();
									}
								}
								cand_3 = candidates_3.get_next();
							}
						}
						cand_2 = candidates_2.get_next_alive();
					}
				}
				cand_1 = candidates_1.get_next();
			}
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule connect ****
	Rule Head Variables: MacM, NameM, M, C, O
	Rule Head Compre Binders: 
	Active #H0 [M]member()
	LookupAtom #H1 8:0:hash<[+]ownerAt(-)|.>  M [M]ownerAt(O)
	LookupAtom #H2 10:0:hash<[+]reqCode(-)|.>  M [M]reqCode(C)
	LookupAtom #H3 3:0:hash<[+]connect(-,-)|.>  M [M]connect(NameM,MacM)
	DeleteHead #H3
	IntroAtom Remote NoPrior Mono [O]joinRequest(C,NameM,MacM)
	*/
	protected boolean execute_member_join_ordering_1(Member act) {
		
		String macm;
		String namem;
		int m;
		String c;
		int o;
		// Join Task: Active #H0 [M]member()
		m = act.loc;
		// Join Task: LookupAtom #H1 8:0:hash<[+]ownerAt(-)|.>  M [M]ownerAt(O)
		StoreIter<OwnerAt> candidates_1 = ownerat_store_0.lookup_candidates(index0OwnerAt(m));
		OwnerAt cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int m1;
			m1 = cand_1.loc;
			o = cand_1.arg1;
			if (true) {
				// Join Task: LookupAtom #H2 10:0:hash<[+]reqCode(-)|.>  M [M]reqCode(C)
				StoreIter<ReqCode> candidates_2 = reqcode_store_0.lookup_candidates(index0ReqCode(m));
				ReqCode cand_2 = candidates_2.get_next();
				while(cand_2 != null) {
					int m2;
					m2 = cand_2.loc;
					c = cand_2.arg1;
					if (true) {
						// Join Task: LookupAtom #H3 3:0:hash<[+]connect(-,-)|.>  M [M]connect(NameM,MacM)
						StoreIter<Connect> candidates_3 = connect_store_0.lookup_candidates(index0Connect(m));
						Connect cand_3 = candidates_3.get_next_alive();
						while(cand_3 != null) {
							int m3;
							m3 = cand_3.loc;
							namem = cand_3.arg1;
							macm = cand_3.arg2;
							if (true) {
								// Join Task: DeleteHead #H3
								connect_store_0.remove( cand_3 );
								// Join Task: IntroAtom Remote NoPrior Mono [O]joinRequest(C,NameM,MacM)
								send( new JoinRequest(o,c,namem,macm) ); 
								connect_rule_count++;
							}
							cand_3 = candidates_3.get_next_alive();
						}
					}
					cand_2 = candidates_2.get_next();
				}
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule quitM ****
	Rule Head Variables: M, O
	Rule Head Compre Binders: 
	Active #H0 [M]member()
	LookupAtom #H1 2:1:hash<[+]quit()|.>  M [M]quit()
	LookupAtom #H2 8:0:hash<[+]ownerAt(-)|.>  M [M]ownerAt(O)
	DeleteHead #H1
	IntroAtom Remote NoPrior Mono [O]remove(M)
	*/
	protected boolean execute_member_join_ordering_2(Member act) {
		
		int m;
		int o;
		// Join Task: Active #H0 [M]member()
		m = act.loc;
		// Join Task: LookupAtom #H1 2:1:hash<[+]quit()|.>  M [M]quit()
		StoreIter<Quit> candidates_1 = quit_store_1.lookup_candidates(index1Quit(m));
		Quit cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int m1;
			m1 = cand_1.loc;
			if (true) {
				// Join Task: LookupAtom #H2 8:0:hash<[+]ownerAt(-)|.>  M [M]ownerAt(O)
				StoreIter<OwnerAt> candidates_2 = ownerat_store_0.lookup_candidates(index0OwnerAt(m));
				OwnerAt cand_2 = candidates_2.get_next();
				while(cand_2 != null) {
					int m2;
					m2 = cand_2.loc;
					o = cand_2.arg1;
					if (true) {
						// Join Task: DeleteHead #H1
						quit_store_0.remove( cand_1 );
						// Join Task: IntroAtom Remote NoPrior Mono [O]remove(M)
						send( new Remove(o,m) ); 
						quitM_rule_count++;
					}
					cand_2 = candidates_2.get_next();
				}
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 2 Join Ordering of Rule join ****
	Rule Head Variables: C, Name, LocN, O, Mac, Ls, Ms
	Rule Head Compre Binders: M, L
	Active #H0 [O]owner()
	LookupAtom #H1 11:0:hash<[+]nextLoc(-)|.>  O [O]nextLoc(LocN)
	LookupAtom #H2 10:0:hash<[+]reqCode(-)|.>  O [O]reqCode(C)
	LookupAtom #H3 9:0:hash<[+]joinRequest(+,-,-)|.>  O,C [O]joinRequest(C,Name,Mac)
	LookupAll #H4 4:0:hash<[+]node(-)|.>  O [O]node(L)
	CompreDomain #H4 L Ls [O]node(L)
	LookupAll #H5 5:0:hash<[+]seen(-)|.>  O [O]seen(M)
	CompreDomain #H5 M Ms [O]seen(M)
	CheckGuard not(Mac in Ms)
	DeleteHead #H1
	DeleteHead #H3
	LetBind LocU next(LocN)
	LetBind Inet lookupIP(Mac)
	IntroAtom Remote NoPrior Mono [LocN]notifyNodeAdded(LocN,Inet,Name,Mac)
	IntroAtom Remote NoPrior Mono [LocN]notifyLocAssign(LocN)
	IntroAtom Remote NoPrior Mono [O]nextLoc(LocU)
	IntroAtom Remote NoPrior NonMono [O]node(LocN)
	IntroAtom Remote NoPrior NonMono [O]seen(Mac)
	IntroCompre Remote NoPrior Mono L Ls [L]notifyNodeAdded(LocN,Inet,Name,Mac)
	*/
	protected boolean execute_owner_join_ordering_1(Owner act) {
		
		String c;
		String name;
		String m;
		int locn;
		int l;
		int o;
		String mac;
		SimpMultiset<Integer>  ls;
		SimpMultiset<String>  ms;
		int locu;
		String inet;
		// Join Task: Active #H0 [O]owner()
		o = act.loc;
		// Join Task: LookupAtom #H1 11:0:hash<[+]nextLoc(-)|.>  O [O]nextLoc(LocN)
		StoreIter<NextLoc> candidates_1 = nextloc_store_0.lookup_candidates(index0NextLoc(o));
		NextLoc cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int o1;
			o1 = cand_1.loc;
			locn = cand_1.arg1;
			if (true) {
				// Join Task: LookupAtom #H2 10:0:hash<[+]reqCode(-)|.>  O [O]reqCode(C)
				StoreIter<ReqCode> candidates_2 = reqcode_store_0.lookup_candidates(index0ReqCode(o));
				ReqCode cand_2 = candidates_2.get_next();
				while(cand_2 != null) {
					int o2;
					o2 = cand_2.loc;
					c = cand_2.arg1;
					if (true) {
						// Join Task: LookupAtom #H3 9:0:hash<[+]joinRequest(+,-,-)|.>  O,C [O]joinRequest(C,Name,Mac)
						StoreIter<JoinRequest> candidates_3 = joinrequest_store_0.lookup_candidates(index0JoinRequest(o,c));
						JoinRequest cand_3 = candidates_3.get_next_alive();
						while(cand_3 != null) {
							int o3;
							String c3;
							o3 = cand_3.loc;
							c3 = cand_3.arg1;
							name = cand_3.arg2;
							mac = cand_3.arg3;
							if (Equality.is_eq(o,o3) && Equality.is_eq(c,c3)) {
								// Join Task: LookupAll #H4 4:0:hash<[+]node(-)|.>  O [O]node(L)
								StoreIter<Node> candidates_4 = node_store_0.lookup_candidates(index0Node(o));
								// Join Task: CompreDomain #H4 L Ls [O]node(L)
								ls = new SimpMultiset<Integer> ();
								Node cand_4_0 = candidates_4.get_next_alive();
								while(cand_4_0 != null) {
									o = cand_4_0.loc;
									l = cand_4_0.arg1;
									ls.add( l );
									cand_4_0 = candidates_4.get_next_alive();
								}
								candidates_4.init_iter();
								// Join Task: LookupAll #H5 5:0:hash<[+]seen(-)|.>  O [O]seen(M)
								StoreIter<Seen> candidates_5 = seen_store_0.lookup_candidates(index0Seen(o));
								// Join Task: CompreDomain #H5 M Ms [O]seen(M)
								ms = new SimpMultiset<String> ();
								Seen cand_5_0 = candidates_5.get_next();
								while(cand_5_0 != null) {
									o = cand_5_0.loc;
									m = cand_5_0.arg1;
									ms.add( m );
									cand_5_0 = candidates_5.get_next();
								}
								candidates_5.init_iter();
								// Join Task: CheckGuard not(Mac in Ms)
								if (ExtLib.not(ExtLib.in(mac,ms))) {
									// Join Task: DeleteHead #H1
									nextloc_store_0.remove( cand_1 );
									// Join Task: DeleteHead #H3
									joinrequest_store_0.remove( cand_3 );
									// Join Task: LetBind LocU next(LocN)
									locu = WifiDirectComingleDirectory.next(locn);
									;
									// Join Task: LetBind Inet lookupIP(Mac)
									inet = WifiDirectComingleDirectory.lookupIP(mac);
									;
									// Join Task: IntroAtom Remote NoPrior Mono [LocN]notifyNodeAdded(LocN,Inet,Name,Mac)
									send( new NotifyNodeAdded(locn,locn,inet,name,mac) ); 
									// Join Task: IntroAtom Remote NoPrior Mono [LocN]notifyLocAssign(LocN)
									send( new NotifyLocAssign(locn,locn) ); 
									// Join Task: IntroAtom Remote NoPrior Mono [O]nextLoc(LocU)
									intro( new NextLoc(o,locu) );
									// Join Task: IntroAtom Remote NoPrior NonMono [O]node(LocN)
									intro( new Node(o,locn) );
									// Join Task: IntroAtom Remote NoPrior NonMono [O]seen(Mac)
									intro( new Seen(o,mac) );
									// Join Task: IntroCompre Remote NoPrior Mono L Ls [L]notifyNodeAdded(LocN,Inet,Name,Mac)
									SimpMultiset<Integer>  comp_0 = ls;
									for(int idx=0; idx<comp_0.size(); idx++) {
										l = comp_0.get(idx);
										send( new NotifyNodeAdded(l,locn,inet,name,mac) ); 
									}
									join_rule_count++;
								}
							} else {
							}
							cand_3 = candidates_3.get_next_alive();
						}
					}
					cand_2 = candidates_2.get_next();
				}
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule quitO ****
	Rule Head Variables: M, Ms, O
	Rule Head Compre Binders: M
	Active #H0 [O]owner()
	LookupAtom #H1 2:0:linear<[-]quit()|.>   [M]quit()
	LookupAll #H2 4:0:hash<[+]node(-)|.>  O [O]node(M)
	CompreDomain #H2 M Ms [O]node(M)
	DeleteHead #H1
	IntroCompre Remote NoPrior Mono M Ms [M]notifyOwnerQuit()
	*/
	protected boolean execute_owner_join_ordering_2(Owner act) {
		
		int m;
		SimpMultiset<Integer>  ms;
		int o;
		// Join Task: Active #H0 [O]owner()
		o = act.loc;
		// Join Task: LookupAtom #H1 2:0:linear<[-]quit()|.>   [M]quit()
		StoreIter<Quit> candidates_1 = quit_store_0.lookup_candidates();
		Quit cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			m = cand_1.loc;
			if (true) {
				// Join Task: LookupAll #H2 4:0:hash<[+]node(-)|.>  O [O]node(M)
				StoreIter<Node> candidates_2 = node_store_0.lookup_candidates(index0Node(o));
				// Join Task: CompreDomain #H2 M Ms [O]node(M)
				ms = new SimpMultiset<Integer> ();
				Node cand_2_0 = candidates_2.get_next_alive();
				while(cand_2_0 != null) {
					o = cand_2_0.loc;
					m = cand_2_0.arg1;
					ms.add( m );
					cand_2_0 = candidates_2.get_next_alive();
				}
				candidates_2.init_iter();
				// Join Task: DeleteHead #H1
				quit_store_0.remove( cand_1 );
				// Join Task: IntroCompre Remote NoPrior Mono M Ms [M]notifyOwnerQuit()
				SimpMultiset<Integer>  comp_0 = ms;
				for(int idx=0; idx<comp_0.size(); idx++) {
					m = comp_0.get(idx);
					send( new NotifyOwnerQuit(m) ); 
				}
				quitO_rule_count++;
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 2 Join Ordering of Rule connect ****
	Rule Head Variables: MacM, NameM, M, C, O
	Rule Head Compre Binders: 
	Active #H0 [M]ownerAt(O)
	LookupAtom #H1 6:0:hash<[+]member()|.>  M [M]member()
	LookupAtom #H2 10:0:hash<[+]reqCode(-)|.>  M [M]reqCode(C)
	LookupAtom #H3 3:0:hash<[+]connect(-,-)|.>  M [M]connect(NameM,MacM)
	DeleteHead #H3
	IntroAtom Remote NoPrior Mono [O]joinRequest(C,NameM,MacM)
	*/
	protected boolean execute_ownerat_join_ordering_1(OwnerAt act) {
		
		String macm;
		String namem;
		int m;
		String c;
		int o;
		// Join Task: Active #H0 [M]ownerAt(O)
		m = act.loc;
		o = act.arg1;
		// Join Task: LookupAtom #H1 6:0:hash<[+]member()|.>  M [M]member()
		StoreIter<Member> candidates_1 = member_store_0.lookup_candidates(index0Member(m));
		Member cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int m1;
			m1 = cand_1.loc;
			if (true) {
				// Join Task: LookupAtom #H2 10:0:hash<[+]reqCode(-)|.>  M [M]reqCode(C)
				StoreIter<ReqCode> candidates_2 = reqcode_store_0.lookup_candidates(index0ReqCode(m));
				ReqCode cand_2 = candidates_2.get_next();
				while(cand_2 != null) {
					int m2;
					m2 = cand_2.loc;
					c = cand_2.arg1;
					if (true) {
						// Join Task: LookupAtom #H3 3:0:hash<[+]connect(-,-)|.>  M [M]connect(NameM,MacM)
						StoreIter<Connect> candidates_3 = connect_store_0.lookup_candidates(index0Connect(m));
						Connect cand_3 = candidates_3.get_next_alive();
						while(cand_3 != null) {
							int m3;
							m3 = cand_3.loc;
							namem = cand_3.arg1;
							macm = cand_3.arg2;
							if (true) {
								// Join Task: DeleteHead #H3
								connect_store_0.remove( cand_3 );
								// Join Task: IntroAtom Remote NoPrior Mono [O]joinRequest(C,NameM,MacM)
								send( new JoinRequest(o,c,namem,macm) ); 
								connect_rule_count++;
							}
							cand_3 = candidates_3.get_next_alive();
						}
					}
					cand_2 = candidates_2.get_next();
				}
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 2 Join Ordering of Rule quitM ****
	Rule Head Variables: M, O
	Rule Head Compre Binders: 
	Active #H0 [M]ownerAt(O)
	LookupAtom #H1 2:1:hash<[+]quit()|.>  M [M]quit()
	LookupAtom #H2 6:0:hash<[+]member()|.>  M [M]member()
	DeleteHead #H1
	IntroAtom Remote NoPrior Mono [O]remove(M)
	*/
	protected boolean execute_ownerat_join_ordering_2(OwnerAt act) {
		
		int m;
		int o;
		// Join Task: Active #H0 [M]ownerAt(O)
		m = act.loc;
		o = act.arg1;
		// Join Task: LookupAtom #H1 2:1:hash<[+]quit()|.>  M [M]quit()
		StoreIter<Quit> candidates_1 = quit_store_1.lookup_candidates(index1Quit(m));
		Quit cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int m1;
			m1 = cand_1.loc;
			if (true) {
				// Join Task: LookupAtom #H2 6:0:hash<[+]member()|.>  M [M]member()
				StoreIter<Member> candidates_2 = member_store_0.lookup_candidates(index0Member(m));
				Member cand_2 = candidates_2.get_next();
				while(cand_2 != null) {
					int m2;
					m2 = cand_2.loc;
					if (true) {
						// Join Task: DeleteHead #H1
						quit_store_0.remove( cand_1 );
						// Join Task: IntroAtom Remote NoPrior Mono [O]remove(M)
						send( new Remove(o,m) ); 
						quitM_rule_count++;
					}
					cand_2 = candidates_2.get_next();
				}
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule join ****
	Rule Head Variables: C, Name, LocN, O, Mac, Ls, Ms
	Rule Head Compre Binders: M, L
	Active #H0 [O]joinRequest(C,Name,Mac)
	LookupAtom #H1 10:1:hash<[+]reqCode(+)|.>  O,C [O]reqCode(C)
	LookupAtom #H2 7:0:hash<[+]owner()|.>  O [O]owner()
	LookupAtom #H3 11:0:hash<[+]nextLoc(-)|.>  O [O]nextLoc(LocN)
	LookupAll #H4 4:0:hash<[+]node(-)|.>  O [O]node(L)
	CompreDomain #H4 L Ls [O]node(L)
	LookupAll #H5 5:0:hash<[+]seen(-)|.>  O [O]seen(M)
	CompreDomain #H5 M Ms [O]seen(M)
	CheckGuard not(Mac in Ms)
	DeleteHead #H0
	DeleteHead #H3
	LetBind LocU next(LocN)
	LetBind Inet lookupIP(Mac)
	IntroAtom Remote NoPrior Mono [LocN]notifyNodeAdded(LocN,Inet,Name,Mac)
	IntroAtom Remote NoPrior Mono [LocN]notifyLocAssign(LocN)
	IntroAtom Remote NoPrior Mono [O]nextLoc(LocU)
	IntroAtom Remote NoPrior NonMono [O]node(LocN)
	IntroAtom Remote NoPrior NonMono [O]seen(Mac)
	IntroCompre Remote NoPrior Mono L Ls [L]notifyNodeAdded(LocN,Inet,Name,Mac)
	*/
	protected boolean execute_joinrequest_join_ordering_1(JoinRequest act) {
		
		String c;
		String name;
		String m;
		int locn;
		int l;
		int o;
		String mac;
		SimpMultiset<Integer>  ls;
		SimpMultiset<String>  ms;
		int locu;
		String inet;
		// Join Task: Active #H0 [O]joinRequest(C,Name,Mac)
		o = act.loc;
		c = act.arg1;
		name = act.arg2;
		mac = act.arg3;
		// Join Task: LookupAtom #H1 10:1:hash<[+]reqCode(+)|.>  O,C [O]reqCode(C)
		StoreIter<ReqCode> candidates_1 = reqcode_store_1.lookup_candidates(index1ReqCode(o,c));
		ReqCode cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int o1;
			String c1;
			o1 = cand_1.loc;
			c1 = cand_1.arg1;
			if (Equality.is_eq(o,o1) && Equality.is_eq(c,c1)) {
				// Join Task: LookupAtom #H2 7:0:hash<[+]owner()|.>  O [O]owner()
				StoreIter<Owner> candidates_2 = owner_store_0.lookup_candidates(index0Owner(o));
				Owner cand_2 = candidates_2.get_next();
				while(cand_2 != null) {
					int o2;
					o2 = cand_2.loc;
					if (true) {
						// Join Task: LookupAtom #H3 11:0:hash<[+]nextLoc(-)|.>  O [O]nextLoc(LocN)
						StoreIter<NextLoc> candidates_3 = nextloc_store_0.lookup_candidates(index0NextLoc(o));
						NextLoc cand_3 = candidates_3.get_next_alive();
						while(cand_3 != null) {
							int o3;
							o3 = cand_3.loc;
							locn = cand_3.arg1;
							if (true) {
								// Join Task: LookupAll #H4 4:0:hash<[+]node(-)|.>  O [O]node(L)
								StoreIter<Node> candidates_4 = node_store_0.lookup_candidates(index0Node(o));
								// Join Task: CompreDomain #H4 L Ls [O]node(L)
								ls = new SimpMultiset<Integer> ();
								Node cand_4_0 = candidates_4.get_next_alive();
								while(cand_4_0 != null) {
									o = cand_4_0.loc;
									l = cand_4_0.arg1;
									ls.add( l );
									cand_4_0 = candidates_4.get_next_alive();
								}
								candidates_4.init_iter();
								// Join Task: LookupAll #H5 5:0:hash<[+]seen(-)|.>  O [O]seen(M)
								StoreIter<Seen> candidates_5 = seen_store_0.lookup_candidates(index0Seen(o));
								// Join Task: CompreDomain #H5 M Ms [O]seen(M)
								ms = new SimpMultiset<String> ();
								Seen cand_5_0 = candidates_5.get_next();
								while(cand_5_0 != null) {
									o = cand_5_0.loc;
									m = cand_5_0.arg1;
									ms.add( m );
									cand_5_0 = candidates_5.get_next();
								}
								candidates_5.init_iter();
								// Join Task: CheckGuard not(Mac in Ms)
								if (ExtLib.not(ExtLib.in(mac,ms))) {
									// Join Task: DeleteHead #H0
									// H0 is active and monotone, no delete required
									// Join Task: DeleteHead #H3
									nextloc_store_0.remove( cand_3 );
									// Join Task: LetBind LocU next(LocN)
									locu = WifiDirectComingleDirectory.next(locn);
									;
									// Join Task: LetBind Inet lookupIP(Mac)
									inet = WifiDirectComingleDirectory.lookupIP(mac);
									;
									// Join Task: IntroAtom Remote NoPrior Mono [LocN]notifyNodeAdded(LocN,Inet,Name,Mac)
									send( new NotifyNodeAdded(locn,locn,inet,name,mac) ); 
									// Join Task: IntroAtom Remote NoPrior Mono [LocN]notifyLocAssign(LocN)
									send( new NotifyLocAssign(locn,locn) ); 
									// Join Task: IntroAtom Remote NoPrior Mono [O]nextLoc(LocU)
									intro( new NextLoc(o,locu) );
									// Join Task: IntroAtom Remote NoPrior NonMono [O]node(LocN)
									intro( new Node(o,locn) );
									// Join Task: IntroAtom Remote NoPrior NonMono [O]seen(Mac)
									intro( new Seen(o,mac) );
									// Join Task: IntroCompre Remote NoPrior Mono L Ls [L]notifyNodeAdded(LocN,Inet,Name,Mac)
									SimpMultiset<Integer>  comp_0 = ls;
									for(int idx=0; idx<comp_0.size(); idx++) {
										l = comp_0.get(idx);
										send( new NotifyNodeAdded(l,locn,inet,name,mac) ); 
									}
									join_rule_count++;
									return false;
								}
							}
							cand_3 = candidates_3.get_next_alive();
						}
					}
					cand_2 = candidates_2.get_next();
				}
			} else {
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 3 Join Ordering of Rule connect ****
	Rule Head Variables: MacM, NameM, M, C, O
	Rule Head Compre Binders: 
	Active #H0 [M]reqCode(C)
	LookupAtom #H1 6:0:hash<[+]member()|.>  M [M]member()
	LookupAtom #H2 8:0:hash<[+]ownerAt(-)|.>  M [M]ownerAt(O)
	LookupAtom #H3 3:0:hash<[+]connect(-,-)|.>  M [M]connect(NameM,MacM)
	DeleteHead #H3
	IntroAtom Remote NoPrior Mono [O]joinRequest(C,NameM,MacM)
	*/
	protected boolean execute_reqcode_join_ordering_1(ReqCode act) {
		
		String macm;
		String namem;
		int m;
		String c;
		int o;
		// Join Task: Active #H0 [M]reqCode(C)
		m = act.loc;
		c = act.arg1;
		// Join Task: LookupAtom #H1 6:0:hash<[+]member()|.>  M [M]member()
		StoreIter<Member> candidates_1 = member_store_0.lookup_candidates(index0Member(m));
		Member cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int m1;
			m1 = cand_1.loc;
			if (true) {
				// Join Task: LookupAtom #H2 8:0:hash<[+]ownerAt(-)|.>  M [M]ownerAt(O)
				StoreIter<OwnerAt> candidates_2 = ownerat_store_0.lookup_candidates(index0OwnerAt(m));
				OwnerAt cand_2 = candidates_2.get_next();
				while(cand_2 != null) {
					int m2;
					m2 = cand_2.loc;
					o = cand_2.arg1;
					if (true) {
						// Join Task: LookupAtom #H3 3:0:hash<[+]connect(-,-)|.>  M [M]connect(NameM,MacM)
						StoreIter<Connect> candidates_3 = connect_store_0.lookup_candidates(index0Connect(m));
						Connect cand_3 = candidates_3.get_next_alive();
						while(cand_3 != null) {
							int m3;
							m3 = cand_3.loc;
							namem = cand_3.arg1;
							macm = cand_3.arg2;
							if (true) {
								// Join Task: DeleteHead #H3
								connect_store_0.remove( cand_3 );
								// Join Task: IntroAtom Remote NoPrior Mono [O]joinRequest(C,NameM,MacM)
								send( new JoinRequest(o,c,namem,macm) ); 
								connect_rule_count++;
							}
							cand_3 = candidates_3.get_next_alive();
						}
					}
					cand_2 = candidates_2.get_next();
				}
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 3 Join Ordering of Rule join ****
	Rule Head Variables: C, Name, LocN, O, Mac, Ls, Ms
	Rule Head Compre Binders: M, L
	Active #H0 [O]reqCode(C)
	LookupAtom #H1 9:0:hash<[+]joinRequest(+,-,-)|.>  O,C [O]joinRequest(C,Name,Mac)
	LookupAtom #H2 7:0:hash<[+]owner()|.>  O [O]owner()
	LookupAtom #H3 11:0:hash<[+]nextLoc(-)|.>  O [O]nextLoc(LocN)
	LookupAll #H4 4:0:hash<[+]node(-)|.>  O [O]node(L)
	CompreDomain #H4 L Ls [O]node(L)
	LookupAll #H5 5:0:hash<[+]seen(-)|.>  O [O]seen(M)
	CompreDomain #H5 M Ms [O]seen(M)
	CheckGuard not(Mac in Ms)
	DeleteHead #H1
	DeleteHead #H3
	LetBind LocU next(LocN)
	LetBind Inet lookupIP(Mac)
	IntroAtom Remote NoPrior Mono [LocN]notifyNodeAdded(LocN,Inet,Name,Mac)
	IntroAtom Remote NoPrior Mono [LocN]notifyLocAssign(LocN)
	IntroAtom Remote NoPrior Mono [O]nextLoc(LocU)
	IntroAtom Remote NoPrior NonMono [O]node(LocN)
	IntroAtom Remote NoPrior NonMono [O]seen(Mac)
	IntroCompre Remote NoPrior Mono L Ls [L]notifyNodeAdded(LocN,Inet,Name,Mac)
	*/
	protected boolean execute_reqcode_join_ordering_2(ReqCode act) {
		
		String c;
		String name;
		String m;
		int locn;
		int l;
		int o;
		String mac;
		SimpMultiset<Integer>  ls;
		SimpMultiset<String>  ms;
		int locu;
		String inet;
		// Join Task: Active #H0 [O]reqCode(C)
		o = act.loc;
		c = act.arg1;
		// Join Task: LookupAtom #H1 9:0:hash<[+]joinRequest(+,-,-)|.>  O,C [O]joinRequest(C,Name,Mac)
		StoreIter<JoinRequest> candidates_1 = joinrequest_store_0.lookup_candidates(index0JoinRequest(o,c));
		JoinRequest cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int o1;
			String c1;
			o1 = cand_1.loc;
			c1 = cand_1.arg1;
			name = cand_1.arg2;
			mac = cand_1.arg3;
			if (Equality.is_eq(o,o1) && Equality.is_eq(c,c1)) {
				// Join Task: LookupAtom #H2 7:0:hash<[+]owner()|.>  O [O]owner()
				StoreIter<Owner> candidates_2 = owner_store_0.lookup_candidates(index0Owner(o));
				Owner cand_2 = candidates_2.get_next();
				while(cand_2 != null) {
					int o2;
					o2 = cand_2.loc;
					if (true) {
						// Join Task: LookupAtom #H3 11:0:hash<[+]nextLoc(-)|.>  O [O]nextLoc(LocN)
						StoreIter<NextLoc> candidates_3 = nextloc_store_0.lookup_candidates(index0NextLoc(o));
						NextLoc cand_3 = candidates_3.get_next_alive();
						while(cand_3 != null) {
							int o3;
							o3 = cand_3.loc;
							locn = cand_3.arg1;
							if (true) {
								// Join Task: LookupAll #H4 4:0:hash<[+]node(-)|.>  O [O]node(L)
								StoreIter<Node> candidates_4 = node_store_0.lookup_candidates(index0Node(o));
								// Join Task: CompreDomain #H4 L Ls [O]node(L)
								ls = new SimpMultiset<Integer> ();
								Node cand_4_0 = candidates_4.get_next_alive();
								while(cand_4_0 != null) {
									o = cand_4_0.loc;
									l = cand_4_0.arg1;
									ls.add( l );
									cand_4_0 = candidates_4.get_next_alive();
								}
								candidates_4.init_iter();
								// Join Task: LookupAll #H5 5:0:hash<[+]seen(-)|.>  O [O]seen(M)
								StoreIter<Seen> candidates_5 = seen_store_0.lookup_candidates(index0Seen(o));
								// Join Task: CompreDomain #H5 M Ms [O]seen(M)
								ms = new SimpMultiset<String> ();
								Seen cand_5_0 = candidates_5.get_next();
								while(cand_5_0 != null) {
									o = cand_5_0.loc;
									m = cand_5_0.arg1;
									ms.add( m );
									cand_5_0 = candidates_5.get_next();
								}
								candidates_5.init_iter();
								// Join Task: CheckGuard not(Mac in Ms)
								if (ExtLib.not(ExtLib.in(mac,ms))) {
									// Join Task: DeleteHead #H1
									joinrequest_store_0.remove( cand_1 );
									// Join Task: DeleteHead #H3
									nextloc_store_0.remove( cand_3 );
									// Join Task: LetBind LocU next(LocN)
									locu = WifiDirectComingleDirectory.next(locn);
									;
									// Join Task: LetBind Inet lookupIP(Mac)
									inet = WifiDirectComingleDirectory.lookupIP(mac);
									;
									// Join Task: IntroAtom Remote NoPrior Mono [LocN]notifyNodeAdded(LocN,Inet,Name,Mac)
									send( new NotifyNodeAdded(locn,locn,inet,name,mac) ); 
									// Join Task: IntroAtom Remote NoPrior Mono [LocN]notifyLocAssign(LocN)
									send( new NotifyLocAssign(locn,locn) ); 
									// Join Task: IntroAtom Remote NoPrior Mono [O]nextLoc(LocU)
									intro( new NextLoc(o,locu) );
									// Join Task: IntroAtom Remote NoPrior NonMono [O]node(LocN)
									intro( new Node(o,locn) );
									// Join Task: IntroAtom Remote NoPrior NonMono [O]seen(Mac)
									intro( new Seen(o,mac) );
									// Join Task: IntroCompre Remote NoPrior Mono L Ls [L]notifyNodeAdded(LocN,Inet,Name,Mac)
									SimpMultiset<Integer>  comp_0 = ls;
									for(int idx=0; idx<comp_0.size(); idx++) {
										l = comp_0.get(idx);
										send( new NotifyNodeAdded(l,locn,inet,name,mac) ); 
									}
									join_rule_count++;
								}
							}
							cand_3 = candidates_3.get_next_alive();
						}
					}
					cand_2 = candidates_2.get_next();
				}
			} else {
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule join ****
	Rule Head Variables: C, Name, LocN, O, Mac, Ls, Ms
	Rule Head Compre Binders: M, L
	Active #H0 [O]nextLoc(LocN)
	LookupAtom #H1 7:0:hash<[+]owner()|.>  O [O]owner()
	LookupAtom #H2 10:0:hash<[+]reqCode(-)|.>  O [O]reqCode(C)
	LookupAtom #H3 9:0:hash<[+]joinRequest(+,-,-)|.>  O,C [O]joinRequest(C,Name,Mac)
	LookupAll #H4 4:0:hash<[+]node(-)|.>  O [O]node(L)
	CompreDomain #H4 L Ls [O]node(L)
	LookupAll #H5 5:0:hash<[+]seen(-)|.>  O [O]seen(M)
	CompreDomain #H5 M Ms [O]seen(M)
	CheckGuard not(Mac in Ms)
	DeleteHead #H0
	DeleteHead #H3
	LetBind LocU next(LocN)
	LetBind Inet lookupIP(Mac)
	IntroAtom Remote NoPrior Mono [LocN]notifyNodeAdded(LocN,Inet,Name,Mac)
	IntroAtom Remote NoPrior Mono [LocN]notifyLocAssign(LocN)
	IntroAtom Remote NoPrior Mono [O]nextLoc(LocU)
	IntroAtom Remote NoPrior NonMono [O]node(LocN)
	IntroAtom Remote NoPrior NonMono [O]seen(Mac)
	IntroCompre Remote NoPrior Mono L Ls [L]notifyNodeAdded(LocN,Inet,Name,Mac)
	*/
	protected boolean execute_nextloc_join_ordering_1(NextLoc act) {
		
		String c;
		String name;
		String m;
		int locn;
		int l;
		int o;
		String mac;
		SimpMultiset<Integer>  ls;
		SimpMultiset<String>  ms;
		int locu;
		String inet;
		// Join Task: Active #H0 [O]nextLoc(LocN)
		o = act.loc;
		locn = act.arg1;
		// Join Task: LookupAtom #H1 7:0:hash<[+]owner()|.>  O [O]owner()
		StoreIter<Owner> candidates_1 = owner_store_0.lookup_candidates(index0Owner(o));
		Owner cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int o1;
			o1 = cand_1.loc;
			if (true) {
				// Join Task: LookupAtom #H2 10:0:hash<[+]reqCode(-)|.>  O [O]reqCode(C)
				StoreIter<ReqCode> candidates_2 = reqcode_store_0.lookup_candidates(index0ReqCode(o));
				ReqCode cand_2 = candidates_2.get_next();
				while(cand_2 != null) {
					int o2;
					o2 = cand_2.loc;
					c = cand_2.arg1;
					if (true) {
						// Join Task: LookupAtom #H3 9:0:hash<[+]joinRequest(+,-,-)|.>  O,C [O]joinRequest(C,Name,Mac)
						StoreIter<JoinRequest> candidates_3 = joinrequest_store_0.lookup_candidates(index0JoinRequest(o,c));
						JoinRequest cand_3 = candidates_3.get_next_alive();
						while(cand_3 != null) {
							int o3;
							String c3;
							o3 = cand_3.loc;
							c3 = cand_3.arg1;
							name = cand_3.arg2;
							mac = cand_3.arg3;
							if (Equality.is_eq(o,o3) && Equality.is_eq(c,c3)) {
								// Join Task: LookupAll #H4 4:0:hash<[+]node(-)|.>  O [O]node(L)
								StoreIter<Node> candidates_4 = node_store_0.lookup_candidates(index0Node(o));
								// Join Task: CompreDomain #H4 L Ls [O]node(L)
								ls = new SimpMultiset<Integer> ();
								Node cand_4_0 = candidates_4.get_next_alive();
								while(cand_4_0 != null) {
									o = cand_4_0.loc;
									l = cand_4_0.arg1;
									ls.add( l );
									cand_4_0 = candidates_4.get_next_alive();
								}
								candidates_4.init_iter();
								// Join Task: LookupAll #H5 5:0:hash<[+]seen(-)|.>  O [O]seen(M)
								StoreIter<Seen> candidates_5 = seen_store_0.lookup_candidates(index0Seen(o));
								// Join Task: CompreDomain #H5 M Ms [O]seen(M)
								ms = new SimpMultiset<String> ();
								Seen cand_5_0 = candidates_5.get_next();
								while(cand_5_0 != null) {
									o = cand_5_0.loc;
									m = cand_5_0.arg1;
									ms.add( m );
									cand_5_0 = candidates_5.get_next();
								}
								candidates_5.init_iter();
								// Join Task: CheckGuard not(Mac in Ms)
								if (ExtLib.not(ExtLib.in(mac,ms))) {
									// Join Task: DeleteHead #H0
									// H0 is active and monotone, no delete required
									// Join Task: DeleteHead #H3
									joinrequest_store_0.remove( cand_3 );
									// Join Task: LetBind LocU next(LocN)
									locu = WifiDirectComingleDirectory.next(locn);
									;
									// Join Task: LetBind Inet lookupIP(Mac)
									inet = WifiDirectComingleDirectory.lookupIP(mac);
									;
									// Join Task: IntroAtom Remote NoPrior Mono [LocN]notifyNodeAdded(LocN,Inet,Name,Mac)
									send( new NotifyNodeAdded(locn,locn,inet,name,mac) ); 
									// Join Task: IntroAtom Remote NoPrior Mono [LocN]notifyLocAssign(LocN)
									send( new NotifyLocAssign(locn,locn) ); 
									// Join Task: IntroAtom Remote NoPrior Mono [O]nextLoc(LocU)
									intro( new NextLoc(o,locu) );
									// Join Task: IntroAtom Remote NoPrior NonMono [O]node(LocN)
									intro( new Node(o,locn) );
									// Join Task: IntroAtom Remote NoPrior NonMono [O]seen(Mac)
									intro( new Seen(o,mac) );
									// Join Task: IntroCompre Remote NoPrior Mono L Ls [L]notifyNodeAdded(LocN,Inet,Name,Mac)
									SimpMultiset<Integer>  comp_0 = ls;
									for(int idx=0; idx<comp_0.size(); idx++) {
										l = comp_0.get(idx);
										send( new NotifyNodeAdded(l,locn,inet,name,mac) ); 
									}
									join_rule_count++;
									return false;
								}
							} else {
							}
							cand_3 = candidates_3.get_next_alive();
						}
					}
					cand_2 = candidates_2.get_next();
				}
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule remove ****
	Rule Head Variables: Ns, M, O
	Rule Head Compre Binders: N
	Active #H0 [O]remove(M)
	LookupAll #H1 4:0:hash<[+]node(-)|.>  O [O]node(N)
	CompreDomain #H1 N Ns [O]node(N)
	DeleteHead #H0
	DeleteHead #H1
	LetBind Ms diff((Ns,{M}))
	IntroCompre Remote NoPrior NonMono N Ms [O]node(N)
	IntroCompre Remote NoPrior Mono N Ms [M]notifyNodeRemoved(N)
	*/
	protected boolean execute_remove_join_ordering_1(Remove act) {
		
		SimpMultiset<Integer>  ns;
		int m;
		SimpMultiset<Integer>  ms;
		int o;
		int n;
		// Join Task: Active #H0 [O]remove(M)
		o = act.loc;
		m = act.arg1;
		// Join Task: LookupAll #H1 4:0:hash<[+]node(-)|.>  O [O]node(N)
		StoreIter<Node> candidates_1 = node_store_0.lookup_candidates(index0Node(o));
		// Join Task: CompreDomain #H1 N Ns [O]node(N)
		ns = new SimpMultiset<Integer> ();
		Node cand_1_0 = candidates_1.get_next_alive();
		while(cand_1_0 != null) {
			o = cand_1_0.loc;
			n = cand_1_0.arg1;
			ns.add( n );
			cand_1_0 = candidates_1.get_next_alive();
		}
		candidates_1.init_iter();
		// Join Task: DeleteHead #H0
		// H0 is active and monotone, no delete required
		// Join Task: DeleteHead #H1
		Node cand_1_1 = candidates_1.get_next_alive();
		while(cand_1_1 != null) {
			node_store_0.remove( cand_1_1 );
			cand_1_1 = candidates_1.get_next_alive();
		}
		// Join Task: LetBind Ms diff((Ns,{M}))
		Integer[] temp1 = { m };
		ms = ExtLib.diff(ns,Misc.to_mset(temp1));
		;
		// Join Task: IntroCompre Remote NoPrior NonMono N Ms [O]node(N)
		SimpMultiset<Integer>  comp_0 = ms;
		for(int idx=0; idx<comp_0.size(); idx++) {
			n = comp_0.get(idx);
			intro( new Node(o,n) );
		}
		// Join Task: IntroCompre Remote NoPrior Mono N Ms [M]notifyNodeRemoved(N)
		SimpMultiset<Integer>  comp_1 = ms;
		for(int idx=0; idx<comp_1.size(); idx++) {
			n = comp_1.get(idx);
			send( new NotifyNodeRemoved(m,n) ); 
		}
		remove_rule_count++;
		return false;
		
	}
	

	protected void execute(StartOwner startowner) {
		if( execute_startowner_join_ordering_1(startowner) ) {
			store( startowner );
		}
	}
	
	protected void execute(StartMember startmember) {
		if( execute_startmember_join_ordering_1(startmember) ) {
			store( startmember );
		}
	}
	
	protected void execute(Quit quit) {
		if( execute_quit_join_ordering_1(quit) ) {
			if( execute_quit_join_ordering_2(quit) ) {
				store( quit );
			}
		}
	}
	
	protected void execute(Connect connect) {
		if( execute_connect_join_ordering_1(connect) ) {
			store( connect );
		}
	}
	
	protected void execute(Node node) {
		execute_node_join_ordering_1( node );
		execute_node_join_ordering_2( node );
		if( execute_node_join_ordering_3(node) ) {
		}
	}
	
	protected void execute(Seen seen) {
		execute_seen_join_ordering_1( seen );
	}
	
	protected void execute(Member member) {
		execute_member_join_ordering_1( member );
		execute_member_join_ordering_2( member );
		store( member );
	}
	
	protected void execute(Owner owner) {
		execute_owner_join_ordering_1( owner );
		execute_owner_join_ordering_2( owner );
		store( owner );
	}
	
	protected void execute(OwnerAt ownerat) {
		execute_ownerat_join_ordering_1( ownerat );
		execute_ownerat_join_ordering_2( ownerat );
		store( ownerat );
	}
	
	protected void execute(JoinRequest joinrequest) {
		if( execute_joinrequest_join_ordering_1(joinrequest) ) {
			store( joinrequest );
		}
	}
	
	protected void execute(ReqCode reqcode) {
		execute_reqcode_join_ordering_1( reqcode );
		execute_reqcode_join_ordering_2( reqcode );
		store( reqcode );
	}
	
	protected void execute(NextLoc nextloc) {
		if( execute_nextloc_join_ordering_1(nextloc) ) {
			store( nextloc );
		}
	}
	
	protected void execute(Remove remove) {
		if( execute_remove_join_ordering_1(remove) ) {
			store( remove );
		}
	}
	

	@Override
	public void init() {
	}

}


