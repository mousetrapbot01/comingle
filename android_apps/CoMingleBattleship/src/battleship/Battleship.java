package battleship;

import java.io.Serializable;
import java.util.LinkedList;
import java.util.ListIterator;

import comingle.goals.*;
import comingle.store.*;
import comingle.facts.*;
import comingle.rewrite.*;
import comingle.hash.*;
import comingle.tuple.*;
import comingle.misc.*;
import comingle.mset.*;
import comingle.actuation.*;
import comingle.lib.*;

import comingle.lib.ExtLib;




/**
**  
** Generated by Comingle: Distributed Logic Programming for Decentralized Mobile Ensembles
** Visit https://github.com/sllam/comingle for more information.
** Or contact us:      
**      Edmund Lam          sllam@qatar.cmu.edu
**      Iliano Cervesato    iliano@cmu.edu
**
**/

/**
** This Comingle Runtime is generated from the following Comingle specifications:
ensem battleship {

	module comingle.lib.ExtLib import {
		union :: ({A},{A}) -> {A}.
		size  :: {A} -> int.
		makeChain :: (A,[A]) -> ({(A,A)},A).
		mset :: [A] -> {A}.
	}

	predicate initGame :: (int,int,int,[loc]) -> trigger.
	predicate fireAt   :: (loc,int,int) -> trigger.
	predicate empty     :: (int,int) -> trigger.
	predicate hull      :: (string,int,int) -> trigger.

	predicate blastAt :: (loc,int,int) -> fact.
	predicate next      :: loc -> fact.
	predicate turn      :: fact.
	predicate all       :: {loc} -> fact.
	predicate damaged   :: (string,int,int) -> fact.
	predicate checkShip :: (loc,string) -> fact.
	predicate checkFleet :: fact.
	predicate dead       :: loc -> fact.

	predicate randomFleet  :: (int,int,int) -> actuator.
	predicate notifyTurn   :: actuator.
	predicate missed       :: (loc,loc,int,int) -> actuator.
	predicate hit          :: (loc,loc,int,int) -> actuator.
	predicate sunk         :: (loc,loc,string,{(int,int)}) -> actuator.
	predicate notifyDead   :: loc -> actuator.
	predicate notifyWinner :: loc -> actuator.

	rule start :: [I]initGame(G,F,C,Ls) 
                          --o [I]turn(), [I]notifyTurn(),
			      { [A]next(B) | (A,B) <- Cs }, [E]next(I), 
                              { [L]all(Ps), [L]randomFleet(G,F,C) | L <- Ls }
                              where (Cs,E) = makeChain(I,Ls),
                                        Ps = mset(Ls).

	rule shoot :: [A]next(B) \ [A]fireAt(D,X,Y), [A]turn()
                           --o [D]blastAt(A,X,Y), [B]turn(), [B]notifyTurn().

	rule miss :: [D]empty(X,Y) \ [D]blastAt(A,X,Y) --o [D]missed(A,D,X,Y), [A]missed(A,D,X,Y).

	rule goodHit :: [D]blastAt(A,X,Y), [D]hull(S,X,Y) --o [D]damaged(S,X,Y), [D]checkShip(A,S),
                                                              [D]hit(A,D,X,Y), [A]hit(A,D,X,Y).

	rule dmgHit  :: [D]damaged(S,X,Y) \ [D]blastAt(A,X,Y) --o [D]hit(A,D,X,Y), [A]hit(A,D,X,Y).

	rule sunk1 :: [D]all(Ps), { [D]damaged(S,X,Y)|(X,Y)<-Ds } \ [D]checkShip(A,S), 
                      { [D]hull(S,W,V)|(W,V)<-Hs } | (size(Hs))==0
                          --o { [P]sunk(A,D,S,Ds) | P <- Ps }, [D]checkFleet().

	rule sunk2 :: [D]checkShip(A,S) --o 1.

	rule deadFleet1 :: [D]all(Ps), [D]checkFleet(), { [D]hull(S,X,Y)|(S,X,Y)<-Hs } | (size(Hs))==0
                           --o { [P]notifyDead(D), [P]dead(D) | P <- Ps }.

	rule deadFleet2 :: [D]checkFleet() --o 1.

	rule winner :: [D]all(Ps), { [D]dead(O) | O->Os } | Ps==(union(Os,{D})) 
                           --o { [P]notifyWinner(D) | P<-Ps }.

}
**/


public class Battleship extends RewriteMachine {

	public class Actuations {
		public static final String randomfleet = "randomfleet";
		public static final String notifyturn = "notifyturn";
		public static final String missed = "missed";
		public static final String hit = "hit";
		public static final String sunk = "sunk";
		public static final String notifydead = "notifydead";
		public static final String notifywinner = "notifywinner";
		public static final String delay = "delay";
		public static final String beep = "beep";
		public static final String toast = "toast";
	}

	abstract class BattleshipFact extends Fact {
		public BattleshipFact(int l) { super(l); }
		public void execute(Battleship ensem) { }
		public void intro(Battleship ensem) { }
	}

	public class InitGame extends BattleshipFact {
		public int arg1;
		public int arg2;
		public int arg3;
		public LinkedList<Integer>  arg4;
	
		public InitGame(int l, int a1, int a2, int a3, LinkedList<Integer>  a4) { super(l); arg1=a1; arg2=a2; arg3=a3; arg4=a4; }
	
		public int fact_idx() { return 0; }
	
		@Override
		public void execute(Battleship ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Battleship ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1, (Serializable) arg2, (Serializable) arg3, (Serializable) arg4 };
			return new SerializedFact(loc, 0, arguments);
		}
	
		public String toString() { return String.format("[%s]InitGame(%s,%s,%s,%s)",loc,arg1,arg2,arg3,arg4); }
	
	}
	
	public class FireAt extends BattleshipFact {
		public int arg1;
		public int arg2;
		public int arg3;
	
		public FireAt(int l, int a1, int a2, int a3) { super(l); arg1=a1; arg2=a2; arg3=a3; }
	
		public int fact_idx() { return 1; }
	
		@Override
		public void execute(Battleship ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Battleship ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1, (Serializable) arg2, (Serializable) arg3 };
			return new SerializedFact(loc, 1, arguments);
		}
	
		public String toString() { return String.format("[%s]FireAt(%s,%s,%s)",loc,arg1,arg2,arg3); }
	
	}
	
	public class Empty extends BattleshipFact {
		public int arg1;
		public int arg2;
	
		public Empty(int l, int a1, int a2) { super(l); arg1=a1; arg2=a2; }
	
		public int fact_idx() { return 2; }
	
		@Override
		public void execute(Battleship ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Battleship ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1, (Serializable) arg2 };
			return new SerializedFact(loc, 2, arguments);
		}
	
		public String toString() { return String.format("[%s]Empty(%s,%s)",loc,arg1,arg2); }
	
	}
	
	public class Hull extends BattleshipFact {
		public String arg1;
		public int arg2;
		public int arg3;
	
		public Hull(int l, String a1, int a2, int a3) { super(l); arg1=a1; arg2=a2; arg3=a3; }
	
		public int fact_idx() { return 3; }
	
		@Override
		public void execute(Battleship ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Battleship ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1, (Serializable) arg2, (Serializable) arg3 };
			return new SerializedFact(loc, 3, arguments);
		}
	
		public String toString() { return String.format("[%s]Hull(%s,%s,%s)",loc,arg1,arg2,arg3); }
	
	}
	
	public class BlastAt extends BattleshipFact {
		public int arg1;
		public int arg2;
		public int arg3;
	
		public BlastAt(int l, int a1, int a2, int a3) { super(l); arg1=a1; arg2=a2; arg3=a3; }
	
		public int fact_idx() { return 4; }
	
		@Override
		public void execute(Battleship ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Battleship ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1, (Serializable) arg2, (Serializable) arg3 };
			return new SerializedFact(loc, 4, arguments);
		}
	
		public String toString() { return String.format("[%s]BlastAt(%s,%s,%s)",loc,arg1,arg2,arg3); }
	
	}
	
	public class Next extends BattleshipFact {
		public int arg1;
	
		public Next(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 5; }
	
		@Override
		public void execute(Battleship ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Battleship ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 5, arguments);
		}
	
		public String toString() { return String.format("[%s]Next(%s)",loc,arg1); }
	
	}
	
	public class Turn extends BattleshipFact {
		
	
		public Turn(int l) { super(l); }
	
		public int fact_idx() { return 6; }
	
		@Override
		public void execute(Battleship ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Battleship ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = {  };
			return new SerializedFact(loc, 6, arguments);
		}
	
		public String toString() { return String.format("[%s]Turn()",loc); }
	
	}
	
	public class All extends BattleshipFact {
		public SimpMultiset<Integer>  arg1;
	
		public All(int l, SimpMultiset<Integer>  a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 7; }
	
		@Override
		public void execute(Battleship ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Battleship ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 7, arguments);
		}
	
		public String toString() { return String.format("[%s]All(%s)",loc,arg1); }
	
	}
	
	public class Damaged extends BattleshipFact {
		public String arg1;
		public int arg2;
		public int arg3;
	
		public Damaged(int l, String a1, int a2, int a3) { super(l); arg1=a1; arg2=a2; arg3=a3; }
	
		public int fact_idx() { return 8; }
	
		@Override
		public void execute(Battleship ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Battleship ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1, (Serializable) arg2, (Serializable) arg3 };
			return new SerializedFact(loc, 8, arguments);
		}
	
		public String toString() { return String.format("[%s]Damaged(%s,%s,%s)",loc,arg1,arg2,arg3); }
	
	}
	
	public class CheckShip extends BattleshipFact {
		public int arg1;
		public String arg2;
	
		public CheckShip(int l, int a1, String a2) { super(l); arg1=a1; arg2=a2; }
	
		public int fact_idx() { return 9; }
	
		@Override
		public void execute(Battleship ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Battleship ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1, (Serializable) arg2 };
			return new SerializedFact(loc, 9, arguments);
		}
	
		public String toString() { return String.format("[%s]CheckShip(%s,%s)",loc,arg1,arg2); }
	
	}
	
	public class CheckFleet extends BattleshipFact {
		
	
		public CheckFleet(int l) { super(l); }
	
		public int fact_idx() { return 10; }
	
		@Override
		public void execute(Battleship ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Battleship ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = {  };
			return new SerializedFact(loc, 10, arguments);
		}
	
		public String toString() { return String.format("[%s]CheckFleet()",loc); }
	
	}
	
	public class Dead extends BattleshipFact {
		public int arg1;
	
		public Dead(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 11; }
	
		@Override
		public void execute(Battleship ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Battleship ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 11, arguments);
		}
	
		public String toString() { return String.format("[%s]Dead(%s)",loc,arg1); }
	
	}
	
	public class RandomFleet extends BattleshipFact {
		public int arg1;
		public int arg2;
		public int arg3;
	
		public RandomFleet(int l, int a1, int a2, int a3) { super(l); arg1=a1; arg2=a2; arg3=a3; }
	
		public int fact_idx() { return 12; }
	
		@Override
		public void execute(Battleship ensem) { ensem.invokeActuator("randomfleet",Tuples.make_tuple(arg1,arg2,arg3)); }
	
		@Override
		public void intro(Battleship ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1, (Serializable) arg2, (Serializable) arg3 };
			return new SerializedFact(loc, 12, arguments);
		}
	
		public String toString() { return String.format("[%s]RandomFleet(%s,%s,%s)",loc,arg1,arg2,arg3); }
	
	}
	
	public class NotifyTurn extends BattleshipFact {
		
	
		public NotifyTurn(int l) { super(l); }
	
		public int fact_idx() { return 13; }
	
		@Override
		public void execute(Battleship ensem) { ensem.invokeActuator("notifyturn",Tuples.make_unit()); }
	
		@Override
		public void intro(Battleship ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = {  };
			return new SerializedFact(loc, 13, arguments);
		}
	
		public String toString() { return String.format("[%s]NotifyTurn()",loc); }
	
	}
	
	public class Missed extends BattleshipFact {
		public int arg1;
		public int arg2;
		public int arg3;
		public int arg4;
	
		public Missed(int l, int a1, int a2, int a3, int a4) { super(l); arg1=a1; arg2=a2; arg3=a3; arg4=a4; }
	
		public int fact_idx() { return 14; }
	
		@Override
		public void execute(Battleship ensem) { ensem.invokeActuator("missed",Tuples.make_tuple(arg1,arg2,arg3,arg4)); }
	
		@Override
		public void intro(Battleship ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1, (Serializable) arg2, (Serializable) arg3, (Serializable) arg4 };
			return new SerializedFact(loc, 14, arguments);
		}
	
		public String toString() { return String.format("[%s]Missed(%s,%s,%s,%s)",loc,arg1,arg2,arg3,arg4); }
	
	}
	
	public class Hit extends BattleshipFact {
		public int arg1;
		public int arg2;
		public int arg3;
		public int arg4;
	
		public Hit(int l, int a1, int a2, int a3, int a4) { super(l); arg1=a1; arg2=a2; arg3=a3; arg4=a4; }
	
		public int fact_idx() { return 15; }
	
		@Override
		public void execute(Battleship ensem) { ensem.invokeActuator("hit",Tuples.make_tuple(arg1,arg2,arg3,arg4)); }
	
		@Override
		public void intro(Battleship ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1, (Serializable) arg2, (Serializable) arg3, (Serializable) arg4 };
			return new SerializedFact(loc, 15, arguments);
		}
	
		public String toString() { return String.format("[%s]Hit(%s,%s,%s,%s)",loc,arg1,arg2,arg3,arg4); }
	
	}
	
	public class Sunk extends BattleshipFact {
		public int arg1;
		public int arg2;
		public String arg3;
		public SimpMultiset<Tuple2<Integer,Integer> >  arg4;
	
		public Sunk(int l, int a1, int a2, String a3, SimpMultiset<Tuple2<Integer,Integer> >  a4) { super(l); arg1=a1; arg2=a2; arg3=a3; arg4=a4; }
	
		public int fact_idx() { return 16; }
	
		@Override
		public void execute(Battleship ensem) { ensem.invokeActuator("sunk",Tuples.make_tuple(arg1,arg2,arg3,arg4)); }
	
		@Override
		public void intro(Battleship ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1, (Serializable) arg2, (Serializable) arg3, (Serializable) arg4 };
			return new SerializedFact(loc, 16, arguments);
		}
	
		public String toString() { return String.format("[%s]Sunk(%s,%s,%s,%s)",loc,arg1,arg2,arg3,arg4); }
	
	}
	
	public class NotifyDead extends BattleshipFact {
		public int arg1;
	
		public NotifyDead(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 17; }
	
		@Override
		public void execute(Battleship ensem) { ensem.invokeActuator("notifydead",arg1); }
	
		@Override
		public void intro(Battleship ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 17, arguments);
		}
	
		public String toString() { return String.format("[%s]NotifyDead(%s)",loc,arg1); }
	
	}
	
	public class NotifyWinner extends BattleshipFact {
		public int arg1;
	
		public NotifyWinner(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 18; }
	
		@Override
		public void execute(Battleship ensem) { ensem.invokeActuator("notifywinner",arg1); }
	
		@Override
		public void intro(Battleship ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 18, arguments);
		}
	
		public String toString() { return String.format("[%s]NotifyWinner(%s)",loc,arg1); }
	
	}
	
	public class Delay extends BattleshipFact {
		public int arg1;
	
		public Delay(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 19; }
	
		@Override
		public void execute(Battleship ensem) { ensem.invokeActuator("delay",arg1); }
	
		@Override
		public void intro(Battleship ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 19, arguments);
		}
	
		public String toString() { return String.format("[%s]Delay(%s)",loc,arg1); }
	
	}
	
	public class Beep extends BattleshipFact {
		public String arg1;
	
		public Beep(int l, String a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 20; }
	
		@Override
		public void execute(Battleship ensem) { ensem.invokeActuator("beep",arg1); }
	
		@Override
		public void intro(Battleship ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 20, arguments);
		}
	
		public String toString() { return String.format("[%s]Beep(%s)",loc,arg1); }
	
	}
	
	public class Toast extends BattleshipFact {
		public String arg1;
	
		public Toast(int l, String a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 21; }
	
		@Override
		public void execute(Battleship ensem) { ensem.invokeActuator("toast",arg1); }
	
		@Override
		public void intro(Battleship ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 21, arguments);
		}
	
		public String toString() { return String.format("[%s]Toast(%s)",loc,arg1); }
	
	}
	

	protected static int index0FireAt(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0Empty(int loc, int arg1, int arg2) {
		return Hash.join(Hash.hash(loc),Hash.hash(arg1),Hash.hash(arg2));
	}
	protected static int index0Hull(int loc, int arg2, int arg3) {
		return Hash.join(Hash.hash(loc),Hash.hash(arg2),Hash.hash(arg3));
	}
	protected static int index1Hull(int loc, String arg1) {
		return Hash.join(Hash.hash(loc),Hash.hash(arg1));
	}
	protected static int index2Hull(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0BlastAt(int loc, int arg2, int arg3) {
		return Hash.join(Hash.hash(loc),Hash.hash(arg2),Hash.hash(arg3));
	}
	protected static int index0Next(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0Turn(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0All(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0Damaged(int loc, int arg2, int arg3) {
		return Hash.join(Hash.hash(loc),Hash.hash(arg2),Hash.hash(arg3));
	}
	protected static int index1Damaged(int loc, String arg1) {
		return Hash.join(Hash.hash(loc),Hash.hash(arg1));
	}
	protected static int index0CheckShip(int loc) {
		return Hash.hash(loc);
	}
	protected static int index1CheckShip(int loc, String arg2) {
		return Hash.join(Hash.hash(loc),Hash.hash(arg2));
	}
	protected static int index0CheckFleet(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0Dead(int loc) {
		return Hash.hash(loc);
	}

	protected static final int initgame_fact_idx = 0;
	protected static final int fireat_fact_idx = 1;
	protected static final int empty_fact_idx = 2;
	protected static final int hull_fact_idx = 3;
	protected static final int blastat_fact_idx = 4;
	protected static final int next_fact_idx = 5;
	protected static final int turn_fact_idx = 6;
	protected static final int all_fact_idx = 7;
	protected static final int damaged_fact_idx = 8;
	protected static final int checkship_fact_idx = 9;
	protected static final int checkfleet_fact_idx = 10;
	protected static final int dead_fact_idx = 11;
	protected static final int randomfleet_fact_idx = 12;
	protected static final int notifyturn_fact_idx = 13;
	protected static final int missed_fact_idx = 14;
	protected static final int hit_fact_idx = 15;
	protected static final int sunk_fact_idx = 16;
	protected static final int notifydead_fact_idx = 17;
	protected static final int notifywinner_fact_idx = 18;
	protected static final int delay_fact_idx = 19;
	protected static final int beep_fact_idx = 20;
	protected static final int toast_fact_idx = 21;

	protected Goals<BattleshipFact> goals;

	protected ListStore<InitGame> initgame_store_0;
	protected MultiMapStore<FireAt> fireat_store_0;
	protected ListStore<FireAt> fireat_store_1;
	protected MultiMapStore<Empty> empty_store_0;
	protected ListStore<Empty> empty_store_1;
	protected MultiMapStore<Hull> hull_store_0;
	protected MultiMapStore<Hull> hull_store_1;
	protected MultiMapStore<Hull> hull_store_2;
	protected ListStore<Hull> hull_store_3;
	protected MultiMapStore<BlastAt> blastat_store_0;
	protected ListStore<BlastAt> blastat_store_1;
	protected MultiMapStore<Next> next_store_0;
	protected ListStore<Next> next_store_1;
	protected MultiMapStore<Turn> turn_store_0;
	protected ListStore<Turn> turn_store_1;
	protected MultiMapStore<All> all_store_0;
	protected ListStore<All> all_store_1;
	protected MultiMapStore<Damaged> damaged_store_0;
	protected MultiMapStore<Damaged> damaged_store_1;
	protected ListStore<Damaged> damaged_store_2;
	protected MultiMapStore<CheckShip> checkship_store_0;
	protected MultiMapStore<CheckShip> checkship_store_1;
	protected ListStore<CheckShip> checkship_store_2;
	protected MultiMapStore<CheckFleet> checkfleet_store_0;
	protected ListStore<CheckFleet> checkfleet_store_1;
	protected MultiMapStore<Dead> dead_store_0;
	protected ListStore<Dead> dead_store_1;

	protected int start_rule_count;
	protected int shoot_rule_count;
	protected int miss_rule_count;
	protected int goodHit_rule_count;
	protected int dmgHit_rule_count;
	protected int sunk1_rule_count;
	protected int sunk2_rule_count;
	protected int deadFleet1_rule_count;
	protected int deadFleet2_rule_count;
	protected int winner_rule_count;
	protected int rule_app_misses;

	public Battleship() {
		super();
	
		start_rule_count = 0;
		shoot_rule_count = 0;
		miss_rule_count = 0;
		goodHit_rule_count = 0;
		dmgHit_rule_count = 0;
		sunk1_rule_count = 0;
		sunk2_rule_count = 0;
		deadFleet1_rule_count = 0;
		deadFleet2_rule_count = 0;
		winner_rule_count = 0;
		rule_app_misses = 0;
	
		goals = new ListGoals<BattleshipFact>();
		set_goal_component( goals );
	
		initgame_store_0 = new ListStore<InitGame>();
		initgame_store_0.set_name("InitGame Store");
		// set_store_component( initgame_store_0 );
		
		fireat_store_0 = new MultiMapStore<FireAt>();
		fireat_store_0.set_name("FireAt Store");
		// set_store_component( fireat_store_0 );
		
		fireat_store_1 = new ListStore<FireAt>();
		fireat_store_1.set_name("FireAt Store");
		// set_store_component( fireat_store_1 );
		
		empty_store_0 = new MultiMapStore<Empty>();
		empty_store_0.set_name("Empty Store");
		// set_store_component( empty_store_0 );
		
		empty_store_1 = new ListStore<Empty>();
		empty_store_1.set_name("Empty Store");
		// set_store_component( empty_store_1 );
		
		hull_store_0 = new MultiMapStore<Hull>();
		hull_store_0.set_name("Hull Store");
		// set_store_component( hull_store_0 );
		
		hull_store_1 = new MultiMapStore<Hull>();
		hull_store_1.set_name("Hull Store");
		// set_store_component( hull_store_1 );
		
		hull_store_2 = new MultiMapStore<Hull>();
		hull_store_2.set_name("Hull Store");
		// set_store_component( hull_store_2 );
		
		hull_store_3 = new ListStore<Hull>();
		hull_store_3.set_name("Hull Store");
		// set_store_component( hull_store_3 );
		
		blastat_store_0 = new MultiMapStore<BlastAt>();
		blastat_store_0.set_name("BlastAt Store");
		// set_store_component( blastat_store_0 );
		
		blastat_store_1 = new ListStore<BlastAt>();
		blastat_store_1.set_name("BlastAt Store");
		// set_store_component( blastat_store_1 );
		
		next_store_0 = new MultiMapStore<Next>();
		next_store_0.set_name("Next Store");
		// set_store_component( next_store_0 );
		
		next_store_1 = new ListStore<Next>();
		next_store_1.set_name("Next Store");
		// set_store_component( next_store_1 );
		
		turn_store_0 = new MultiMapStore<Turn>();
		turn_store_0.set_name("Turn Store");
		// set_store_component( turn_store_0 );
		
		turn_store_1 = new ListStore<Turn>();
		turn_store_1.set_name("Turn Store");
		// set_store_component( turn_store_1 );
		
		all_store_0 = new MultiMapStore<All>();
		all_store_0.set_name("All Store");
		// set_store_component( all_store_0 );
		
		all_store_1 = new ListStore<All>();
		all_store_1.set_name("All Store");
		// set_store_component( all_store_1 );
		
		damaged_store_0 = new MultiMapStore<Damaged>();
		damaged_store_0.set_name("Damaged Store");
		// set_store_component( damaged_store_0 );
		
		damaged_store_1 = new MultiMapStore<Damaged>();
		damaged_store_1.set_name("Damaged Store");
		// set_store_component( damaged_store_1 );
		
		damaged_store_2 = new ListStore<Damaged>();
		damaged_store_2.set_name("Damaged Store");
		// set_store_component( damaged_store_2 );
		
		checkship_store_0 = new MultiMapStore<CheckShip>();
		checkship_store_0.set_name("CheckShip Store");
		// set_store_component( checkship_store_0 );
		
		checkship_store_1 = new MultiMapStore<CheckShip>();
		checkship_store_1.set_name("CheckShip Store");
		// set_store_component( checkship_store_1 );
		
		checkship_store_2 = new ListStore<CheckShip>();
		checkship_store_2.set_name("CheckShip Store");
		// set_store_component( checkship_store_2 );
		
		checkfleet_store_0 = new MultiMapStore<CheckFleet>();
		checkfleet_store_0.set_name("CheckFleet Store");
		// set_store_component( checkfleet_store_0 );
		
		checkfleet_store_1 = new ListStore<CheckFleet>();
		checkfleet_store_1.set_name("CheckFleet Store");
		// set_store_component( checkfleet_store_1 );
		
		dead_store_0 = new MultiMapStore<Dead>();
		dead_store_0.set_name("Dead Store");
		// set_store_component( dead_store_0 );
		
		dead_store_1 = new ListStore<Dead>();
		dead_store_1.set_name("Dead Store");
		// set_store_component( dead_store_1 );
		
	
		set_store_component( initgame_store_0 );
		set_store_component( fireat_store_1 );
		set_store_component( empty_store_1 );
		set_store_component( hull_store_3 );
		set_store_component( blastat_store_1 );
		set_store_component( next_store_1 );
		set_store_component( turn_store_1 );
		set_store_component( all_store_1 );
		set_store_component( damaged_store_2 );
		set_store_component( checkship_store_2 );
		set_store_component( checkfleet_store_1 );
		set_store_component( dead_store_1 );
	}
	

	@Override
	protected boolean rewrite() {
		boolean done_something = false;
		while(goals.has_goals()) {
			goals.next().execute( this );
			done_something = true;
		}
		return done_something;
	}
	
	@Override
	protected boolean rewrite(int max_steps) {
		int count = 0;
		while(goals.has_goals() && count < max_steps) {
			goals.next().execute( this );
			count++;
		}
		return count > 0;
	}

	protected BattleshipFact demultiplex(SerializedFact fact) {
		Serializable[] args = fact.arguments;
		switch(fact.fact_idx) {
			case 0: return new InitGame(fact.loc,(Integer) args[0],(Integer) args[1],(Integer) args[2],(LinkedList<Integer> ) args[3]);
			
			case 1: return new FireAt(fact.loc,(Integer) args[0],(Integer) args[1],(Integer) args[2]);
			
			case 2: return new Empty(fact.loc,(Integer) args[0],(Integer) args[1]);
			
			case 3: return new Hull(fact.loc,(String) args[0],(Integer) args[1],(Integer) args[2]);
			
			case 4: return new BlastAt(fact.loc,(Integer) args[0],(Integer) args[1],(Integer) args[2]);
			
			case 5: return new Next(fact.loc,(Integer) args[0]);
			
			case 6: return new Turn(fact.loc);
			
			case 7: return new All(fact.loc,(SimpMultiset<Integer> ) args[0]);
			
			case 8: return new Damaged(fact.loc,(String) args[0],(Integer) args[1],(Integer) args[2]);
			
			case 9: return new CheckShip(fact.loc,(Integer) args[0],(String) args[1]);
			
			case 10: return new CheckFleet(fact.loc);
			
			case 11: return new Dead(fact.loc,(Integer) args[0]);
			
			case 12: return new RandomFleet(fact.loc,(Integer) args[0],(Integer) args[1],(Integer) args[2]);
			
			case 13: return new NotifyTurn(fact.loc);
			
			case 14: return new Missed(fact.loc,(Integer) args[0],(Integer) args[1],(Integer) args[2],(Integer) args[3]);
			
			case 15: return new Hit(fact.loc,(Integer) args[0],(Integer) args[1],(Integer) args[2],(Integer) args[3]);
			
			case 16: return new Sunk(fact.loc,(Integer) args[0],(Integer) args[1],(String) args[2],(SimpMultiset<Tuple2<Integer,Integer> > ) args[3]);
			
			case 17: return new NotifyDead(fact.loc,(Integer) args[0]);
			
			case 18: return new NotifyWinner(fact.loc,(Integer) args[0]);
			
			case 19: return new Delay(fact.loc,(Integer) args[0]);
			
			case 20: return new Beep(fact.loc,(String) args[0]);
			
			case 21: return new Toast(fact.loc,(String) args[0]);
			
		}
		return null;
	}
	
	
	@Override
	protected synchronized boolean flushGoals() {
		if (external_goals.size() == 0) { return false; }
		for (SerializedFact new_goal : external_goals) {
			BattleshipFact ef_goal = demultiplex( new_goal );
			ef_goal.intro( this ) ;
		}
		external_goals.clear();
		return true;
	}
	
	protected void store(InitGame initgame) {
		initgame_store_0.add( initgame );
	} 				
	
	protected void store(FireAt fireat) {
		fireat_store_0.add( fireat, index0FireAt(fireat.loc) );
		fireat_store_1.add( fireat );
	} 				
	
	protected void store(Empty empty) {
		empty_store_0.add( empty, index0Empty(empty.loc,empty.arg1,empty.arg2) );
		empty_store_1.add( empty );
	} 				
	
	protected void store(Hull hull) {
		hull_store_0.add( hull, index0Hull(hull.loc,hull.arg2,hull.arg3) );
		hull_store_1.add( hull, index1Hull(hull.loc,hull.arg1) );
		hull_store_2.add( hull, index2Hull(hull.loc) );
		hull_store_3.add( hull );
	} 				
	
	protected void store(BlastAt blastat) {
		blastat_store_0.add( blastat, index0BlastAt(blastat.loc,blastat.arg2,blastat.arg3) );
		blastat_store_1.add( blastat );
	} 				
	
	protected void store(Next next) {
		next_store_0.add( next, index0Next(next.loc) );
		next_store_1.add( next );
	} 				
	
	protected void store(Turn turn) {
		turn_store_0.add( turn, index0Turn(turn.loc) );
		turn_store_1.add( turn );
	} 				
	
	protected void store(All all) {
		all_store_0.add( all, index0All(all.loc) );
		all_store_1.add( all );
	} 				
	
	protected void store(Damaged damaged) {
		damaged_store_0.add( damaged, index0Damaged(damaged.loc,damaged.arg2,damaged.arg3) );
		damaged_store_1.add( damaged, index1Damaged(damaged.loc,damaged.arg1) );
		damaged_store_2.add( damaged );
	} 				
	
	protected void store(CheckShip checkship) {
		checkship_store_0.add( checkship, index0CheckShip(checkship.loc) );
		checkship_store_1.add( checkship, index1CheckShip(checkship.loc,checkship.arg2) );
		checkship_store_2.add( checkship );
	} 				
	
	protected void store(CheckFleet checkfleet) {
		checkfleet_store_0.add( checkfleet, index0CheckFleet(checkfleet.loc) );
		checkfleet_store_1.add( checkfleet );
	} 				
	
	protected void store(Dead dead) {
		dead_store_0.add( dead, index0Dead(dead.loc) );
		dead_store_1.add( dead );
	} 				
	
	protected void store(RandomFleet randomfleet) {
		
	} 				
	
	protected void store(NotifyTurn notifyturn) {
		
	} 				
	
	protected void store(Missed missed) {
		
	} 				
	
	protected void store(Hit hit) {
		
	} 				
	
	protected void store(Sunk sunk) {
		
	} 				
	
	protected void store(NotifyDead notifydead) {
		
	} 				
	
	protected void store(NotifyWinner notifywinner) {
		
	} 				
	
	protected void store(Delay delay) {
		
	} 				
	
	protected void store(Beep beep) {
		
	} 				
	
	protected void store(Toast toast) {
		
	} 				
	
	public void add_initgame(int loc,int arg1,int arg2,int arg3,LinkedList<Integer>  arg4) {
		if (isSolo || location == loc) {
			intro( new InitGame(loc,arg1,arg2,arg3,arg4) );
		}
	}
	
	public void add_fireat(int loc,int arg1,int arg2,int arg3) {
		if (isSolo || location == loc) {
			intro( new FireAt(loc,arg1,arg2,arg3) );
		}
	}
	
	public void add_empty(int loc,int arg1,int arg2) {
		if (isSolo || location == loc) {
			intro( new Empty(loc,arg1,arg2) );
		}
	}
	
	public void add_hull(int loc,String arg1,int arg2,int arg3) {
		if (isSolo || location == loc) {
			intro( new Hull(loc,arg1,arg2,arg3) );
		}
	}
	
	public void add_blastat(int loc,int arg1,int arg2,int arg3) {
		if (isSolo || location == loc) {
			intro( new BlastAt(loc,arg1,arg2,arg3) );
		}
	}
	
	public void add_next(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new Next(loc,arg1) );
		}
	}
	
	public void add_turn(int loc) {
		if (isSolo || location == loc) {
			intro( new Turn(loc) );
		}
	}
	
	public void add_all(int loc,SimpMultiset<Integer>  arg1) {
		if (isSolo || location == loc) {
			intro( new All(loc,arg1) );
		}
	}
	
	public void add_damaged(int loc,String arg1,int arg2,int arg3) {
		if (isSolo || location == loc) {
			intro( new Damaged(loc,arg1,arg2,arg3) );
		}
	}
	
	public void add_checkship(int loc,int arg1,String arg2) {
		if (isSolo || location == loc) {
			intro( new CheckShip(loc,arg1,arg2) );
		}
	}
	
	public void add_checkfleet(int loc) {
		if (isSolo || location == loc) {
			intro( new CheckFleet(loc) );
		}
	}
	
	public void add_dead(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new Dead(loc,arg1) );
		}
	}
	
	public void add_randomfleet(int loc,int arg1,int arg2,int arg3) {
		if (isSolo || location == loc) {
			intro( new RandomFleet(loc,arg1,arg2,arg3) );
		}
	}
	
	public void add_notifyturn(int loc) {
		if (isSolo || location == loc) {
			intro( new NotifyTurn(loc) );
		}
	}
	
	public void add_missed(int loc,int arg1,int arg2,int arg3,int arg4) {
		if (isSolo || location == loc) {
			intro( new Missed(loc,arg1,arg2,arg3,arg4) );
		}
	}
	
	public void add_hit(int loc,int arg1,int arg2,int arg3,int arg4) {
		if (isSolo || location == loc) {
			intro( new Hit(loc,arg1,arg2,arg3,arg4) );
		}
	}
	
	public void add_sunk(int loc,int arg1,int arg2,String arg3,SimpMultiset<Tuple2<Integer,Integer> >  arg4) {
		if (isSolo || location == loc) {
			intro( new Sunk(loc,arg1,arg2,arg3,arg4) );
		}
	}
	
	public void add_notifydead(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new NotifyDead(loc,arg1) );
		}
	}
	
	public void add_notifywinner(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new NotifyWinner(loc,arg1) );
		}
	}
	
	public void add_delay(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new Delay(loc,arg1) );
		}
	}
	
	public void add_beep(int loc,String arg1) {
		if (isSolo || location == loc) {
			intro( new Beep(loc,arg1) );
		}
	}
	
	public void add_toast(int loc,String arg1) {
		if (isSolo || location == loc) {
			intro( new Toast(loc,arg1) );
		}
	}
	
	protected void intro(InitGame initgame) {
		goals.add( initgame );
		notify_new_goals();
	}
	
	protected void intro(FireAt fireat) {
		goals.add( fireat );
		notify_new_goals();
	}
	
	protected void intro(Empty empty) {
		goals.add( empty );
		notify_new_goals();
	}
	
	protected void intro(Hull hull) {
		goals.add( hull );
		store( hull );
		notify_new_goals();
	}	
	
	protected void intro(BlastAt blastat) {
		goals.add( blastat );
		notify_new_goals();
	}
	
	protected void intro(Next next) {
		goals.add( next );
		notify_new_goals();
	}
	
	protected void intro(Turn turn) {
		goals.add( turn );
		notify_new_goals();
	}
	
	protected void intro(All all) {
		goals.add( all );
		notify_new_goals();
	}
	
	protected void intro(Damaged damaged) {
		goals.add( damaged );
		store( damaged );
		notify_new_goals();
	}	
	
	protected void intro(CheckShip checkship) {
		goals.add( checkship );
		notify_new_goals();
	}
	
	protected void intro(CheckFleet checkfleet) {
		goals.add( checkfleet );
		notify_new_goals();
	}
	
	protected void intro(Dead dead) {
		goals.add( dead );
		store( dead );
		notify_new_goals();
	}	
	
	protected void intro(RandomFleet randomfleet) {
		goals.add( randomfleet );
		notify_new_goals();
	}
	
	protected void intro(NotifyTurn notifyturn) {
		goals.add( notifyturn );
		notify_new_goals();
	}
	
	protected void intro(Missed missed) {
		goals.add( missed );
		notify_new_goals();
	}
	
	protected void intro(Hit hit) {
		goals.add( hit );
		notify_new_goals();
	}
	
	protected void intro(Sunk sunk) {
		goals.add( sunk );
		notify_new_goals();
	}
	
	protected void intro(NotifyDead notifydead) {
		goals.add( notifydead );
		notify_new_goals();
	}
	
	protected void intro(NotifyWinner notifywinner) {
		goals.add( notifywinner );
		notify_new_goals();
	}
	
	protected void intro(Delay delay) {
		goals.add( delay );
		store( delay );
		notify_new_goals();
	}	
	
	protected void intro(Beep beep) {
		goals.add( beep );
		store( beep );
		notify_new_goals();
	}	
	
	protected void intro(Toast toast) {
		goals.add( toast );
		store( toast );
		notify_new_goals();
	}	
	
	protected void send(InitGame initgame) {
		if(location == initgame.get_loc()) {
			intro(initgame);
		} else {
			send_buffers.add(initgame);
		}
	}
	
	protected void send(FireAt fireat) {
		if(location == fireat.get_loc()) {
			intro(fireat);
		} else {
			send_buffers.add(fireat);
		}
	}
	
	protected void send(Empty empty) {
		if(location == empty.get_loc()) {
			intro(empty);
		} else {
			send_buffers.add(empty);
		}
	}
	
	protected void send(Hull hull) {
		if(location == hull.get_loc()) {
			intro(hull);
		} else {
			send_buffers.add(hull);
		}
	}
	
	protected void send(BlastAt blastat) {
		if(location == blastat.get_loc()) {
			intro(blastat);
		} else {
			send_buffers.add(blastat);
		}
	}
	
	protected void send(Next next) {
		if(location == next.get_loc()) {
			intro(next);
		} else {
			send_buffers.add(next);
		}
	}
	
	protected void send(Turn turn) {
		if(location == turn.get_loc()) {
			intro(turn);
		} else {
			send_buffers.add(turn);
		}
	}
	
	protected void send(All all) {
		if(location == all.get_loc()) {
			intro(all);
		} else {
			send_buffers.add(all);
		}
	}
	
	protected void send(Damaged damaged) {
		if(location == damaged.get_loc()) {
			intro(damaged);
		} else {
			send_buffers.add(damaged);
		}
	}
	
	protected void send(CheckShip checkship) {
		if(location == checkship.get_loc()) {
			intro(checkship);
		} else {
			send_buffers.add(checkship);
		}
	}
	
	protected void send(CheckFleet checkfleet) {
		if(location == checkfleet.get_loc()) {
			intro(checkfleet);
		} else {
			send_buffers.add(checkfleet);
		}
	}
	
	protected void send(Dead dead) {
		if(location == dead.get_loc()) {
			intro(dead);
		} else {
			send_buffers.add(dead);
		}
	}
	
	protected void send(RandomFleet randomfleet) {
		if(location == randomfleet.get_loc()) {
			intro(randomfleet);
		} else {
			send_buffers.add(randomfleet);
		}
	}
	
	protected void send(NotifyTurn notifyturn) {
		if(location == notifyturn.get_loc()) {
			intro(notifyturn);
		} else {
			send_buffers.add(notifyturn);
		}
	}
	
	protected void send(Missed missed) {
		if(location == missed.get_loc()) {
			intro(missed);
		} else {
			send_buffers.add(missed);
		}
	}
	
	protected void send(Hit hit) {
		if(location == hit.get_loc()) {
			intro(hit);
		} else {
			send_buffers.add(hit);
		}
	}
	
	protected void send(Sunk sunk) {
		if(location == sunk.get_loc()) {
			intro(sunk);
		} else {
			send_buffers.add(sunk);
		}
	}
	
	protected void send(NotifyDead notifydead) {
		if(location == notifydead.get_loc()) {
			intro(notifydead);
		} else {
			send_buffers.add(notifydead);
		}
	}
	
	protected void send(NotifyWinner notifywinner) {
		if(location == notifywinner.get_loc()) {
			intro(notifywinner);
		} else {
			send_buffers.add(notifywinner);
		}
	}
	
	protected void send(Delay delay) {
		if(location == delay.get_loc()) {
			intro(delay);
		} else {
			send_buffers.add(delay);
		}
	}
	
	protected void send(Beep beep) {
		if(location == beep.get_loc()) {
			intro(beep);
		} else {
			send_buffers.add(beep);
		}
	}
	
	protected void send(Toast toast) {
		if(location == toast.get_loc()) {
			intro(toast);
		} else {
			send_buffers.add(toast);
		}
	}
	
	

	public void addInitGame(int arg1,int arg2,int arg3,LinkedList<Integer>  arg4) {
		intro( new InitGame(location,arg1,arg2,arg3,arg4) );
	}
	
	public void addFireAt(int arg1,int arg2,int arg3) {
		intro( new FireAt(location,arg1,arg2,arg3) );
	}
	
	public void addEmpty(int arg1,int arg2) {
		intro( new Empty(location,arg1,arg2) );
	}
	
	public void addHull(String arg1,int arg2,int arg3) {
		intro( new Hull(location,arg1,arg2,arg3) );
	}
	

	public void setRandomFleetActuator(ActuatorAction<Tuple3<Integer,Integer,Integer>> action) {
		setActuator("randomfleet", action);
	}
	
	public void setNotifyTurnActuator(ActuatorAction<Unit> action) {
		setActuator("notifyturn", action);
	}
	
	public void setMissedActuator(ActuatorAction<Tuple4<Integer,Integer,Integer,Integer>> action) {
		setActuator("missed", action);
	}
	
	public void setHitActuator(ActuatorAction<Tuple4<Integer,Integer,Integer,Integer>> action) {
		setActuator("hit", action);
	}
	
	public void setSunkActuator(ActuatorAction<Tuple4<Integer,Integer,String,SimpMultiset<Tuple2<Integer,Integer> > >> action) {
		setActuator("sunk", action);
	}
	
	public void setNotifyDeadActuator(ActuatorAction<Integer> action) {
		setActuator("notifydead", action);
	}
	
	public void setNotifyWinnerActuator(ActuatorAction<Integer> action) {
		setActuator("notifywinner", action);
	}
	
	public void setDelayActuator(ActuatorAction<Integer> action) {
		setActuator("delay", action);
	}
	
	public void setBeepActuator(ActuatorAction<String> action) {
		setActuator("beep", action);
	}
	
	public void setToastActuator(ActuatorAction<String> action) {
		setActuator("toast", action);
	}
	

	

	public ConcListStore[] getLinearStores() {
		ConcListStore[] stores = new ConcListStore[0];
		
		return stores;
	}
	

	/*
	**** 0 Join Ordering of Rule start ****
	Rule Head Variables: (I::0), (G::1), (F::2), (C::3), (Ls::4)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]initGame((G::1),(F::2),(C::3),(Ls::4))
	DeleteHead #H0
	LetBind ((Cs::5),(E::6)) makeChain(((I::0),(Ls::4)))
	LetBind (Ps::7) mset((Ls::4))
	IntroAtom Local NoPrior Mono [(I::0)]turn()
	IntroAtom Local NoPrior Mono [(I::0)]notifyTurn()
	IntroAtom Remote NoPrior Mono [(E::6)]next((I::0))
	IntroCompre Remote NoPrior Mono (A::8),(B::9) (Cs::5) [(A::8)]next((B::9))
	IntroCompre Remote NoPrior Mono (L::10) (Ls::4) [(L::10)]all((Ps::7))
	*/
	protected boolean execute_initgame_join_ordering_1(InitGame act) {
		
		int i;
		int g;
		int f;
		int c;
		LinkedList<Integer>  ls;
		SimpMultiset<Tuple2<Integer,Integer> >  cs;
		int e;
		SimpMultiset<Integer>  ps;
		int a;
		int b;
		int l;
		// Join Task: Active #H0 [(I::0)]initGame((G::1),(F::2),(C::3),(Ls::4))
		i = act.loc;
		g = act.arg1;
		f = act.arg2;
		c = act.arg3;
		ls = act.arg4;
		// Join Task: DeleteHead #H0
		// H0 is active and monotone, no delete required
		// Join Task: LetBind ((Cs::5),(E::6)) makeChain(((I::0),(Ls::4)))
		Tuple2<SimpMultiset<Tuple2<Integer,Integer> > ,Integer>  tup0;
		tup0 = ExtLib.makeChain(i,ls);
		cs = tup0.t1;
		e = tup0.t2;
		;
		// Join Task: LetBind (Ps::7) mset((Ls::4))
		ps = ExtLib.mset(ls);
		;
		// Join Task: IntroAtom Local NoPrior Mono [(I::0)]turn()
		intro( new Turn(i) );
		// Join Task: IntroAtom Local NoPrior Mono [(I::0)]notifyTurn()
		intro( new NotifyTurn(i) );
		// Join Task: IntroAtom Remote NoPrior Mono [(E::6)]next((I::0))
		send( new Next(e,i) ); 
		// Join Task: IntroCompre Remote NoPrior Mono (A::8),(B::9) (Cs::5) [(A::8)]next((B::9))
		SimpMultiset<Tuple2<Integer,Integer> >  comp_0 = cs;
		for(int idx=0; idx<comp_0.size(); idx++) {
			Tuple2<Integer,Integer>  tup1;
			tup1 = comp_0.get(idx);
			a = tup1.t1;
			b = tup1.t2;
			send( new Next(a,b) ); 
		}
		// Join Task: IntroCompre Remote NoPrior Mono (L::10) (Ls::4) [(L::10)]all((Ps::7))
		LinkedList<Integer>  comp_1 = ls;
		for(int idx=0; idx<comp_1.size(); idx++) {
			l = comp_1.get(idx);
			send( new All(l,ps) ); 
			send( new RandomFleet(l,g,f,c) ); 
		}
		start_rule_count++;
		return false;
		
	}
	
	/*
	**** 0 Join Ordering of Rule shoot ****
	Rule Head Variables: (A::0), (B::1), (D::2), (X::3), (Y::4)
	Rule Head Compre Binders: 
	Active #H0 [(A::0)]fireAt((D::2),(X::3),(Y::4))
	LookupAtom #H1 6:0:hash<[+]turn()|.>  (A::0) [(A::0)]turn()
	LookupAtom #H2 5:0:hash<[+]next(-)|.>  (A::0) [(A::0)]next((B::1))
	DeleteHead #H0
	DeleteHead #H1
	IntroAtom Remote NoPrior Mono [(D::2)]blastAt((A::0),(X::3),(Y::4))
	IntroAtom Remote NoPrior Mono [(B::1)]turn()
	IntroAtom Remote NoPrior Mono [(B::1)]notifyTurn()
	*/
	protected boolean execute_fireat_join_ordering_1(FireAt act) {
		
		int a;
		int b;
		int d;
		int x;
		int y;
		// Join Task: Active #H0 [(A::0)]fireAt((D::2),(X::3),(Y::4))
		a = act.loc;
		d = act.arg1;
		x = act.arg2;
		y = act.arg3;
		// Join Task: LookupAtom #H1 6:0:hash<[+]turn()|.>  (A::0) [(A::0)]turn()
		StoreIter<Turn> candidates_1 = turn_store_0.lookup_candidates(index0Turn(a));
		Turn cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int a__1;
			a__1 = cand_1.loc;
			if (true) {
				// Join Task: LookupAtom #H2 5:0:hash<[+]next(-)|.>  (A::0) [(A::0)]next((B::1))
				StoreIter<Next> candidates_2 = next_store_0.lookup_candidates(index0Next(a));
				Next cand_2 = candidates_2.get_next();
				while(cand_2 != null) {
					int a__2;
					a__2 = cand_2.loc;
					b = cand_2.arg1;
					if (true) {
						// Join Task: DeleteHead #H0
						// H0 is active and monotone, no delete required
						// Join Task: DeleteHead #H1
						turn_store_0.remove( cand_1 );
						// Join Task: IntroAtom Remote NoPrior Mono [(D::2)]blastAt((A::0),(X::3),(Y::4))
						send( new BlastAt(d,a,x,y) ); 
						// Join Task: IntroAtom Remote NoPrior Mono [(B::1)]turn()
						send( new Turn(b) ); 
						// Join Task: IntroAtom Remote NoPrior Mono [(B::1)]notifyTurn()
						send( new NotifyTurn(b) ); 
						shoot_rule_count++;
						return false;
					}
					cand_2 = candidates_2.get_next();
				}
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule miss ****
	Rule Head Variables: (D::0), (X::1), (Y::2), (A::3)
	Rule Head Compre Binders: 
	Active #H0 [(D::0)]empty((X::1),(Y::2))
	LookupAtom #H1 4:0:hash<[+]blastAt(-,+,+)|.>  (D::0),(X::1),(Y::2) [(D::0)]blastAt((A::3),(X::1),(Y::2))
	DeleteHead #H1
	IntroAtom Local NoPrior Mono [(D::0)]missed((A::3),(D::0),(X::1),(Y::2))
	IntroAtom Remote NoPrior Mono [(A::3)]missed((A::3),(D::0),(X::1),(Y::2))
	*/
	protected boolean execute_empty_join_ordering_1(Empty act) {
		
		int d;
		int x;
		int y;
		int a;
		// Join Task: Active #H0 [(D::0)]empty((X::1),(Y::2))
		d = act.loc;
		x = act.arg1;
		y = act.arg2;
		// Join Task: LookupAtom #H1 4:0:hash<[+]blastAt(-,+,+)|.>  (D::0),(X::1),(Y::2) [(D::0)]blastAt((A::3),(X::1),(Y::2))
		StoreIter<BlastAt> candidates_1 = blastat_store_0.lookup_candidates(index0BlastAt(d,x,y));
		BlastAt cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int d__1;
			int x__1;
			int y__1;
			d__1 = cand_1.loc;
			a = cand_1.arg1;
			x__1 = cand_1.arg2;
			y__1 = cand_1.arg3;
			if (Equality.is_eq(d,d__1) && Equality.is_eq(x,x__1) && Equality.is_eq(y,y__1)) {
				// Join Task: DeleteHead #H1
				blastat_store_0.remove( cand_1 );
				// Join Task: IntroAtom Local NoPrior Mono [(D::0)]missed((A::3),(D::0),(X::1),(Y::2))
				intro( new Missed(d,a,d,x,y) );
				// Join Task: IntroAtom Remote NoPrior Mono [(A::3)]missed((A::3),(D::0),(X::1),(Y::2))
				send( new Missed(a,a,d,x,y) ); 
				miss_rule_count++;
			} else {
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule goodHit ****
	Rule Head Variables: (D::0), (A::1), (X::2), (Y::3), (S::4)
	Rule Head Compre Binders: 
	Active #H0 [(D::0)]hull((S::4),(X::2),(Y::3))
	LookupAtom #H1 4:0:hash<[+]blastAt(-,+,+)|.>  (D::0),(X::2),(Y::3) [(D::0)]blastAt((A::1),(X::2),(Y::3))
	DeleteHead #H0
	DeleteHead #H1
	IntroAtom Local NoPrior NonMono [(D::0)]damaged((S::4),(X::2),(Y::3))
	IntroAtom Local NoPrior Mono [(D::0)]checkShip((A::1),(S::4))
	IntroAtom Local NoPrior Mono [(D::0)]hit((A::1),(D::0),(X::2),(Y::3))
	IntroAtom Remote NoPrior Mono [(A::1)]hit((A::1),(D::0),(X::2),(Y::3))
	*/
	protected boolean execute_hull_join_ordering_1(Hull act) {
		
		int d;
		int a;
		int x;
		int y;
		String s;
		// Join Task: Active #H0 [(D::0)]hull((S::4),(X::2),(Y::3))
		if (act.is_alive()) {
			d = act.loc;
			s = act.arg1;
			x = act.arg2;
			y = act.arg3;
			// Join Task: LookupAtom #H1 4:0:hash<[+]blastAt(-,+,+)|.>  (D::0),(X::2),(Y::3) [(D::0)]blastAt((A::1),(X::2),(Y::3))
			StoreIter<BlastAt> candidates_1 = blastat_store_0.lookup_candidates(index0BlastAt(d,x,y));
			BlastAt cand_1 = candidates_1.get_next_alive();
			while(cand_1 != null) {
				int d__1;
				int x__1;
				int y__1;
				d__1 = cand_1.loc;
				a = cand_1.arg1;
				x__1 = cand_1.arg2;
				y__1 = cand_1.arg3;
				if (Equality.is_eq(d,d__1) && Equality.is_eq(x,x__1) && Equality.is_eq(y,y__1)) {
					// Join Task: DeleteHead #H0
					hull_store_0.remove( act );
					// Join Task: DeleteHead #H1
					blastat_store_0.remove( cand_1 );
					// Join Task: IntroAtom Local NoPrior NonMono [(D::0)]damaged((S::4),(X::2),(Y::3))
					intro( new Damaged(d,s,x,y) );
					// Join Task: IntroAtom Local NoPrior Mono [(D::0)]checkShip((A::1),(S::4))
					intro( new CheckShip(d,a,s) );
					// Join Task: IntroAtom Local NoPrior Mono [(D::0)]hit((A::1),(D::0),(X::2),(Y::3))
					intro( new Hit(d,a,d,x,y) );
					// Join Task: IntroAtom Remote NoPrior Mono [(A::1)]hit((A::1),(D::0),(X::2),(Y::3))
					send( new Hit(a,a,d,x,y) ); 
					goodHit_rule_count++;
					return false;
				} else {
				}
				cand_1 = candidates_1.get_next_alive();
			}
		}
		return true;
	}
	
	/*
	**** 2 Join Ordering of Rule sunk1 ****
	Rule Head Variables: (D::0), (Ps::1), (Ds::2), (S::5), (A::6), (Hs::7)
	Rule Head Compre Binders: (W::8), (V::9), (Y::3), (X::4)
	Active #H0 [(D::0)]hull((S::5),(W::8),(V::9))
	LookupAtom #H1 9:1:hash<[+]checkShip(-,+)|.>  (D::0),(S::5) [(D::0)]checkShip((A::6),(S::5))
	LookupAtom #H2 7:0:hash<[+]all(-)|.>  (D::0) [(D::0)]all((Ps::1))
	LookupAll #H3 3:1:hash<[+]hull(+,-,-)|.>  (D::0),(S::5) [(D::0)]hull((S::5),(W::8),(V::9))
	CompreDomain #H3 (W::8),(V::9) (Hs::7) [(D::0)]hull((S::5),(W::8),(V::9))
	CheckGuard size((Hs::7)) == 0
	LookupAll #H4 8:1:hash<[+]damaged(+,-,-)|.>  (D::0),(S::5) [(D::0)]damaged((S::5),(X::4),(Y::3))
	CompreDomain #H4 (X::4),(Y::3) (Ds::2) [(D::0)]damaged((S::5),(X::4),(Y::3))
	DeleteHead #H1
	DeleteHead #H3
	IntroAtom Remote NoPrior Mono [(D::0)]checkFleet()
	IntroCompre Remote NoPrior Mono (P::10) (Ps::1) [(P::10)]sunk((A::6),(D::0),(S::5),(Ds::2))
	*/
	protected boolean execute_hull_join_ordering_2(Hull act) {
		
		int d;
		SimpMultiset<Integer>  ps;
		SimpMultiset<Tuple2<Integer,Integer> >  ds;
		int y;
		int x;
		String s;
		int a;
		SimpMultiset<Tuple2<Integer,Integer> >  hs;
		int w;
		int v;
		int p;
		// Join Task: Active #H0 [(D::0)]hull((S::5),(W::8),(V::9))
		if (act.is_alive()) {
			d = act.loc;
			s = act.arg1;
			w = act.arg2;
			v = act.arg3;
			// Join Task: LookupAtom #H1 9:1:hash<[+]checkShip(-,+)|.>  (D::0),(S::5) [(D::0)]checkShip((A::6),(S::5))
			StoreIter<CheckShip> candidates_1 = checkship_store_1.lookup_candidates(index1CheckShip(d,s));
			CheckShip cand_1 = candidates_1.get_next_alive();
			while(cand_1 != null) {
				int d__1;
				String s__1;
				d__1 = cand_1.loc;
				a = cand_1.arg1;
				s__1 = cand_1.arg2;
				if (Equality.is_eq(d,d__1) && Equality.is_eq(s,s__1)) {
					// Join Task: LookupAtom #H2 7:0:hash<[+]all(-)|.>  (D::0) [(D::0)]all((Ps::1))
					StoreIter<All> candidates_2 = all_store_0.lookup_candidates(index0All(d));
					All cand_2 = candidates_2.get_next_alive();
					while(cand_2 != null) {
						int d__2;
						d__2 = cand_2.loc;
						ps = cand_2.arg1;
						if (true) {
							// Join Task: LookupAll #H3 3:1:hash<[+]hull(+,-,-)|.>  (D::0),(S::5) [(D::0)]hull((S::5),(W::8),(V::9))
							StoreIter<Hull> candidates_3 = hull_store_1.lookup_candidates(index1Hull(d,s));
							ListStoreIter<Hull> candidates_3_0 = new ListStoreIter<Hull>();
							Hull cand_3 = candidates_3.get_next_alive();
							while(cand_3 != null) {
								int d__3;
								String s__3;
								d__3 = cand_3.loc;
								s__3 = cand_3.arg1;
								w = cand_3.arg2;
								v = cand_3.arg3;
								if (Equality.is_eq(d,d__3) && Equality.is_eq(s,s__3)) {
									candidates_3_0.add( cand_3 );
								}
								cand_3 = candidates_3.get_next_alive();
							}
							candidates_3_0.init_iter();
							// Join Task: CompreDomain #H3 (W::8),(V::9) (Hs::7) [(D::0)]hull((S::5),(W::8),(V::9))
							hs = new SimpMultiset<Tuple2<Integer,Integer> > ();
							Hull cand_3_1 = candidates_3_0.get_next_alive();
							while(cand_3_1 != null) {
								d = cand_3_1.loc;
								s = cand_3_1.arg1;
								w = cand_3_1.arg2;
								v = cand_3_1.arg3;
								hs.add( Tuples.make_tuple(w,v) );
								cand_3_1 = candidates_3_0.get_next_alive();
							}
							candidates_3_0.init_iter();
							// Join Task: CheckGuard size((Hs::7)) == 0
							if (Equality.is_eq(ExtLib.size(hs),0)) {
								// Join Task: LookupAll #H4 8:1:hash<[+]damaged(+,-,-)|.>  (D::0),(S::5) [(D::0)]damaged((S::5),(X::4),(Y::3))
								StoreIter<Damaged> candidates_4 = damaged_store_1.lookup_candidates(index1Damaged(d,s));
								ListStoreIter<Damaged> candidates_4_0 = new ListStoreIter<Damaged>();
								Damaged cand_4 = candidates_4.get_next();
								while(cand_4 != null) {
									int d__4;
									String s__4;
									d__4 = cand_4.loc;
									s__4 = cand_4.arg1;
									x = cand_4.arg2;
									y = cand_4.arg3;
									if (Equality.is_eq(d,d__4) && Equality.is_eq(s,s__4)) {
										candidates_4_0.add( cand_4 );
									}
									cand_4 = candidates_4.get_next();
								}
								candidates_4_0.init_iter();
								// Join Task: CompreDomain #H4 (X::4),(Y::3) (Ds::2) [(D::0)]damaged((S::5),(X::4),(Y::3))
								ds = new SimpMultiset<Tuple2<Integer,Integer> > ();
								Damaged cand_4_1 = candidates_4_0.get_next();
								while(cand_4_1 != null) {
									d = cand_4_1.loc;
									s = cand_4_1.arg1;
									x = cand_4_1.arg2;
									y = cand_4_1.arg3;
									ds.add( Tuples.make_tuple(x,y) );
									cand_4_1 = candidates_4_0.get_next();
								}
								candidates_4_0.init_iter();
								// Join Task: DeleteHead #H1
								checkship_store_0.remove( cand_1 );
								// Join Task: DeleteHead #H3
								Hull cand_3_2 = candidates_3_0.get_next_alive();
								while(cand_3_2 != null) {
									hull_store_0.remove( cand_3_2 );
									cand_3_2 = candidates_3_0.get_next_alive();
								}
								// Join Task: IntroAtom Remote NoPrior Mono [(D::0)]checkFleet()
								intro( new CheckFleet(d) );
								// Join Task: IntroCompre Remote NoPrior Mono (P::10) (Ps::1) [(P::10)]sunk((A::6),(D::0),(S::5),(Ds::2))
								SimpMultiset<Integer>  comp_0 = ps;
								for(int idx=0; idx<comp_0.size(); idx++) {
									p = comp_0.get(idx);
									send( new Sunk(p,a,d,s,ds) ); 
								}
								sunk1_rule_count++;
								return false;
							}
						}
						cand_2 = candidates_2.get_next_alive();
					}
				} else {
				}
				cand_1 = candidates_1.get_next_alive();
			}
		}
		return true;
	}
	
	/*
	**** 2 Join Ordering of Rule deadFleet1 ****
	Rule Head Variables: (D::0), (Ps::1), (Hs::2)
	Rule Head Compre Binders: (Y::3), (X::4), (S::5)
	Active #H0 [(D::0)]hull((S::5),(X::4),(Y::3))
	LookupAtom #H1 10:0:hash<[+]checkFleet()|.>  (D::0) [(D::0)]checkFleet()
	LookupAtom #H2 7:0:hash<[+]all(-)|.>  (D::0) [(D::0)]all((Ps::1))
	LookupAll #H3 3:2:hash<[+]hull(-,-,-)|.>  (D::0) [(D::0)]hull((S::5),(X::4),(Y::3))
	CompreDomain #H3 (S::5),(X::4),(Y::3) (Hs::2) [(D::0)]hull((S::5),(X::4),(Y::3))
	CheckGuard size((Hs::2)) == 0
	DeleteHead #H1
	DeleteHead #H2
	DeleteHead #H3
	IntroCompre Remote NoPrior Mono (P::6) (Ps::1) [(P::6)]notifyDead((D::0))
	*/
	protected boolean execute_hull_join_ordering_3(Hull act) {
		
		int d;
		SimpMultiset<Integer>  ps;
		SimpMultiset<Tuple3<String,Integer,Integer> >  hs;
		int y;
		int x;
		String s;
		int p;
		// Join Task: Active #H0 [(D::0)]hull((S::5),(X::4),(Y::3))
		if (act.is_alive()) {
			d = act.loc;
			s = act.arg1;
			x = act.arg2;
			y = act.arg3;
			// Join Task: LookupAtom #H1 10:0:hash<[+]checkFleet()|.>  (D::0) [(D::0)]checkFleet()
			StoreIter<CheckFleet> candidates_1 = checkfleet_store_0.lookup_candidates(index0CheckFleet(d));
			CheckFleet cand_1 = candidates_1.get_next_alive();
			while(cand_1 != null) {
				int d__1;
				d__1 = cand_1.loc;
				if (true) {
					// Join Task: LookupAtom #H2 7:0:hash<[+]all(-)|.>  (D::0) [(D::0)]all((Ps::1))
					StoreIter<All> candidates_2 = all_store_0.lookup_candidates(index0All(d));
					All cand_2 = candidates_2.get_next_alive();
					while(cand_2 != null) {
						int d__2;
						d__2 = cand_2.loc;
						ps = cand_2.arg1;
						if (true) {
							// Join Task: LookupAll #H3 3:2:hash<[+]hull(-,-,-)|.>  (D::0) [(D::0)]hull((S::5),(X::4),(Y::3))
							StoreIter<Hull> candidates_3 = hull_store_2.lookup_candidates(index2Hull(d));
							// Join Task: CompreDomain #H3 (S::5),(X::4),(Y::3) (Hs::2) [(D::0)]hull((S::5),(X::4),(Y::3))
							hs = new SimpMultiset<Tuple3<String,Integer,Integer> > ();
							Hull cand_3_0 = candidates_3.get_next_alive();
							while(cand_3_0 != null) {
								d = cand_3_0.loc;
								s = cand_3_0.arg1;
								x = cand_3_0.arg2;
								y = cand_3_0.arg3;
								hs.add( Tuples.make_tuple(s,x,y) );
								cand_3_0 = candidates_3.get_next_alive();
							}
							candidates_3.init_iter();
							// Join Task: CheckGuard size((Hs::2)) == 0
							if (Equality.is_eq(ExtLib.size(hs),0)) {
								// Join Task: DeleteHead #H1
								checkfleet_store_0.remove( cand_1 );
								// Join Task: DeleteHead #H2
								all_store_0.remove( cand_2 );
								// Join Task: DeleteHead #H3
								Hull cand_3_1 = candidates_3.get_next_alive();
								while(cand_3_1 != null) {
									hull_store_0.remove( cand_3_1 );
									cand_3_1 = candidates_3.get_next_alive();
								}
								// Join Task: IntroCompre Remote NoPrior Mono (P::6) (Ps::1) [(P::6)]notifyDead((D::0))
								SimpMultiset<Integer>  comp_0 = ps;
								for(int idx=0; idx<comp_0.size(); idx++) {
									p = comp_0.get(idx);
									send( new NotifyDead(p,d) ); 
									send( new Dead(p,d) ); 
								}
								deadFleet1_rule_count++;
								return false;
							}
						}
						cand_2 = candidates_2.get_next_alive();
					}
				}
				cand_1 = candidates_1.get_next_alive();
			}
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule miss ****
	Rule Head Variables: (D::0), (X::1), (Y::2), (A::3)
	Rule Head Compre Binders: 
	Active #H0 [(D::0)]blastAt((A::3),(X::1),(Y::2))
	LookupAtom #H1 2:0:hash<[+]empty(+,+)|.>  (D::0),(X::1),(Y::2) [(D::0)]empty((X::1),(Y::2))
	DeleteHead #H0
	IntroAtom Local NoPrior Mono [(D::0)]missed((A::3),(D::0),(X::1),(Y::2))
	IntroAtom Remote NoPrior Mono [(A::3)]missed((A::3),(D::0),(X::1),(Y::2))
	*/
	protected boolean execute_blastat_join_ordering_1(BlastAt act) {
		
		int d;
		int x;
		int y;
		int a;
		// Join Task: Active #H0 [(D::0)]blastAt((A::3),(X::1),(Y::2))
		d = act.loc;
		a = act.arg1;
		x = act.arg2;
		y = act.arg3;
		// Join Task: LookupAtom #H1 2:0:hash<[+]empty(+,+)|.>  (D::0),(X::1),(Y::2) [(D::0)]empty((X::1),(Y::2))
		StoreIter<Empty> candidates_1 = empty_store_0.lookup_candidates(index0Empty(d,x,y));
		Empty cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int d__1;
			int x__1;
			int y__1;
			d__1 = cand_1.loc;
			x__1 = cand_1.arg1;
			y__1 = cand_1.arg2;
			if (Equality.is_eq(d,d__1) && Equality.is_eq(x,x__1) && Equality.is_eq(y,y__1)) {
				// Join Task: DeleteHead #H0
				// H0 is active and monotone, no delete required
				// Join Task: IntroAtom Local NoPrior Mono [(D::0)]missed((A::3),(D::0),(X::1),(Y::2))
				intro( new Missed(d,a,d,x,y) );
				// Join Task: IntroAtom Remote NoPrior Mono [(A::3)]missed((A::3),(D::0),(X::1),(Y::2))
				send( new Missed(a,a,d,x,y) ); 
				miss_rule_count++;
				return false;
			} else {
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule goodHit ****
	Rule Head Variables: (D::0), (A::1), (X::2), (Y::3), (S::4)
	Rule Head Compre Binders: 
	Active #H0 [(D::0)]blastAt((A::1),(X::2),(Y::3))
	LookupAtom #H1 3:0:hash<[+]hull(-,+,+)|.>  (D::0),(X::2),(Y::3) [(D::0)]hull((S::4),(X::2),(Y::3))
	DeleteHead #H0
	DeleteHead #H1
	IntroAtom Local NoPrior NonMono [(D::0)]damaged((S::4),(X::2),(Y::3))
	IntroAtom Local NoPrior Mono [(D::0)]checkShip((A::1),(S::4))
	IntroAtom Local NoPrior Mono [(D::0)]hit((A::1),(D::0),(X::2),(Y::3))
	IntroAtom Remote NoPrior Mono [(A::1)]hit((A::1),(D::0),(X::2),(Y::3))
	*/
	protected boolean execute_blastat_join_ordering_2(BlastAt act) {
		
		int d;
		int a;
		int x;
		int y;
		String s;
		// Join Task: Active #H0 [(D::0)]blastAt((A::1),(X::2),(Y::3))
		d = act.loc;
		a = act.arg1;
		x = act.arg2;
		y = act.arg3;
		// Join Task: LookupAtom #H1 3:0:hash<[+]hull(-,+,+)|.>  (D::0),(X::2),(Y::3) [(D::0)]hull((S::4),(X::2),(Y::3))
		StoreIter<Hull> candidates_1 = hull_store_0.lookup_candidates(index0Hull(d,x,y));
		Hull cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int d__1;
			int x__1;
			int y__1;
			d__1 = cand_1.loc;
			s = cand_1.arg1;
			x__1 = cand_1.arg2;
			y__1 = cand_1.arg3;
			if (Equality.is_eq(d,d__1) && Equality.is_eq(x,x__1) && Equality.is_eq(y,y__1)) {
				// Join Task: DeleteHead #H0
				// H0 is active and monotone, no delete required
				// Join Task: DeleteHead #H1
				hull_store_0.remove( cand_1 );
				// Join Task: IntroAtom Local NoPrior NonMono [(D::0)]damaged((S::4),(X::2),(Y::3))
				intro( new Damaged(d,s,x,y) );
				// Join Task: IntroAtom Local NoPrior Mono [(D::0)]checkShip((A::1),(S::4))
				intro( new CheckShip(d,a,s) );
				// Join Task: IntroAtom Local NoPrior Mono [(D::0)]hit((A::1),(D::0),(X::2),(Y::3))
				intro( new Hit(d,a,d,x,y) );
				// Join Task: IntroAtom Remote NoPrior Mono [(A::1)]hit((A::1),(D::0),(X::2),(Y::3))
				send( new Hit(a,a,d,x,y) ); 
				goodHit_rule_count++;
				return false;
			} else {
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule dmgHit ****
	Rule Head Variables: (D::0), (S::1), (X::2), (Y::3), (A::4)
	Rule Head Compre Binders: 
	Active #H0 [(D::0)]blastAt((A::4),(X::2),(Y::3))
	LookupAtom #H1 8:0:hash<[+]damaged(-,+,+)|.>  (D::0),(X::2),(Y::3) [(D::0)]damaged((S::1),(X::2),(Y::3))
	DeleteHead #H0
	IntroAtom Local NoPrior Mono [(D::0)]hit((A::4),(D::0),(X::2),(Y::3))
	IntroAtom Remote NoPrior Mono [(A::4)]hit((A::4),(D::0),(X::2),(Y::3))
	*/
	protected boolean execute_blastat_join_ordering_3(BlastAt act) {
		
		int d;
		String s;
		int x;
		int y;
		int a;
		// Join Task: Active #H0 [(D::0)]blastAt((A::4),(X::2),(Y::3))
		d = act.loc;
		a = act.arg1;
		x = act.arg2;
		y = act.arg3;
		// Join Task: LookupAtom #H1 8:0:hash<[+]damaged(-,+,+)|.>  (D::0),(X::2),(Y::3) [(D::0)]damaged((S::1),(X::2),(Y::3))
		StoreIter<Damaged> candidates_1 = damaged_store_0.lookup_candidates(index0Damaged(d,x,y));
		Damaged cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int d__1;
			int x__1;
			int y__1;
			d__1 = cand_1.loc;
			s = cand_1.arg1;
			x__1 = cand_1.arg2;
			y__1 = cand_1.arg3;
			if (Equality.is_eq(d,d__1) && Equality.is_eq(x,x__1) && Equality.is_eq(y,y__1)) {
				// Join Task: DeleteHead #H0
				// H0 is active and monotone, no delete required
				// Join Task: IntroAtom Local NoPrior Mono [(D::0)]hit((A::4),(D::0),(X::2),(Y::3))
				intro( new Hit(d,a,d,x,y) );
				// Join Task: IntroAtom Remote NoPrior Mono [(A::4)]hit((A::4),(D::0),(X::2),(Y::3))
				send( new Hit(a,a,d,x,y) ); 
				dmgHit_rule_count++;
				return false;
			} else {
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 2 Join Ordering of Rule shoot ****
	Rule Head Variables: (A::0), (B::1), (D::2), (X::3), (Y::4)
	Rule Head Compre Binders: 
	Active #H0 [(A::0)]next((B::1))
	LookupAtom #H1 6:0:hash<[+]turn()|.>  (A::0) [(A::0)]turn()
	LookupAtom #H2 1:0:hash<[+]fireAt(-,-,-)|.>  (A::0) [(A::0)]fireAt((D::2),(X::3),(Y::4))
	DeleteHead #H1
	DeleteHead #H2
	IntroAtom Remote NoPrior Mono [(D::2)]blastAt((A::0),(X::3),(Y::4))
	IntroAtom Remote NoPrior Mono [(B::1)]turn()
	IntroAtom Remote NoPrior Mono [(B::1)]notifyTurn()
	*/
	protected boolean execute_next_join_ordering_1(Next act) {
		
		int a;
		int b;
		int d;
		int x;
		int y;
		// Join Task: Active #H0 [(A::0)]next((B::1))
		a = act.loc;
		b = act.arg1;
		// Join Task: LookupAtom #H1 6:0:hash<[+]turn()|.>  (A::0) [(A::0)]turn()
		StoreIter<Turn> candidates_1 = turn_store_0.lookup_candidates(index0Turn(a));
		Turn cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int a__1;
			a__1 = cand_1.loc;
			if (true) {
				// Join Task: LookupAtom #H2 1:0:hash<[+]fireAt(-,-,-)|.>  (A::0) [(A::0)]fireAt((D::2),(X::3),(Y::4))
				StoreIter<FireAt> candidates_2 = fireat_store_0.lookup_candidates(index0FireAt(a));
				FireAt cand_2 = candidates_2.get_next_alive();
				while(cand_2 != null) {
					int a__2;
					a__2 = cand_2.loc;
					d = cand_2.arg1;
					x = cand_2.arg2;
					y = cand_2.arg3;
					if (true) {
						// Join Task: DeleteHead #H1
						turn_store_0.remove( cand_1 );
						// Join Task: DeleteHead #H2
						fireat_store_0.remove( cand_2 );
						// Join Task: IntroAtom Remote NoPrior Mono [(D::2)]blastAt((A::0),(X::3),(Y::4))
						send( new BlastAt(d,a,x,y) ); 
						// Join Task: IntroAtom Remote NoPrior Mono [(B::1)]turn()
						send( new Turn(b) ); 
						// Join Task: IntroAtom Remote NoPrior Mono [(B::1)]notifyTurn()
						send( new NotifyTurn(b) ); 
						shoot_rule_count++;
					}
					cand_2 = candidates_2.get_next_alive();
				}
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule shoot ****
	Rule Head Variables: (A::0), (B::1), (D::2), (X::3), (Y::4)
	Rule Head Compre Binders: 
	Active #H0 [(A::0)]turn()
	LookupAtom #H1 5:0:hash<[+]next(-)|.>  (A::0) [(A::0)]next((B::1))
	LookupAtom #H2 1:0:hash<[+]fireAt(-,-,-)|.>  (A::0) [(A::0)]fireAt((D::2),(X::3),(Y::4))
	DeleteHead #H0
	DeleteHead #H2
	IntroAtom Remote NoPrior Mono [(D::2)]blastAt((A::0),(X::3),(Y::4))
	IntroAtom Remote NoPrior Mono [(B::1)]turn()
	IntroAtom Remote NoPrior Mono [(B::1)]notifyTurn()
	*/
	protected boolean execute_turn_join_ordering_1(Turn act) {
		
		int a;
		int b;
		int d;
		int x;
		int y;
		// Join Task: Active #H0 [(A::0)]turn()
		a = act.loc;
		// Join Task: LookupAtom #H1 5:0:hash<[+]next(-)|.>  (A::0) [(A::0)]next((B::1))
		StoreIter<Next> candidates_1 = next_store_0.lookup_candidates(index0Next(a));
		Next cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int a__1;
			a__1 = cand_1.loc;
			b = cand_1.arg1;
			if (true) {
				// Join Task: LookupAtom #H2 1:0:hash<[+]fireAt(-,-,-)|.>  (A::0) [(A::0)]fireAt((D::2),(X::3),(Y::4))
				StoreIter<FireAt> candidates_2 = fireat_store_0.lookup_candidates(index0FireAt(a));
				FireAt cand_2 = candidates_2.get_next_alive();
				while(cand_2 != null) {
					int a__2;
					a__2 = cand_2.loc;
					d = cand_2.arg1;
					x = cand_2.arg2;
					y = cand_2.arg3;
					if (true) {
						// Join Task: DeleteHead #H0
						// H0 is active and monotone, no delete required
						// Join Task: DeleteHead #H2
						fireat_store_0.remove( cand_2 );
						// Join Task: IntroAtom Remote NoPrior Mono [(D::2)]blastAt((A::0),(X::3),(Y::4))
						send( new BlastAt(d,a,x,y) ); 
						// Join Task: IntroAtom Remote NoPrior Mono [(B::1)]turn()
						send( new Turn(b) ); 
						// Join Task: IntroAtom Remote NoPrior Mono [(B::1)]notifyTurn()
						send( new NotifyTurn(b) ); 
						shoot_rule_count++;
						return false;
					}
					cand_2 = candidates_2.get_next_alive();
				}
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule sunk1 ****
	Rule Head Variables: (D::0), (Ps::1), (Ds::2), (S::5), (A::6), (Hs::7)
	Rule Head Compre Binders: (W::8), (V::9), (Y::3), (X::4)
	Active #H0 [(D::0)]all((Ps::1))
	LookupAtom #H1 9:0:hash<[+]checkShip(-,-)|.>  (D::0) [(D::0)]checkShip((A::6),(S::5))
	LookupAll #H2 3:1:hash<[+]hull(+,-,-)|.>  (D::0),(S::5) [(D::0)]hull((S::5),(W::8),(V::9))
	CompreDomain #H2 (W::8),(V::9) (Hs::7) [(D::0)]hull((S::5),(W::8),(V::9))
	CheckGuard size((Hs::7)) == 0
	LookupAll #H3 8:1:hash<[+]damaged(+,-,-)|.>  (D::0),(S::5) [(D::0)]damaged((S::5),(X::4),(Y::3))
	CompreDomain #H3 (X::4),(Y::3) (Ds::2) [(D::0)]damaged((S::5),(X::4),(Y::3))
	DeleteHead #H1
	DeleteHead #H2
	IntroAtom Remote NoPrior Mono [(D::0)]checkFleet()
	IntroCompre Remote NoPrior Mono (P::10) (Ps::1) [(P::10)]sunk((A::6),(D::0),(S::5),(Ds::2))
	*/
	protected boolean execute_all_join_ordering_1(All act) {
		
		int d;
		SimpMultiset<Integer>  ps;
		SimpMultiset<Tuple2<Integer,Integer> >  ds;
		int y;
		int x;
		String s;
		int a;
		SimpMultiset<Tuple2<Integer,Integer> >  hs;
		int w;
		int v;
		int p;
		// Join Task: Active #H0 [(D::0)]all((Ps::1))
		d = act.loc;
		ps = act.arg1;
		// Join Task: LookupAtom #H1 9:0:hash<[+]checkShip(-,-)|.>  (D::0) [(D::0)]checkShip((A::6),(S::5))
		StoreIter<CheckShip> candidates_1 = checkship_store_0.lookup_candidates(index0CheckShip(d));
		CheckShip cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int d__1;
			d__1 = cand_1.loc;
			a = cand_1.arg1;
			s = cand_1.arg2;
			if (true) {
				// Join Task: LookupAll #H2 3:1:hash<[+]hull(+,-,-)|.>  (D::0),(S::5) [(D::0)]hull((S::5),(W::8),(V::9))
				StoreIter<Hull> candidates_2 = hull_store_1.lookup_candidates(index1Hull(d,s));
				ListStoreIter<Hull> candidates_2_0 = new ListStoreIter<Hull>();
				Hull cand_2 = candidates_2.get_next_alive();
				while(cand_2 != null) {
					int d__2;
					String s__2;
					d__2 = cand_2.loc;
					s__2 = cand_2.arg1;
					w = cand_2.arg2;
					v = cand_2.arg3;
					if (Equality.is_eq(d,d__2) && Equality.is_eq(s,s__2)) {
						candidates_2_0.add( cand_2 );
					}
					cand_2 = candidates_2.get_next_alive();
				}
				candidates_2_0.init_iter();
				// Join Task: CompreDomain #H2 (W::8),(V::9) (Hs::7) [(D::0)]hull((S::5),(W::8),(V::9))
				hs = new SimpMultiset<Tuple2<Integer,Integer> > ();
				Hull cand_2_1 = candidates_2_0.get_next_alive();
				while(cand_2_1 != null) {
					d = cand_2_1.loc;
					s = cand_2_1.arg1;
					w = cand_2_1.arg2;
					v = cand_2_1.arg3;
					hs.add( Tuples.make_tuple(w,v) );
					cand_2_1 = candidates_2_0.get_next_alive();
				}
				candidates_2_0.init_iter();
				// Join Task: CheckGuard size((Hs::7)) == 0
				if (Equality.is_eq(ExtLib.size(hs),0)) {
					// Join Task: LookupAll #H3 8:1:hash<[+]damaged(+,-,-)|.>  (D::0),(S::5) [(D::0)]damaged((S::5),(X::4),(Y::3))
					StoreIter<Damaged> candidates_3 = damaged_store_1.lookup_candidates(index1Damaged(d,s));
					ListStoreIter<Damaged> candidates_3_0 = new ListStoreIter<Damaged>();
					Damaged cand_3 = candidates_3.get_next();
					while(cand_3 != null) {
						int d__3;
						String s__3;
						d__3 = cand_3.loc;
						s__3 = cand_3.arg1;
						x = cand_3.arg2;
						y = cand_3.arg3;
						if (Equality.is_eq(d,d__3) && Equality.is_eq(s,s__3)) {
							candidates_3_0.add( cand_3 );
						}
						cand_3 = candidates_3.get_next();
					}
					candidates_3_0.init_iter();
					// Join Task: CompreDomain #H3 (X::4),(Y::3) (Ds::2) [(D::0)]damaged((S::5),(X::4),(Y::3))
					ds = new SimpMultiset<Tuple2<Integer,Integer> > ();
					Damaged cand_3_1 = candidates_3_0.get_next();
					while(cand_3_1 != null) {
						d = cand_3_1.loc;
						s = cand_3_1.arg1;
						x = cand_3_1.arg2;
						y = cand_3_1.arg3;
						ds.add( Tuples.make_tuple(x,y) );
						cand_3_1 = candidates_3_0.get_next();
					}
					candidates_3_0.init_iter();
					// Join Task: DeleteHead #H1
					checkship_store_0.remove( cand_1 );
					// Join Task: DeleteHead #H2
					Hull cand_2_2 = candidates_2_0.get_next_alive();
					while(cand_2_2 != null) {
						hull_store_0.remove( cand_2_2 );
						cand_2_2 = candidates_2_0.get_next_alive();
					}
					// Join Task: IntroAtom Remote NoPrior Mono [(D::0)]checkFleet()
					intro( new CheckFleet(d) );
					// Join Task: IntroCompre Remote NoPrior Mono (P::10) (Ps::1) [(P::10)]sunk((A::6),(D::0),(S::5),(Ds::2))
					SimpMultiset<Integer>  comp_0 = ps;
					for(int idx=0; idx<comp_0.size(); idx++) {
						p = comp_0.get(idx);
						send( new Sunk(p,a,d,s,ds) ); 
					}
					sunk1_rule_count++;
				}
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule deadFleet1 ****
	Rule Head Variables: (D::0), (Ps::1), (Hs::2)
	Rule Head Compre Binders: (Y::3), (X::4), (S::5)
	Active #H0 [(D::0)]all((Ps::1))
	LookupAtom #H1 10:0:hash<[+]checkFleet()|.>  (D::0) [(D::0)]checkFleet()
	LookupAll #H2 3:2:hash<[+]hull(-,-,-)|.>  (D::0) [(D::0)]hull((S::5),(X::4),(Y::3))
	CompreDomain #H2 (S::5),(X::4),(Y::3) (Hs::2) [(D::0)]hull((S::5),(X::4),(Y::3))
	CheckGuard size((Hs::2)) == 0
	DeleteHead #H0
	DeleteHead #H1
	DeleteHead #H2
	IntroCompre Remote NoPrior Mono (P::6) (Ps::1) [(P::6)]notifyDead((D::0))
	*/
	protected boolean execute_all_join_ordering_2(All act) {
		
		int d;
		SimpMultiset<Integer>  ps;
		SimpMultiset<Tuple3<String,Integer,Integer> >  hs;
		int y;
		int x;
		String s;
		int p;
		// Join Task: Active #H0 [(D::0)]all((Ps::1))
		d = act.loc;
		ps = act.arg1;
		// Join Task: LookupAtom #H1 10:0:hash<[+]checkFleet()|.>  (D::0) [(D::0)]checkFleet()
		StoreIter<CheckFleet> candidates_1 = checkfleet_store_0.lookup_candidates(index0CheckFleet(d));
		CheckFleet cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int d__1;
			d__1 = cand_1.loc;
			if (true) {
				// Join Task: LookupAll #H2 3:2:hash<[+]hull(-,-,-)|.>  (D::0) [(D::0)]hull((S::5),(X::4),(Y::3))
				StoreIter<Hull> candidates_2 = hull_store_2.lookup_candidates(index2Hull(d));
				// Join Task: CompreDomain #H2 (S::5),(X::4),(Y::3) (Hs::2) [(D::0)]hull((S::5),(X::4),(Y::3))
				hs = new SimpMultiset<Tuple3<String,Integer,Integer> > ();
				Hull cand_2_0 = candidates_2.get_next_alive();
				while(cand_2_0 != null) {
					d = cand_2_0.loc;
					s = cand_2_0.arg1;
					x = cand_2_0.arg2;
					y = cand_2_0.arg3;
					hs.add( Tuples.make_tuple(s,x,y) );
					cand_2_0 = candidates_2.get_next_alive();
				}
				candidates_2.init_iter();
				// Join Task: CheckGuard size((Hs::2)) == 0
				if (Equality.is_eq(ExtLib.size(hs),0)) {
					// Join Task: DeleteHead #H0
					// H0 is active and monotone, no delete required
					// Join Task: DeleteHead #H1
					checkfleet_store_0.remove( cand_1 );
					// Join Task: DeleteHead #H2
					Hull cand_2_1 = candidates_2.get_next_alive();
					while(cand_2_1 != null) {
						hull_store_0.remove( cand_2_1 );
						cand_2_1 = candidates_2.get_next_alive();
					}
					// Join Task: IntroCompre Remote NoPrior Mono (P::6) (Ps::1) [(P::6)]notifyDead((D::0))
					SimpMultiset<Integer>  comp_0 = ps;
					for(int idx=0; idx<comp_0.size(); idx++) {
						p = comp_0.get(idx);
						send( new NotifyDead(p,d) ); 
						send( new Dead(p,d) ); 
					}
					deadFleet1_rule_count++;
					return false;
				}
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule winner ****
	Rule Head Variables: (D::0), (Ps::1), (Os::2)
	Rule Head Compre Binders: (O::3)
	Active #H0 [(D::0)]all((Ps::1))
	LookupAll #H1 11:0:hash<[+]dead(-)|.>  (D::0) [(D::0)]dead((O::3))
	CompreDomain #H1 (O::3) (Os::2) [(D::0)]dead((O::3))
	CheckGuard (Ps::1) == union(((Os::2),{(D::0)}))
	DeleteHead #H0
	DeleteHead #H1
	IntroCompre Remote NoPrior Mono (P::4) (Ps::1) [(P::4)]notifyWinner((D::0))
	*/
	protected boolean execute_all_join_ordering_3(All act) {
		
		int d;
		SimpMultiset<Integer>  ps;
		SimpMultiset<Integer>  os;
		int o;
		int p;
		// Join Task: Active #H0 [(D::0)]all((Ps::1))
		d = act.loc;
		ps = act.arg1;
		// Join Task: LookupAll #H1 11:0:hash<[+]dead(-)|.>  (D::0) [(D::0)]dead((O::3))
		StoreIter<Dead> candidates_1 = dead_store_0.lookup_candidates(index0Dead(d));
		// Join Task: CompreDomain #H1 (O::3) (Os::2) [(D::0)]dead((O::3))
		os = new SimpMultiset<Integer> ();
		Dead cand_1_0 = candidates_1.get_next_alive();
		while(cand_1_0 != null) {
			d = cand_1_0.loc;
			o = cand_1_0.arg1;
			os.add( o );
			cand_1_0 = candidates_1.get_next_alive();
		}
		candidates_1.init_iter();
		// Join Task: CheckGuard (Ps::1) == union(((Os::2),{(D::0)}))
		Integer[] temp0 = { d };
		if (Equality.is_eq(ps,ExtLib.union(os,Misc.to_mset(temp0)))) {
			// Join Task: DeleteHead #H0
			// H0 is active and monotone, no delete required
			// Join Task: DeleteHead #H1
			Dead cand_1_1 = candidates_1.get_next_alive();
			while(cand_1_1 != null) {
				dead_store_0.remove( cand_1_1 );
				cand_1_1 = candidates_1.get_next_alive();
			}
			// Join Task: IntroCompre Remote NoPrior Mono (P::4) (Ps::1) [(P::4)]notifyWinner((D::0))
			SimpMultiset<Integer>  comp_0 = ps;
			for(int idx=0; idx<comp_0.size(); idx++) {
				p = comp_0.get(idx);
				send( new NotifyWinner(p,d) ); 
			}
			winner_rule_count++;
			return false;
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule dmgHit ****
	Rule Head Variables: (D::0), (S::1), (X::2), (Y::3), (A::4)
	Rule Head Compre Binders: 
	Active #H0 [(D::0)]damaged((S::1),(X::2),(Y::3))
	LookupAtom #H1 4:0:hash<[+]blastAt(-,+,+)|.>  (D::0),(X::2),(Y::3) [(D::0)]blastAt((A::4),(X::2),(Y::3))
	DeleteHead #H1
	IntroAtom Local NoPrior Mono [(D::0)]hit((A::4),(D::0),(X::2),(Y::3))
	IntroAtom Remote NoPrior Mono [(A::4)]hit((A::4),(D::0),(X::2),(Y::3))
	*/
	protected boolean execute_damaged_join_ordering_1(Damaged act) {
		
		int d;
		String s;
		int x;
		int y;
		int a;
		// Join Task: Active #H0 [(D::0)]damaged((S::1),(X::2),(Y::3))
		if (act.is_alive()) {
			d = act.loc;
			s = act.arg1;
			x = act.arg2;
			y = act.arg3;
			// Join Task: LookupAtom #H1 4:0:hash<[+]blastAt(-,+,+)|.>  (D::0),(X::2),(Y::3) [(D::0)]blastAt((A::4),(X::2),(Y::3))
			StoreIter<BlastAt> candidates_1 = blastat_store_0.lookup_candidates(index0BlastAt(d,x,y));
			BlastAt cand_1 = candidates_1.get_next_alive();
			while(cand_1 != null) {
				int d__1;
				int x__1;
				int y__1;
				d__1 = cand_1.loc;
				a = cand_1.arg1;
				x__1 = cand_1.arg2;
				y__1 = cand_1.arg3;
				if (Equality.is_eq(d,d__1) && Equality.is_eq(x,x__1) && Equality.is_eq(y,y__1)) {
					// Join Task: DeleteHead #H1
					blastat_store_0.remove( cand_1 );
					// Join Task: IntroAtom Local NoPrior Mono [(D::0)]hit((A::4),(D::0),(X::2),(Y::3))
					intro( new Hit(d,a,d,x,y) );
					// Join Task: IntroAtom Remote NoPrior Mono [(A::4)]hit((A::4),(D::0),(X::2),(Y::3))
					send( new Hit(a,a,d,x,y) ); 
					dmgHit_rule_count++;
				} else {
				}
				cand_1 = candidates_1.get_next_alive();
			}
		}
		return true;
	}
	
	/*
	**** 3 Join Ordering of Rule sunk1 ****
	Rule Head Variables: (D::0), (Ps::1), (Ds::2), (S::5), (A::6), (Hs::7)
	Rule Head Compre Binders: (W::8), (V::9), (Y::3), (X::4)
	Active #H0 [(D::0)]damaged((S::5),(X::4),(Y::3))
	LookupAtom #H1 9:1:hash<[+]checkShip(-,+)|.>  (D::0),(S::5) [(D::0)]checkShip((A::6),(S::5))
	LookupAtom #H2 7:0:hash<[+]all(-)|.>  (D::0) [(D::0)]all((Ps::1))
	LookupAll #H3 8:1:hash<[+]damaged(+,-,-)|.>  (D::0),(S::5) [(D::0)]damaged((S::5),(X::4),(Y::3))
	CompreDomain #H3 (X::4),(Y::3) (Ds::2) [(D::0)]damaged((S::5),(X::4),(Y::3))
	LookupAll #H4 3:1:hash<[+]hull(+,-,-)|.>  (D::0),(S::5) [(D::0)]hull((S::5),(W::8),(V::9))
	CompreDomain #H4 (W::8),(V::9) (Hs::7) [(D::0)]hull((S::5),(W::8),(V::9))
	CheckGuard size((Hs::7)) == 0
	DeleteHead #H1
	DeleteHead #H4
	IntroAtom Remote NoPrior Mono [(D::0)]checkFleet()
	IntroCompre Remote NoPrior Mono (P::10) (Ps::1) [(P::10)]sunk((A::6),(D::0),(S::5),(Ds::2))
	*/
	protected boolean execute_damaged_join_ordering_2(Damaged act) {
		
		int d;
		SimpMultiset<Integer>  ps;
		SimpMultiset<Tuple2<Integer,Integer> >  ds;
		int y;
		int x;
		String s;
		int a;
		SimpMultiset<Tuple2<Integer,Integer> >  hs;
		int w;
		int v;
		int p;
		// Join Task: Active #H0 [(D::0)]damaged((S::5),(X::4),(Y::3))
		if (act.is_alive()) {
			d = act.loc;
			s = act.arg1;
			x = act.arg2;
			y = act.arg3;
			// Join Task: LookupAtom #H1 9:1:hash<[+]checkShip(-,+)|.>  (D::0),(S::5) [(D::0)]checkShip((A::6),(S::5))
			StoreIter<CheckShip> candidates_1 = checkship_store_1.lookup_candidates(index1CheckShip(d,s));
			CheckShip cand_1 = candidates_1.get_next_alive();
			while(cand_1 != null) {
				int d__1;
				String s__1;
				d__1 = cand_1.loc;
				a = cand_1.arg1;
				s__1 = cand_1.arg2;
				if (Equality.is_eq(d,d__1) && Equality.is_eq(s,s__1)) {
					// Join Task: LookupAtom #H2 7:0:hash<[+]all(-)|.>  (D::0) [(D::0)]all((Ps::1))
					StoreIter<All> candidates_2 = all_store_0.lookup_candidates(index0All(d));
					All cand_2 = candidates_2.get_next_alive();
					while(cand_2 != null) {
						int d__2;
						d__2 = cand_2.loc;
						ps = cand_2.arg1;
						if (true) {
							// Join Task: LookupAll #H3 8:1:hash<[+]damaged(+,-,-)|.>  (D::0),(S::5) [(D::0)]damaged((S::5),(X::4),(Y::3))
							StoreIter<Damaged> candidates_3 = damaged_store_1.lookup_candidates(index1Damaged(d,s));
							ListStoreIter<Damaged> candidates_3_0 = new ListStoreIter<Damaged>();
							Damaged cand_3 = candidates_3.get_next();
							while(cand_3 != null) {
								int d__3;
								String s__3;
								d__3 = cand_3.loc;
								s__3 = cand_3.arg1;
								x = cand_3.arg2;
								y = cand_3.arg3;
								if (Equality.is_eq(d,d__3) && Equality.is_eq(s,s__3)) {
									candidates_3_0.add( cand_3 );
								}
								cand_3 = candidates_3.get_next();
							}
							candidates_3_0.init_iter();
							// Join Task: CompreDomain #H3 (X::4),(Y::3) (Ds::2) [(D::0)]damaged((S::5),(X::4),(Y::3))
							ds = new SimpMultiset<Tuple2<Integer,Integer> > ();
							Damaged cand_3_1 = candidates_3_0.get_next();
							while(cand_3_1 != null) {
								d = cand_3_1.loc;
								s = cand_3_1.arg1;
								x = cand_3_1.arg2;
								y = cand_3_1.arg3;
								ds.add( Tuples.make_tuple(x,y) );
								cand_3_1 = candidates_3_0.get_next();
							}
							candidates_3_0.init_iter();
							// Join Task: LookupAll #H4 3:1:hash<[+]hull(+,-,-)|.>  (D::0),(S::5) [(D::0)]hull((S::5),(W::8),(V::9))
							StoreIter<Hull> candidates_4 = hull_store_1.lookup_candidates(index1Hull(d,s));
							ListStoreIter<Hull> candidates_4_0 = new ListStoreIter<Hull>();
							Hull cand_4 = candidates_4.get_next_alive();
							while(cand_4 != null) {
								int d__4;
								String s__4;
								d__4 = cand_4.loc;
								s__4 = cand_4.arg1;
								w = cand_4.arg2;
								v = cand_4.arg3;
								if (Equality.is_eq(d,d__4) && Equality.is_eq(s,s__4)) {
									candidates_4_0.add( cand_4 );
								}
								cand_4 = candidates_4.get_next_alive();
							}
							candidates_4_0.init_iter();
							// Join Task: CompreDomain #H4 (W::8),(V::9) (Hs::7) [(D::0)]hull((S::5),(W::8),(V::9))
							hs = new SimpMultiset<Tuple2<Integer,Integer> > ();
							Hull cand_4_1 = candidates_4_0.get_next_alive();
							while(cand_4_1 != null) {
								d = cand_4_1.loc;
								s = cand_4_1.arg1;
								w = cand_4_1.arg2;
								v = cand_4_1.arg3;
								hs.add( Tuples.make_tuple(w,v) );
								cand_4_1 = candidates_4_0.get_next_alive();
							}
							candidates_4_0.init_iter();
							// Join Task: CheckGuard size((Hs::7)) == 0
							if (Equality.is_eq(ExtLib.size(hs),0)) {
								// Join Task: DeleteHead #H1
								checkship_store_0.remove( cand_1 );
								// Join Task: DeleteHead #H4
								Hull cand_4_2 = candidates_4_0.get_next_alive();
								while(cand_4_2 != null) {
									hull_store_0.remove( cand_4_2 );
									cand_4_2 = candidates_4_0.get_next_alive();
								}
								// Join Task: IntroAtom Remote NoPrior Mono [(D::0)]checkFleet()
								intro( new CheckFleet(d) );
								// Join Task: IntroCompre Remote NoPrior Mono (P::10) (Ps::1) [(P::10)]sunk((A::6),(D::0),(S::5),(Ds::2))
								SimpMultiset<Integer>  comp_0 = ps;
								for(int idx=0; idx<comp_0.size(); idx++) {
									p = comp_0.get(idx);
									send( new Sunk(p,a,d,s,ds) ); 
								}
								sunk1_rule_count++;
							}
						}
						cand_2 = candidates_2.get_next_alive();
					}
				} else {
				}
				cand_1 = candidates_1.get_next_alive();
			}
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule sunk1 ****
	Rule Head Variables: (D::0), (Ps::1), (Ds::2), (S::5), (A::6), (Hs::7)
	Rule Head Compre Binders: (W::8), (V::9), (Y::3), (X::4)
	Active #H0 [(D::0)]checkShip((A::6),(S::5))
	LookupAtom #H1 7:0:hash<[+]all(-)|.>  (D::0) [(D::0)]all((Ps::1))
	LookupAll #H2 3:1:hash<[+]hull(+,-,-)|.>  (D::0),(S::5) [(D::0)]hull((S::5),(W::8),(V::9))
	CompreDomain #H2 (W::8),(V::9) (Hs::7) [(D::0)]hull((S::5),(W::8),(V::9))
	CheckGuard size((Hs::7)) == 0
	LookupAll #H3 8:1:hash<[+]damaged(+,-,-)|.>  (D::0),(S::5) [(D::0)]damaged((S::5),(X::4),(Y::3))
	CompreDomain #H3 (X::4),(Y::3) (Ds::2) [(D::0)]damaged((S::5),(X::4),(Y::3))
	DeleteHead #H0
	DeleteHead #H2
	IntroAtom Remote NoPrior Mono [(D::0)]checkFleet()
	IntroCompre Remote NoPrior Mono (P::10) (Ps::1) [(P::10)]sunk((A::6),(D::0),(S::5),(Ds::2))
	*/
	protected boolean execute_checkship_join_ordering_1(CheckShip act) {
		
		int d;
		SimpMultiset<Integer>  ps;
		SimpMultiset<Tuple2<Integer,Integer> >  ds;
		int y;
		int x;
		String s;
		int a;
		SimpMultiset<Tuple2<Integer,Integer> >  hs;
		int w;
		int v;
		int p;
		// Join Task: Active #H0 [(D::0)]checkShip((A::6),(S::5))
		d = act.loc;
		a = act.arg1;
		s = act.arg2;
		// Join Task: LookupAtom #H1 7:0:hash<[+]all(-)|.>  (D::0) [(D::0)]all((Ps::1))
		StoreIter<All> candidates_1 = all_store_0.lookup_candidates(index0All(d));
		All cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int d__1;
			d__1 = cand_1.loc;
			ps = cand_1.arg1;
			if (true) {
				// Join Task: LookupAll #H2 3:1:hash<[+]hull(+,-,-)|.>  (D::0),(S::5) [(D::0)]hull((S::5),(W::8),(V::9))
				StoreIter<Hull> candidates_2 = hull_store_1.lookup_candidates(index1Hull(d,s));
				ListStoreIter<Hull> candidates_2_0 = new ListStoreIter<Hull>();
				Hull cand_2 = candidates_2.get_next_alive();
				while(cand_2 != null) {
					int d__2;
					String s__2;
					d__2 = cand_2.loc;
					s__2 = cand_2.arg1;
					w = cand_2.arg2;
					v = cand_2.arg3;
					if (Equality.is_eq(d,d__2) && Equality.is_eq(s,s__2)) {
						candidates_2_0.add( cand_2 );
					}
					cand_2 = candidates_2.get_next_alive();
				}
				candidates_2_0.init_iter();
				// Join Task: CompreDomain #H2 (W::8),(V::9) (Hs::7) [(D::0)]hull((S::5),(W::8),(V::9))
				hs = new SimpMultiset<Tuple2<Integer,Integer> > ();
				Hull cand_2_1 = candidates_2_0.get_next_alive();
				while(cand_2_1 != null) {
					d = cand_2_1.loc;
					s = cand_2_1.arg1;
					w = cand_2_1.arg2;
					v = cand_2_1.arg3;
					hs.add( Tuples.make_tuple(w,v) );
					cand_2_1 = candidates_2_0.get_next_alive();
				}
				candidates_2_0.init_iter();
				// Join Task: CheckGuard size((Hs::7)) == 0
				if (Equality.is_eq(ExtLib.size(hs),0)) {
					// Join Task: LookupAll #H3 8:1:hash<[+]damaged(+,-,-)|.>  (D::0),(S::5) [(D::0)]damaged((S::5),(X::4),(Y::3))
					StoreIter<Damaged> candidates_3 = damaged_store_1.lookup_candidates(index1Damaged(d,s));
					ListStoreIter<Damaged> candidates_3_0 = new ListStoreIter<Damaged>();
					Damaged cand_3 = candidates_3.get_next();
					while(cand_3 != null) {
						int d__3;
						String s__3;
						d__3 = cand_3.loc;
						s__3 = cand_3.arg1;
						x = cand_3.arg2;
						y = cand_3.arg3;
						if (Equality.is_eq(d,d__3) && Equality.is_eq(s,s__3)) {
							candidates_3_0.add( cand_3 );
						}
						cand_3 = candidates_3.get_next();
					}
					candidates_3_0.init_iter();
					// Join Task: CompreDomain #H3 (X::4),(Y::3) (Ds::2) [(D::0)]damaged((S::5),(X::4),(Y::3))
					ds = new SimpMultiset<Tuple2<Integer,Integer> > ();
					Damaged cand_3_1 = candidates_3_0.get_next();
					while(cand_3_1 != null) {
						d = cand_3_1.loc;
						s = cand_3_1.arg1;
						x = cand_3_1.arg2;
						y = cand_3_1.arg3;
						ds.add( Tuples.make_tuple(x,y) );
						cand_3_1 = candidates_3_0.get_next();
					}
					candidates_3_0.init_iter();
					// Join Task: DeleteHead #H0
					// H0 is active and monotone, no delete required
					// Join Task: DeleteHead #H2
					Hull cand_2_2 = candidates_2_0.get_next_alive();
					while(cand_2_2 != null) {
						hull_store_0.remove( cand_2_2 );
						cand_2_2 = candidates_2_0.get_next_alive();
					}
					// Join Task: IntroAtom Remote NoPrior Mono [(D::0)]checkFleet()
					intro( new CheckFleet(d) );
					// Join Task: IntroCompre Remote NoPrior Mono (P::10) (Ps::1) [(P::10)]sunk((A::6),(D::0),(S::5),(Ds::2))
					SimpMultiset<Integer>  comp_0 = ps;
					for(int idx=0; idx<comp_0.size(); idx++) {
						p = comp_0.get(idx);
						send( new Sunk(p,a,d,s,ds) ); 
					}
					sunk1_rule_count++;
					return false;
				}
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule sunk2 ****
	Rule Head Variables: (D::0), (A::1), (S::2)
	Rule Head Compre Binders: 
	Active #H0 [(D::0)]checkShip((A::1),(S::2))
	DeleteHead #H0
	*/
	protected boolean execute_checkship_join_ordering_2(CheckShip act) {
		
		int d;
		int a;
		String s;
		// Join Task: Active #H0 [(D::0)]checkShip((A::1),(S::2))
		d = act.loc;
		a = act.arg1;
		s = act.arg2;
		// Join Task: DeleteHead #H0
		// H0 is active and monotone, no delete required
		sunk2_rule_count++;
		return false;
		
	}
	
	/*
	**** 1 Join Ordering of Rule deadFleet1 ****
	Rule Head Variables: (D::0), (Ps::1), (Hs::2)
	Rule Head Compre Binders: (Y::3), (X::4), (S::5)
	Active #H0 [(D::0)]checkFleet()
	LookupAtom #H1 7:0:hash<[+]all(-)|.>  (D::0) [(D::0)]all((Ps::1))
	LookupAll #H2 3:2:hash<[+]hull(-,-,-)|.>  (D::0) [(D::0)]hull((S::5),(X::4),(Y::3))
	CompreDomain #H2 (S::5),(X::4),(Y::3) (Hs::2) [(D::0)]hull((S::5),(X::4),(Y::3))
	CheckGuard size((Hs::2)) == 0
	DeleteHead #H0
	DeleteHead #H1
	DeleteHead #H2
	IntroCompre Remote NoPrior Mono (P::6) (Ps::1) [(P::6)]notifyDead((D::0))
	*/
	protected boolean execute_checkfleet_join_ordering_1(CheckFleet act) {
		
		int d;
		SimpMultiset<Integer>  ps;
		SimpMultiset<Tuple3<String,Integer,Integer> >  hs;
		int y;
		int x;
		String s;
		int p;
		// Join Task: Active #H0 [(D::0)]checkFleet()
		d = act.loc;
		// Join Task: LookupAtom #H1 7:0:hash<[+]all(-)|.>  (D::0) [(D::0)]all((Ps::1))
		StoreIter<All> candidates_1 = all_store_0.lookup_candidates(index0All(d));
		All cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int d__1;
			d__1 = cand_1.loc;
			ps = cand_1.arg1;
			if (true) {
				// Join Task: LookupAll #H2 3:2:hash<[+]hull(-,-,-)|.>  (D::0) [(D::0)]hull((S::5),(X::4),(Y::3))
				StoreIter<Hull> candidates_2 = hull_store_2.lookup_candidates(index2Hull(d));
				// Join Task: CompreDomain #H2 (S::5),(X::4),(Y::3) (Hs::2) [(D::0)]hull((S::5),(X::4),(Y::3))
				hs = new SimpMultiset<Tuple3<String,Integer,Integer> > ();
				Hull cand_2_0 = candidates_2.get_next_alive();
				while(cand_2_0 != null) {
					d = cand_2_0.loc;
					s = cand_2_0.arg1;
					x = cand_2_0.arg2;
					y = cand_2_0.arg3;
					hs.add( Tuples.make_tuple(s,x,y) );
					cand_2_0 = candidates_2.get_next_alive();
				}
				candidates_2.init_iter();
				// Join Task: CheckGuard size((Hs::2)) == 0
				if (Equality.is_eq(ExtLib.size(hs),0)) {
					// Join Task: DeleteHead #H0
					// H0 is active and monotone, no delete required
					// Join Task: DeleteHead #H1
					all_store_0.remove( cand_1 );
					// Join Task: DeleteHead #H2
					Hull cand_2_1 = candidates_2.get_next_alive();
					while(cand_2_1 != null) {
						hull_store_0.remove( cand_2_1 );
						cand_2_1 = candidates_2.get_next_alive();
					}
					// Join Task: IntroCompre Remote NoPrior Mono (P::6) (Ps::1) [(P::6)]notifyDead((D::0))
					SimpMultiset<Integer>  comp_0 = ps;
					for(int idx=0; idx<comp_0.size(); idx++) {
						p = comp_0.get(idx);
						send( new NotifyDead(p,d) ); 
						send( new Dead(p,d) ); 
					}
					deadFleet1_rule_count++;
					return false;
				}
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule deadFleet2 ****
	Rule Head Variables: (D::0)
	Rule Head Compre Binders: 
	Active #H0 [(D::0)]checkFleet()
	DeleteHead #H0
	*/
	protected boolean execute_checkfleet_join_ordering_2(CheckFleet act) {
		
		int d;
		// Join Task: Active #H0 [(D::0)]checkFleet()
		d = act.loc;
		// Join Task: DeleteHead #H0
		// H0 is active and monotone, no delete required
		deadFleet2_rule_count++;
		return false;
		
	}
	
	/*
	**** 1 Join Ordering of Rule winner ****
	Rule Head Variables: (D::0), (Ps::1), (Os::2)
	Rule Head Compre Binders: (O::3)
	Active #H0 [(D::0)]dead((O::3))
	LookupAtom #H1 7:0:hash<[+]all(-)|.>  (D::0) [(D::0)]all((Ps::1))
	LookupAll #H2 11:0:hash<[+]dead(-)|.>  (D::0) [(D::0)]dead((O::3))
	CompreDomain #H2 (O::3) (Os::2) [(D::0)]dead((O::3))
	CheckGuard (Ps::1) == union(((Os::2),{(D::0)}))
	DeleteHead #H1
	DeleteHead #H2
	IntroCompre Remote NoPrior Mono (P::4) (Ps::1) [(P::4)]notifyWinner((D::0))
	*/
	protected boolean execute_dead_join_ordering_1(Dead act) {
		
		int d;
		SimpMultiset<Integer>  ps;
		SimpMultiset<Integer>  os;
		int o;
		int p;
		// Join Task: Active #H0 [(D::0)]dead((O::3))
		if (act.is_alive()) {
			d = act.loc;
			o = act.arg1;
			// Join Task: LookupAtom #H1 7:0:hash<[+]all(-)|.>  (D::0) [(D::0)]all((Ps::1))
			StoreIter<All> candidates_1 = all_store_0.lookup_candidates(index0All(d));
			All cand_1 = candidates_1.get_next_alive();
			while(cand_1 != null) {
				int d__1;
				d__1 = cand_1.loc;
				ps = cand_1.arg1;
				if (true) {
					// Join Task: LookupAll #H2 11:0:hash<[+]dead(-)|.>  (D::0) [(D::0)]dead((O::3))
					StoreIter<Dead> candidates_2 = dead_store_0.lookup_candidates(index0Dead(d));
					// Join Task: CompreDomain #H2 (O::3) (Os::2) [(D::0)]dead((O::3))
					os = new SimpMultiset<Integer> ();
					Dead cand_2_0 = candidates_2.get_next_alive();
					while(cand_2_0 != null) {
						d = cand_2_0.loc;
						o = cand_2_0.arg1;
						os.add( o );
						cand_2_0 = candidates_2.get_next_alive();
					}
					candidates_2.init_iter();
					// Join Task: CheckGuard (Ps::1) == union(((Os::2),{(D::0)}))
					Integer[] temp1 = { d };
					if (Equality.is_eq(ps,ExtLib.union(os,Misc.to_mset(temp1)))) {
						// Join Task: DeleteHead #H1
						all_store_0.remove( cand_1 );
						// Join Task: DeleteHead #H2
						Dead cand_2_1 = candidates_2.get_next_alive();
						while(cand_2_1 != null) {
							dead_store_0.remove( cand_2_1 );
							cand_2_1 = candidates_2.get_next_alive();
						}
						// Join Task: IntroCompre Remote NoPrior Mono (P::4) (Ps::1) [(P::4)]notifyWinner((D::0))
						SimpMultiset<Integer>  comp_0 = ps;
						for(int idx=0; idx<comp_0.size(); idx++) {
							p = comp_0.get(idx);
							send( new NotifyWinner(p,d) ); 
						}
						winner_rule_count++;
						return false;
					}
				}
				cand_1 = candidates_1.get_next_alive();
			}
		}
		return true;
	}
	

	protected void execute(InitGame initgame) {
		if( execute_initgame_join_ordering_1(initgame) ) {
			store( initgame );
		}
	}
	
	protected void execute(FireAt fireat) {
		if( execute_fireat_join_ordering_1(fireat) ) {
			store( fireat );
		}
	}
	
	protected void execute(Empty empty) {
		execute_empty_join_ordering_1( empty );
		store( empty );
	}
	
	protected void execute(Hull hull) {
		if( execute_hull_join_ordering_1(hull) ) {
			if( execute_hull_join_ordering_2(hull) ) {
				if( execute_hull_join_ordering_3(hull) ) {
				}
			}
		}
	}
	
	protected void execute(BlastAt blastat) {
		if( execute_blastat_join_ordering_1(blastat) ) {
			if( execute_blastat_join_ordering_2(blastat) ) {
				if( execute_blastat_join_ordering_3(blastat) ) {
					store( blastat );
				}
			}
		}
	}
	
	protected void execute(Next next) {
		execute_next_join_ordering_1( next );
		store( next );
	}
	
	protected void execute(Turn turn) {
		if( execute_turn_join_ordering_1(turn) ) {
			store( turn );
		}
	}
	
	protected void execute(All all) {
		execute_all_join_ordering_1( all );
		if( execute_all_join_ordering_2(all) ) {
			if( execute_all_join_ordering_3(all) ) {
				store( all );
			}
		}
	}
	
	protected void execute(Damaged damaged) {
		execute_damaged_join_ordering_1( damaged );
		execute_damaged_join_ordering_2( damaged );
	}
	
	protected void execute(CheckShip checkship) {
		if( execute_checkship_join_ordering_1(checkship) ) {
			if( execute_checkship_join_ordering_2(checkship) ) {
				store( checkship );
			}
		}
	}
	
	protected void execute(CheckFleet checkfleet) {
		if( execute_checkfleet_join_ordering_1(checkfleet) ) {
			if( execute_checkfleet_join_ordering_2(checkfleet) ) {
				store( checkfleet );
			}
		}
	}
	
	protected void execute(Dead dead) {
		if( execute_dead_join_ordering_1(dead) ) {
		}
	}
	

	@Override
	public void init() {
	}

}


