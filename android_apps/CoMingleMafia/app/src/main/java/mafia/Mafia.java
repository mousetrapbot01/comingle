package mafia;

import java.io.Serializable;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.Calendar;

import comingle.goals.*;
import comingle.store.*;
import comingle.facts.*;
import comingle.rewrite.*;
import comingle.hash.*;
import comingle.tuple.*;
import comingle.misc.*;
import comingle.mset.*;
import comingle.actuation.*;
import comingle.lib.*;
import comingle.pretty.*;

import comingle.lib.ExtLib;




/**
**  
** Generated by Comingle: Distributed Logic Programming for Decentralized Mobile Ensembles
** Visit https://github.com/sllam/comingle for more information.
** Or contact us:      
**      Edmund Lam          sllam@qatar.cmu.edu
**      Iliano Cervesato    iliano@cmu.edu
**
**/

/**
** This Comingle Runtime is generated from the following Comingle specifications:
ensem mafia {

	module comingle.lib.ExtLib import {
		pick :: ({loc},int) -> {loc}.
		size :: {A} -> int.
		diff :: ({A},{A}) -> {A}.
		union :: ({A},{A}) -> {A}.
		timeNow :: int -> time.
		not :: bool -> bool.
		addSeconds :: (time,int) -> time.
	}

	predicate initialize :: ({loc},int) -> trigger.
	predicate start      :: trigger.
	predicate kill       :: loc -> trigger.
	predicate mafiaChangedVote :: loc -> trigger.
	predicate citizenChangedVote :: loc -> trigger.
	predicate mark :: loc -> trigger.

	predicate moderator   :: loc -> fact.
	predicate isModerator :: fact.
	predicate isMafia     :: fact.
	predicate isCitizen   :: fact.

	predicate duration    :: int -> fact.
	predicate livePlayers :: ({loc},{loc}) -> fact.
	predicate allPlayers  :: {loc} -> fact.
	predicate allMafia    :: {loc} -> fact.
	predicate trans       :: (bool,bool) -> fact.
	predicate cycle       :: bool -> fact.
	predicate checkVotes  :: {loc} -> fact.
	predicate checkEnd    :: fact.

	predicate notifyMarked :: actuator.
	predicate notifyIsCitizen  :: actuator.
	predicate notifyIsMafia    :: {loc} -> actuator.
	predicate notifyMafiaChangedVote   :: (loc,loc) -> actuator.
	predicate notifyCitizenChangedVote :: (loc,loc) -> actuator.

	predicate warnNight   :: time -> actuator.
	predicate warnDay     :: time -> actuator.
	predicate signalNight :: time -> actuator.
	predicate signalDay   :: time -> actuator.
	predicate wakeMafia   :: time -> actuator.
	predicate notifyCheckVotes :: ({loc},time,bool) -> actuator.
	predicate notifyDeath :: loc -> actuator.
	predicate notifyMafiaWin :: actuator.
	predicate notifyCitizensWin :: actuator.

	rule initi :: [I]initialize(Ps,D) --o [I]duration(D), [I]livePlayers(Cs,Ms), [I]isModerator(),
                                             { [P]allPlayers(Ps), [P]moderator(I) | P<-Ps },
                                             { [C]notifyIsCitizen(), [C]isCitizen() | C<-Cs }, 
                                             { [M]notifyIsMafia(Ms), [M]isMafia(), [M]allMafia(Ms) | M<-Ms }
                                             where Ms = pick(Ps,(size(Ps))/3),
                                                   Cs = diff(Ps,Ms).

	rule start :: [I]moderator(I) \ [I]start() --o [I]trans(Night,IsFirst), [I]cycle(Night) 
                                                       where Night = true,
                                                             IsFirst = true.

	rule mvote :: [X]isMafia(), [X]allMafia(Ms), [X]moderator(I) \ [X]mafiaChangedVote(C) 
                               --o { [M]notifyMafiaChangedVote(X,C) | M<-union({I},Ms) }.
	rule cvote :: [X]allPlayers(Ps) \ [X]citizenChangedVote(C) --o { [P]notifyCitizenChangedVote(X,C) | P<-Ps }.

	rule night :: [I]allPlayers(Ps), [I]duration(D), [I]livePlayers(Cs,Ms) \ [I]trans(Night,IsFirst) 
                  | Night --o { [P]warnNight(TimeWarn), [P]signalNight(TimeNight) | P<-Ps },
                              { [M]wakeMafia(TimeWake) | M<-Ms },
                              [I]notifyCheckVotes(Ms,TimeNext,IsFirst)
                              where TimeWarn  = addSeconds(timeNow(1),1), 
                                    TimeNight = addSeconds(TimeWarn,10),
                                    TimeWake  = addSeconds(TimeNight,5),
                                    TimeNext  = addSeconds( addSeconds(TimeNight,D), 0-11).

	rule day :: [I]allPlayers(Ps), [I]duration(D), [I]livePlayers(Cs,Ms) \ [I]trans(Night,IsFirst) 
                  | not(Night) --o { [P]warnDay(TimeWarn), [P]signalDay(TimeDay) | P<-Ps },
                                   [I]notifyCheckVotes(union(Ms,Cs),TimeNext,IsFirst)
                                   where TimeWarn  = addSeconds(timeNow(1),1), 
                                         TimeDay   = addSeconds(TimeWarn,10),
                                         TimeNext  = addSeconds( addSeconds(TimeDay,D), 0-11).

	rule kill :: [I]isModerator(), [I]allPlayers(Ps) \ [I]kill(K), [I]livePlayers(Cs,Ms)
                   --o [I]livePlayers(diff(Cs,{K}),diff(Ms,{K})), 
                       { [P]notifyDeath(K) | P<-Ps }, [I]checkEnd().

	rule marked :: [I]isModerator() \ [I]mark(M) --o [M]notifyMarked(), [I]checkEnd().

	rule end1 :: [I]allPlayers(Ps), [I]livePlayers(Cs,Ms) \ [I]checkEnd() 
                   | (size(Ms))>=(size(Cs)) --o { [P]notifyMafiaWin() | P<-Ps }.

	rule end2 :: [I]allPlayers(Ps), [I]livePlayers(Cs,Ms) \ [I]checkEnd() 
                   | (size(Ms)) == 0 --o { [P]notifyCitizensWin() | P<-Ps }.

	rule cont :: [I]livePlayers(Cs,Ms) \ [I]cycle(Night), [I]checkEnd() 
                   | (size(Ms))<(size(Cs)), (size(Ms))>0 --o [I]trans(not(Night),false), [I]cycle(not(Night)).
}
**/


public class Mafia extends RewriteMachine {

	public class Actuations {
		public static final String notifymarked = "notifymarked";
		public static final String notifyiscitizen = "notifyiscitizen";
		public static final String notifyismafia = "notifyismafia";
		public static final String notifymafiachangedvote = "notifymafiachangedvote";
		public static final String notifycitizenchangedvote = "notifycitizenchangedvote";
		public static final String warnnight = "warnnight";
		public static final String warnday = "warnday";
		public static final String signalnight = "signalnight";
		public static final String signalday = "signalday";
		public static final String wakemafia = "wakemafia";
		public static final String notifycheckvotes = "notifycheckvotes";
		public static final String notifydeath = "notifydeath";
		public static final String notifymafiawin = "notifymafiawin";
		public static final String notifycitizenswin = "notifycitizenswin";
		public static final String delay = "delay";
		public static final String beep = "beep";
		public static final String toast = "toast";
	}

	abstract class MafiaFact extends Fact {
		public MafiaFact(int l) { super(l); }
		public void execute(Mafia ensem) { }
		public void intro(Mafia ensem) { }
	}

	public class Initialize extends MafiaFact {
		public SimpMultiset<Integer>  arg1;
		public int arg2;
	
		public Initialize(int l, SimpMultiset<Integer>  a1, int a2) { super(l); arg1=a1; arg2=a2; }
	
		public int fact_idx() { return 0; }
	
		@Override
		public void execute(Mafia ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1, (Serializable) arg2 };
			return new SerializedFact(loc, 0, arguments);
		}
	
		public String toString() { return String.format("[%s]Initialize(%s,%s)",loc,arg1,arg2); }
	
	}
	
	public class Start extends MafiaFact {
		
	
		public Start(int l) { super(l); }
	
		public int fact_idx() { return 1; }
	
		@Override
		public void execute(Mafia ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = {  };
			return new SerializedFact(loc, 1, arguments);
		}
	
		public String toString() { return String.format("[%s]Start()",loc); }
	
	}
	
	public class Kill extends MafiaFact {
		public int arg1;
	
		public Kill(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 2; }
	
		@Override
		public void execute(Mafia ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 2, arguments);
		}
	
		public String toString() { return String.format("[%s]Kill(%s)",loc,arg1); }
	
	}
	
	public class MafiaChangedVote extends MafiaFact {
		public int arg1;
	
		public MafiaChangedVote(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 3; }
	
		@Override
		public void execute(Mafia ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 3, arguments);
		}
	
		public String toString() { return String.format("[%s]MafiaChangedVote(%s)",loc,arg1); }
	
	}
	
	public class CitizenChangedVote extends MafiaFact {
		public int arg1;
	
		public CitizenChangedVote(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 4; }
	
		@Override
		public void execute(Mafia ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 4, arguments);
		}
	
		public String toString() { return String.format("[%s]CitizenChangedVote(%s)",loc,arg1); }
	
	}
	
	public class Mark extends MafiaFact {
		public int arg1;
	
		public Mark(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 5; }
	
		@Override
		public void execute(Mafia ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 5, arguments);
		}
	
		public String toString() { return String.format("[%s]Mark(%s)",loc,arg1); }
	
	}
	
	public class Moderator extends MafiaFact {
		public int arg1;
	
		public Moderator(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 6; }
	
		@Override
		public void execute(Mafia ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 6, arguments);
		}
	
		public String toString() { return String.format("[%s]Moderator(%s)",loc,arg1); }
	
	}
	
	public class IsModerator extends MafiaFact {
		
	
		public IsModerator(int l) { super(l); }
	
		public int fact_idx() { return 7; }
	
		@Override
		public void execute(Mafia ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = {  };
			return new SerializedFact(loc, 7, arguments);
		}
	
		public String toString() { return String.format("[%s]IsModerator()",loc); }
	
	}
	
	public class IsMafia extends MafiaFact {
		
	
		public IsMafia(int l) { super(l); }
	
		public int fact_idx() { return 8; }
	
		@Override
		public void execute(Mafia ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = {  };
			return new SerializedFact(loc, 8, arguments);
		}
	
		public String toString() { return String.format("[%s]IsMafia()",loc); }
	
	}
	
	public class IsCitizen extends MafiaFact {
		
	
		public IsCitizen(int l) { super(l); }
	
		public int fact_idx() { return 9; }
	
		@Override
		public void execute(Mafia ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = {  };
			return new SerializedFact(loc, 9, arguments);
		}
	
		public String toString() { return String.format("[%s]IsCitizen()",loc); }
	
	}
	
	public class Duration extends MafiaFact {
		public int arg1;
	
		public Duration(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 10; }
	
		@Override
		public void execute(Mafia ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 10, arguments);
		}
	
		public String toString() { return String.format("[%s]Duration(%s)",loc,arg1); }
	
	}
	
	public class LivePlayers extends MafiaFact {
		public SimpMultiset<Integer>  arg1;
		public SimpMultiset<Integer>  arg2;
	
		public LivePlayers(int l, SimpMultiset<Integer>  a1, SimpMultiset<Integer>  a2) { super(l); arg1=a1; arg2=a2; }
	
		public int fact_idx() { return 11; }
	
		@Override
		public void execute(Mafia ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1, (Serializable) arg2 };
			return new SerializedFact(loc, 11, arguments);
		}
	
		public String toString() { return String.format("[%s]LivePlayers(%s,%s)",loc,arg1,arg2); }
	
	}
	
	public class AllPlayers extends MafiaFact {
		public SimpMultiset<Integer>  arg1;
	
		public AllPlayers(int l, SimpMultiset<Integer>  a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 12; }
	
		@Override
		public void execute(Mafia ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 12, arguments);
		}
	
		public String toString() { return String.format("[%s]AllPlayers(%s)",loc,arg1); }
	
	}
	
	public class AllMafia extends MafiaFact {
		public SimpMultiset<Integer>  arg1;
	
		public AllMafia(int l, SimpMultiset<Integer>  a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 13; }
	
		@Override
		public void execute(Mafia ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 13, arguments);
		}
	
		public String toString() { return String.format("[%s]AllMafia(%s)",loc,arg1); }
	
	}
	
	public class Trans extends MafiaFact {
		public boolean arg1;
		public boolean arg2;
	
		public Trans(int l, boolean a1, boolean a2) { super(l); arg1=a1; arg2=a2; }
	
		public int fact_idx() { return 14; }
	
		@Override
		public void execute(Mafia ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1, (Serializable) arg2 };
			return new SerializedFact(loc, 14, arguments);
		}
	
		public String toString() { return String.format("[%s]Trans(%s,%s)",loc,arg1,arg2); }
	
	}
	
	public class Cycle extends MafiaFact {
		public boolean arg1;
	
		public Cycle(int l, boolean a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 15; }
	
		@Override
		public void execute(Mafia ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 15, arguments);
		}
	
		public String toString() { return String.format("[%s]Cycle(%s)",loc,arg1); }
	
	}
	
	public class CheckVotes extends MafiaFact {
		public SimpMultiset<Integer>  arg1;
	
		public CheckVotes(int l, SimpMultiset<Integer>  a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 16; }
	
		@Override
		public void execute(Mafia ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 16, arguments);
		}
	
		public String toString() { return String.format("[%s]CheckVotes(%s)",loc,arg1); }
	
	}
	
	public class CheckEnd extends MafiaFact {
		
	
		public CheckEnd(int l) { super(l); }
	
		public int fact_idx() { return 17; }
	
		@Override
		public void execute(Mafia ensem) { ensem.execute( this ); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = {  };
			return new SerializedFact(loc, 17, arguments);
		}
	
		public String toString() { return String.format("[%s]CheckEnd()",loc); }
	
	}
	
	public class NotifyMarked extends MafiaFact {
		
	
		public NotifyMarked(int l) { super(l); }
	
		public int fact_idx() { return 18; }
	
		@Override
		public void execute(Mafia ensem) { ensem.invokeActuator("notifymarked",Tuples.make_unit()); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = {  };
			return new SerializedFact(loc, 18, arguments);
		}
	
		public String toString() { return String.format("[%s]NotifyMarked()",loc); }
	
	}
	
	public class NotifyIsCitizen extends MafiaFact {
		
	
		public NotifyIsCitizen(int l) { super(l); }
	
		public int fact_idx() { return 19; }
	
		@Override
		public void execute(Mafia ensem) { ensem.invokeActuator("notifyiscitizen",Tuples.make_unit()); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = {  };
			return new SerializedFact(loc, 19, arguments);
		}
	
		public String toString() { return String.format("[%s]NotifyIsCitizen()",loc); }
	
	}
	
	public class NotifyIsMafia extends MafiaFact {
		public SimpMultiset<Integer>  arg1;
	
		public NotifyIsMafia(int l, SimpMultiset<Integer>  a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 20; }
	
		@Override
		public void execute(Mafia ensem) { ensem.invokeActuator("notifyismafia",arg1); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 20, arguments);
		}
	
		public String toString() { return String.format("[%s]NotifyIsMafia(%s)",loc,arg1); }
	
	}
	
	public class NotifyMafiaChangedVote extends MafiaFact {
		public int arg1;
		public int arg2;
	
		public NotifyMafiaChangedVote(int l, int a1, int a2) { super(l); arg1=a1; arg2=a2; }
	
		public int fact_idx() { return 21; }
	
		@Override
		public void execute(Mafia ensem) { ensem.invokeActuator("notifymafiachangedvote",Tuples.make_tuple(arg1,arg2)); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1, (Serializable) arg2 };
			return new SerializedFact(loc, 21, arguments);
		}
	
		public String toString() { return String.format("[%s]NotifyMafiaChangedVote(%s,%s)",loc,arg1,arg2); }
	
	}
	
	public class NotifyCitizenChangedVote extends MafiaFact {
		public int arg1;
		public int arg2;
	
		public NotifyCitizenChangedVote(int l, int a1, int a2) { super(l); arg1=a1; arg2=a2; }
	
		public int fact_idx() { return 22; }
	
		@Override
		public void execute(Mafia ensem) { ensem.invokeActuator("notifycitizenchangedvote",Tuples.make_tuple(arg1,arg2)); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1, (Serializable) arg2 };
			return new SerializedFact(loc, 22, arguments);
		}
	
		public String toString() { return String.format("[%s]NotifyCitizenChangedVote(%s,%s)",loc,arg1,arg2); }
	
	}
	
	public class WarnNight extends MafiaFact {
		public long arg1;
	
		public WarnNight(int l, long a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 23; }
	
		@Override
		public void execute(Mafia ensem) { ensem.invokeActuator("warnnight",arg1); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 23, arguments);
		}
	
		public String toString() { return String.format("[%s]WarnNight(%s)",loc,PrettyPrinter.prettyTime(arg1)); }
	
	}
	
	public class WarnDay extends MafiaFact {
		public long arg1;
	
		public WarnDay(int l, long a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 24; }
	
		@Override
		public void execute(Mafia ensem) { ensem.invokeActuator("warnday",arg1); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 24, arguments);
		}
	
		public String toString() { return String.format("[%s]WarnDay(%s)",loc,PrettyPrinter.prettyTime(arg1)); }
	
	}
	
	public class SignalNight extends MafiaFact {
		public long arg1;
	
		public SignalNight(int l, long a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 25; }
	
		@Override
		public void execute(Mafia ensem) { ensem.invokeActuator("signalnight",arg1); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 25, arguments);
		}
	
		public String toString() { return String.format("[%s]SignalNight(%s)",loc,PrettyPrinter.prettyTime(arg1)); }
	
	}
	
	public class SignalDay extends MafiaFact {
		public long arg1;
	
		public SignalDay(int l, long a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 26; }
	
		@Override
		public void execute(Mafia ensem) { ensem.invokeActuator("signalday",arg1); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 26, arguments);
		}
	
		public String toString() { return String.format("[%s]SignalDay(%s)",loc,PrettyPrinter.prettyTime(arg1)); }
	
	}
	
	public class WakeMafia extends MafiaFact {
		public long arg1;
	
		public WakeMafia(int l, long a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 27; }
	
		@Override
		public void execute(Mafia ensem) { ensem.invokeActuator("wakemafia",arg1); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 27, arguments);
		}
	
		public String toString() { return String.format("[%s]WakeMafia(%s)",loc,PrettyPrinter.prettyTime(arg1)); }
	
	}
	
	public class NotifyCheckVotes extends MafiaFact {
		public SimpMultiset<Integer>  arg1;
		public long arg2;
		public boolean arg3;
	
		public NotifyCheckVotes(int l, SimpMultiset<Integer>  a1, long a2, boolean a3) { super(l); arg1=a1; arg2=a2; arg3=a3; }
	
		public int fact_idx() { return 28; }
	
		@Override
		public void execute(Mafia ensem) { ensem.invokeActuator("notifycheckvotes",Tuples.make_tuple(arg1,arg2,arg3)); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1, (Serializable) arg2, (Serializable) arg3 };
			return new SerializedFact(loc, 28, arguments);
		}
	
		public String toString() { return String.format("[%s]NotifyCheckVotes(%s,%s,%s)",loc,arg1,PrettyPrinter.prettyTime(arg2),arg3); }
	
	}
	
	public class NotifyDeath extends MafiaFact {
		public int arg1;
	
		public NotifyDeath(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 29; }
	
		@Override
		public void execute(Mafia ensem) { ensem.invokeActuator("notifydeath",arg1); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 29, arguments);
		}
	
		public String toString() { return String.format("[%s]NotifyDeath(%s)",loc,arg1); }
	
	}
	
	public class NotifyMafiaWin extends MafiaFact {
		
	
		public NotifyMafiaWin(int l) { super(l); }
	
		public int fact_idx() { return 30; }
	
		@Override
		public void execute(Mafia ensem) { ensem.invokeActuator("notifymafiawin",Tuples.make_unit()); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = {  };
			return new SerializedFact(loc, 30, arguments);
		}
	
		public String toString() { return String.format("[%s]NotifyMafiaWin()",loc); }
	
	}
	
	public class NotifyCitizensWin extends MafiaFact {
		
	
		public NotifyCitizensWin(int l) { super(l); }
	
		public int fact_idx() { return 31; }
	
		@Override
		public void execute(Mafia ensem) { ensem.invokeActuator("notifycitizenswin",Tuples.make_unit()); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = {  };
			return new SerializedFact(loc, 31, arguments);
		}
	
		public String toString() { return String.format("[%s]NotifyCitizensWin()",loc); }
	
	}
	
	public class Delay extends MafiaFact {
		public int arg1;
	
		public Delay(int l, int a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 32; }
	
		@Override
		public void execute(Mafia ensem) { ensem.invokeActuator("delay",arg1); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 32, arguments);
		}
	
		public String toString() { return String.format("[%s]Delay(%s)",loc,arg1); }
	
	}
	
	public class Beep extends MafiaFact {
		public String arg1;
	
		public Beep(int l, String a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 33; }
	
		@Override
		public void execute(Mafia ensem) { ensem.invokeActuator("beep",arg1); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 33, arguments);
		}
	
		public String toString() { return String.format("[%s]Beep(%s)",loc,arg1); }
	
	}
	
	public class Toast extends MafiaFact {
		public String arg1;
	
		public Toast(int l, String a1) { super(l); arg1=a1; }
	
		public int fact_idx() { return 34; }
	
		@Override
		public void execute(Mafia ensem) { ensem.invokeActuator("toast",arg1); }
	
		@Override
		public void intro(Mafia ensem) { ensem.intro( this ); }
	
		@Override
		public SerializedFact serialize() {
			Serializable[] arguments = { (Serializable) arg1 };
			return new SerializedFact(loc, 34, arguments);
		}
	
		public String toString() { return String.format("[%s]Toast(%s)",loc,arg1); }
	
	}
	

	protected static int index0Start(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0Kill(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0MafiaChangedVote(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0CitizenChangedVote(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0Mark(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0Moderator(int loc, int arg1) {
		return Hash.join(Hash.hash(loc),Hash.hash(arg1));
	}
	protected static int index1Moderator(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0IsModerator(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0IsMafia(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0Duration(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0LivePlayers(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0AllPlayers(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0AllMafia(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0Trans(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0Cycle(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0CheckEnd(int loc) {
		return Hash.hash(loc);
	}

	protected static final int initialize_fact_idx = 0;
	protected static final int start_fact_idx = 1;
	protected static final int kill_fact_idx = 2;
	protected static final int mafiachangedvote_fact_idx = 3;
	protected static final int citizenchangedvote_fact_idx = 4;
	protected static final int mark_fact_idx = 5;
	protected static final int moderator_fact_idx = 6;
	protected static final int ismoderator_fact_idx = 7;
	protected static final int ismafia_fact_idx = 8;
	protected static final int iscitizen_fact_idx = 9;
	protected static final int duration_fact_idx = 10;
	protected static final int liveplayers_fact_idx = 11;
	protected static final int allplayers_fact_idx = 12;
	protected static final int allmafia_fact_idx = 13;
	protected static final int trans_fact_idx = 14;
	protected static final int cycle_fact_idx = 15;
	protected static final int checkvotes_fact_idx = 16;
	protected static final int checkend_fact_idx = 17;
	protected static final int notifymarked_fact_idx = 18;
	protected static final int notifyiscitizen_fact_idx = 19;
	protected static final int notifyismafia_fact_idx = 20;
	protected static final int notifymafiachangedvote_fact_idx = 21;
	protected static final int notifycitizenchangedvote_fact_idx = 22;
	protected static final int warnnight_fact_idx = 23;
	protected static final int warnday_fact_idx = 24;
	protected static final int signalnight_fact_idx = 25;
	protected static final int signalday_fact_idx = 26;
	protected static final int wakemafia_fact_idx = 27;
	protected static final int notifycheckvotes_fact_idx = 28;
	protected static final int notifydeath_fact_idx = 29;
	protected static final int notifymafiawin_fact_idx = 30;
	protected static final int notifycitizenswin_fact_idx = 31;
	protected static final int delay_fact_idx = 32;
	protected static final int beep_fact_idx = 33;
	protected static final int toast_fact_idx = 34;

	protected Goals<MafiaFact> goals;

	protected ListStore<Initialize> initialize_store_0;
	protected MultiMapStore<Start> start_store_0;
	protected ListStore<Start> start_store_1;
	protected MultiMapStore<Kill> kill_store_0;
	protected ListStore<Kill> kill_store_1;
	protected MultiMapStore<MafiaChangedVote> mafiachangedvote_store_0;
	protected ListStore<MafiaChangedVote> mafiachangedvote_store_1;
	protected MultiMapStore<CitizenChangedVote> citizenchangedvote_store_0;
	protected ListStore<CitizenChangedVote> citizenchangedvote_store_1;
	protected MultiMapStore<Mark> mark_store_0;
	protected ListStore<Mark> mark_store_1;
	protected MultiMapStore<Moderator> moderator_store_0;
	protected MultiMapStore<Moderator> moderator_store_1;
	protected ListStore<Moderator> moderator_store_2;
	protected MultiMapStore<IsModerator> ismoderator_store_0;
	protected ListStore<IsModerator> ismoderator_store_1;
	protected MultiMapStore<IsMafia> ismafia_store_0;
	protected ListStore<IsMafia> ismafia_store_1;
	protected ListStore<IsCitizen> iscitizen_store_0;
	protected MultiMapStore<Duration> duration_store_0;
	protected ListStore<Duration> duration_store_1;
	protected MultiMapStore<LivePlayers> liveplayers_store_0;
	protected ListStore<LivePlayers> liveplayers_store_1;
	protected MultiMapStore<AllPlayers> allplayers_store_0;
	protected ListStore<AllPlayers> allplayers_store_1;
	protected MultiMapStore<AllMafia> allmafia_store_0;
	protected ListStore<AllMafia> allmafia_store_1;
	protected MultiMapStore<Trans> trans_store_0;
	protected ListStore<Trans> trans_store_1;
	protected MultiMapStore<Cycle> cycle_store_0;
	protected ListStore<Cycle> cycle_store_1;
	protected ListStore<CheckVotes> checkvotes_store_0;
	protected MultiMapStore<CheckEnd> checkend_store_0;
	protected ListStore<CheckEnd> checkend_store_1;

	protected int initi_rule_count;
	protected int start_rule_count;
	protected int mvote_rule_count;
	protected int cvote_rule_count;
	protected int night_rule_count;
	protected int day_rule_count;
	protected int kill_rule_count;
	protected int marked_rule_count;
	protected int end1_rule_count;
	protected int end2_rule_count;
	protected int cont_rule_count;
	protected int rule_app_misses;

	public Mafia() {
		super();
	
		initi_rule_count = 0;
		start_rule_count = 0;
		mvote_rule_count = 0;
		cvote_rule_count = 0;
		night_rule_count = 0;
		day_rule_count = 0;
		kill_rule_count = 0;
		marked_rule_count = 0;
		end1_rule_count = 0;
		end2_rule_count = 0;
		cont_rule_count = 0;
		rule_app_misses = 0;
	
		goals = new ListGoals<MafiaFact>();
		set_goal_component( goals );
	
		initialize_store_0 = new ListStore<Initialize>();
		initialize_store_0.set_name("Initialize Store");
		// set_store_component( initialize_store_0 );
		
		start_store_0 = new MultiMapStore<Start>();
		start_store_0.set_name("Start Store");
		// set_store_component( start_store_0 );
		
		start_store_1 = new ListStore<Start>();
		start_store_1.set_name("Start Store");
		// set_store_component( start_store_1 );
		
		kill_store_0 = new MultiMapStore<Kill>();
		kill_store_0.set_name("Kill Store");
		// set_store_component( kill_store_0 );
		
		kill_store_1 = new ListStore<Kill>();
		kill_store_1.set_name("Kill Store");
		// set_store_component( kill_store_1 );
		
		mafiachangedvote_store_0 = new MultiMapStore<MafiaChangedVote>();
		mafiachangedvote_store_0.set_name("MafiaChangedVote Store");
		// set_store_component( mafiachangedvote_store_0 );
		
		mafiachangedvote_store_1 = new ListStore<MafiaChangedVote>();
		mafiachangedvote_store_1.set_name("MafiaChangedVote Store");
		// set_store_component( mafiachangedvote_store_1 );
		
		citizenchangedvote_store_0 = new MultiMapStore<CitizenChangedVote>();
		citizenchangedvote_store_0.set_name("CitizenChangedVote Store");
		// set_store_component( citizenchangedvote_store_0 );
		
		citizenchangedvote_store_1 = new ListStore<CitizenChangedVote>();
		citizenchangedvote_store_1.set_name("CitizenChangedVote Store");
		// set_store_component( citizenchangedvote_store_1 );
		
		mark_store_0 = new MultiMapStore<Mark>();
		mark_store_0.set_name("Mark Store");
		// set_store_component( mark_store_0 );
		
		mark_store_1 = new ListStore<Mark>();
		mark_store_1.set_name("Mark Store");
		// set_store_component( mark_store_1 );
		
		moderator_store_0 = new MultiMapStore<Moderator>();
		moderator_store_0.set_name("Moderator Store");
		// set_store_component( moderator_store_0 );
		
		moderator_store_1 = new MultiMapStore<Moderator>();
		moderator_store_1.set_name("Moderator Store");
		// set_store_component( moderator_store_1 );
		
		moderator_store_2 = new ListStore<Moderator>();
		moderator_store_2.set_name("Moderator Store");
		// set_store_component( moderator_store_2 );
		
		ismoderator_store_0 = new MultiMapStore<IsModerator>();
		ismoderator_store_0.set_name("IsModerator Store");
		// set_store_component( ismoderator_store_0 );
		
		ismoderator_store_1 = new ListStore<IsModerator>();
		ismoderator_store_1.set_name("IsModerator Store");
		// set_store_component( ismoderator_store_1 );
		
		ismafia_store_0 = new MultiMapStore<IsMafia>();
		ismafia_store_0.set_name("IsMafia Store");
		// set_store_component( ismafia_store_0 );
		
		ismafia_store_1 = new ListStore<IsMafia>();
		ismafia_store_1.set_name("IsMafia Store");
		// set_store_component( ismafia_store_1 );
		
		iscitizen_store_0 = new ListStore<IsCitizen>();
		iscitizen_store_0.set_name("IsCitizen Store");
		// set_store_component( iscitizen_store_0 );
		
		duration_store_0 = new MultiMapStore<Duration>();
		duration_store_0.set_name("Duration Store");
		// set_store_component( duration_store_0 );
		
		duration_store_1 = new ListStore<Duration>();
		duration_store_1.set_name("Duration Store");
		// set_store_component( duration_store_1 );
		
		liveplayers_store_0 = new MultiMapStore<LivePlayers>();
		liveplayers_store_0.set_name("LivePlayers Store");
		// set_store_component( liveplayers_store_0 );
		
		liveplayers_store_1 = new ListStore<LivePlayers>();
		liveplayers_store_1.set_name("LivePlayers Store");
		// set_store_component( liveplayers_store_1 );
		
		allplayers_store_0 = new MultiMapStore<AllPlayers>();
		allplayers_store_0.set_name("AllPlayers Store");
		// set_store_component( allplayers_store_0 );
		
		allplayers_store_1 = new ListStore<AllPlayers>();
		allplayers_store_1.set_name("AllPlayers Store");
		// set_store_component( allplayers_store_1 );
		
		allmafia_store_0 = new MultiMapStore<AllMafia>();
		allmafia_store_0.set_name("AllMafia Store");
		// set_store_component( allmafia_store_0 );
		
		allmafia_store_1 = new ListStore<AllMafia>();
		allmafia_store_1.set_name("AllMafia Store");
		// set_store_component( allmafia_store_1 );
		
		trans_store_0 = new MultiMapStore<Trans>();
		trans_store_0.set_name("Trans Store");
		// set_store_component( trans_store_0 );
		
		trans_store_1 = new ListStore<Trans>();
		trans_store_1.set_name("Trans Store");
		// set_store_component( trans_store_1 );
		
		cycle_store_0 = new MultiMapStore<Cycle>();
		cycle_store_0.set_name("Cycle Store");
		// set_store_component( cycle_store_0 );
		
		cycle_store_1 = new ListStore<Cycle>();
		cycle_store_1.set_name("Cycle Store");
		// set_store_component( cycle_store_1 );
		
		checkvotes_store_0 = new ListStore<CheckVotes>();
		checkvotes_store_0.set_name("CheckVotes Store");
		// set_store_component( checkvotes_store_0 );
		
		checkend_store_0 = new MultiMapStore<CheckEnd>();
		checkend_store_0.set_name("CheckEnd Store");
		// set_store_component( checkend_store_0 );
		
		checkend_store_1 = new ListStore<CheckEnd>();
		checkend_store_1.set_name("CheckEnd Store");
		// set_store_component( checkend_store_1 );
		
	
		set_store_component( initialize_store_0 );
		set_store_component( start_store_1 );
		set_store_component( kill_store_1 );
		set_store_component( mafiachangedvote_store_1 );
		set_store_component( citizenchangedvote_store_1 );
		set_store_component( mark_store_1 );
		set_store_component( moderator_store_2 );
		set_store_component( ismoderator_store_1 );
		set_store_component( ismafia_store_1 );
		set_store_component( iscitizen_store_0 );
		set_store_component( duration_store_1 );
		set_store_component( liveplayers_store_1 );
		set_store_component( allplayers_store_1 );
		set_store_component( allmafia_store_1 );
		set_store_component( trans_store_1 );
		set_store_component( cycle_store_1 );
		set_store_component( checkvotes_store_0 );
		set_store_component( checkend_store_1 );
	}
	

	@Override
	protected boolean rewrite() {
		boolean done_something = false;
		while(goals.has_goals()) {
			goals.next().execute( this );
			done_something = true;
		}
		return done_something;
	}
	
	@Override
	protected boolean rewrite(int max_steps) {
		int count = 0;
		while(goals.has_goals() && count < max_steps) {
			goals.next().execute( this );
			count++;
		}
		return count > 0;
	}

	protected MafiaFact demultiplex(SerializedFact fact) {
		Serializable[] args = fact.arguments;
		switch(fact.fact_idx) {
			case 0: return new Initialize(fact.loc,(SimpMultiset<Integer> ) args[0],(Integer) args[1]);
			
			case 1: return new Start(fact.loc);
			
			case 2: return new Kill(fact.loc,(Integer) args[0]);
			
			case 3: return new MafiaChangedVote(fact.loc,(Integer) args[0]);
			
			case 4: return new CitizenChangedVote(fact.loc,(Integer) args[0]);
			
			case 5: return new Mark(fact.loc,(Integer) args[0]);
			
			case 6: return new Moderator(fact.loc,(Integer) args[0]);
			
			case 7: return new IsModerator(fact.loc);
			
			case 8: return new IsMafia(fact.loc);
			
			case 9: return new IsCitizen(fact.loc);
			
			case 10: return new Duration(fact.loc,(Integer) args[0]);
			
			case 11: return new LivePlayers(fact.loc,(SimpMultiset<Integer> ) args[0],(SimpMultiset<Integer> ) args[1]);
			
			case 12: return new AllPlayers(fact.loc,(SimpMultiset<Integer> ) args[0]);
			
			case 13: return new AllMafia(fact.loc,(SimpMultiset<Integer> ) args[0]);
			
			case 14: return new Trans(fact.loc,(Boolean) args[0],(Boolean) args[1]);
			
			case 15: return new Cycle(fact.loc,(Boolean) args[0]);
			
			case 16: return new CheckVotes(fact.loc,(SimpMultiset<Integer> ) args[0]);
			
			case 17: return new CheckEnd(fact.loc);
			
			case 18: return new NotifyMarked(fact.loc);
			
			case 19: return new NotifyIsCitizen(fact.loc);
			
			case 20: return new NotifyIsMafia(fact.loc,(SimpMultiset<Integer> ) args[0]);
			
			case 21: return new NotifyMafiaChangedVote(fact.loc,(Integer) args[0],(Integer) args[1]);
			
			case 22: return new NotifyCitizenChangedVote(fact.loc,(Integer) args[0],(Integer) args[1]);
			
			case 23: return new WarnNight(fact.loc,(Long) args[0]);
			
			case 24: return new WarnDay(fact.loc,(Long) args[0]);
			
			case 25: return new SignalNight(fact.loc,(Long) args[0]);
			
			case 26: return new SignalDay(fact.loc,(Long) args[0]);
			
			case 27: return new WakeMafia(fact.loc,(Long) args[0]);
			
			case 28: return new NotifyCheckVotes(fact.loc,(SimpMultiset<Integer> ) args[0],(Long) args[1],(Boolean) args[2]);
			
			case 29: return new NotifyDeath(fact.loc,(Integer) args[0]);
			
			case 30: return new NotifyMafiaWin(fact.loc);
			
			case 31: return new NotifyCitizensWin(fact.loc);
			
			case 32: return new Delay(fact.loc,(Integer) args[0]);
			
			case 33: return new Beep(fact.loc,(String) args[0]);
			
			case 34: return new Toast(fact.loc,(String) args[0]);
			
		}
		return null;
	}
	
	
	@Override
	protected synchronized boolean flushGoals() {
		if (external_goals.size() == 0) { return false; }
		for (SerializedFact new_goal : external_goals) {
			MafiaFact ef_goal = demultiplex( new_goal );
			ef_goal.intro( this ) ;
		}
		external_goals.clear();
		return true;
	}
	
	protected void store(Initialize initialize) {
		initialize_store_0.add( initialize );
	} 				
	
	protected void store(Start start) {
		start_store_0.add( start, index0Start(start.loc) );
		start_store_1.add( start );
	} 				
	
	protected void store(Kill kill) {
		kill_store_0.add( kill, index0Kill(kill.loc) );
		kill_store_1.add( kill );
	} 				
	
	protected void store(MafiaChangedVote mafiachangedvote) {
		mafiachangedvote_store_0.add( mafiachangedvote, index0MafiaChangedVote(mafiachangedvote.loc) );
		mafiachangedvote_store_1.add( mafiachangedvote );
	} 				
	
	protected void store(CitizenChangedVote citizenchangedvote) {
		citizenchangedvote_store_0.add( citizenchangedvote, index0CitizenChangedVote(citizenchangedvote.loc) );
		citizenchangedvote_store_1.add( citizenchangedvote );
	} 				
	
	protected void store(Mark mark) {
		mark_store_0.add( mark, index0Mark(mark.loc) );
		mark_store_1.add( mark );
	} 				
	
	protected void store(Moderator moderator) {
		moderator_store_0.add( moderator, index0Moderator(moderator.loc,moderator.arg1) );
		moderator_store_1.add( moderator, index1Moderator(moderator.loc) );
		moderator_store_2.add( moderator );
	} 				
	
	protected void store(IsModerator ismoderator) {
		ismoderator_store_0.add( ismoderator, index0IsModerator(ismoderator.loc) );
		ismoderator_store_1.add( ismoderator );
	} 				
	
	protected void store(IsMafia ismafia) {
		ismafia_store_0.add( ismafia, index0IsMafia(ismafia.loc) );
		ismafia_store_1.add( ismafia );
	} 				
	
	protected void store(IsCitizen iscitizen) {
		iscitizen_store_0.add( iscitizen );
	} 				
	
	protected void store(Duration duration) {
		duration_store_0.add( duration, index0Duration(duration.loc) );
		duration_store_1.add( duration );
	} 				
	
	protected void store(LivePlayers liveplayers) {
		liveplayers_store_0.add( liveplayers, index0LivePlayers(liveplayers.loc) );
		liveplayers_store_1.add( liveplayers );
	} 				
	
	protected void store(AllPlayers allplayers) {
		allplayers_store_0.add( allplayers, index0AllPlayers(allplayers.loc) );
		allplayers_store_1.add( allplayers );
	} 				
	
	protected void store(AllMafia allmafia) {
		allmafia_store_0.add( allmafia, index0AllMafia(allmafia.loc) );
		allmafia_store_1.add( allmafia );
	} 				
	
	protected void store(Trans trans) {
		trans_store_0.add( trans, index0Trans(trans.loc) );
		trans_store_1.add( trans );
	} 				
	
	protected void store(Cycle cycle) {
		cycle_store_0.add( cycle, index0Cycle(cycle.loc) );
		cycle_store_1.add( cycle );
	} 				
	
	protected void store(CheckVotes checkvotes) {
		checkvotes_store_0.add( checkvotes );
	} 				
	
	protected void store(CheckEnd checkend) {
		checkend_store_0.add( checkend, index0CheckEnd(checkend.loc) );
		checkend_store_1.add( checkend );
	} 				
	
	protected void store(NotifyMarked notifymarked) {
		
	} 				
	
	protected void store(NotifyIsCitizen notifyiscitizen) {
		
	} 				
	
	protected void store(NotifyIsMafia notifyismafia) {
		
	} 				
	
	protected void store(NotifyMafiaChangedVote notifymafiachangedvote) {
		
	} 				
	
	protected void store(NotifyCitizenChangedVote notifycitizenchangedvote) {
		
	} 				
	
	protected void store(WarnNight warnnight) {
		
	} 				
	
	protected void store(WarnDay warnday) {
		
	} 				
	
	protected void store(SignalNight signalnight) {
		
	} 				
	
	protected void store(SignalDay signalday) {
		
	} 				
	
	protected void store(WakeMafia wakemafia) {
		
	} 				
	
	protected void store(NotifyCheckVotes notifycheckvotes) {
		
	} 				
	
	protected void store(NotifyDeath notifydeath) {
		
	} 				
	
	protected void store(NotifyMafiaWin notifymafiawin) {
		
	} 				
	
	protected void store(NotifyCitizensWin notifycitizenswin) {
		
	} 				
	
	protected void store(Delay delay) {
		
	} 				
	
	protected void store(Beep beep) {
		
	} 				
	
	protected void store(Toast toast) {
		
	} 				
	
	public void add_initialize(int loc,SimpMultiset<Integer>  arg1,int arg2) {
		if (isSolo || location == loc) {
			intro( new Initialize(loc,arg1,arg2) );
		}
	}
	
	public void add_start(int loc) {
		if (isSolo || location == loc) {
			intro( new Start(loc) );
		}
	}
	
	public void add_kill(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new Kill(loc,arg1) );
		}
	}
	
	public void add_mafiachangedvote(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new MafiaChangedVote(loc,arg1) );
		}
	}
	
	public void add_citizenchangedvote(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new CitizenChangedVote(loc,arg1) );
		}
	}
	
	public void add_mark(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new Mark(loc,arg1) );
		}
	}
	
	public void add_moderator(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new Moderator(loc,arg1) );
		}
	}
	
	public void add_ismoderator(int loc) {
		if (isSolo || location == loc) {
			intro( new IsModerator(loc) );
		}
	}
	
	public void add_ismafia(int loc) {
		if (isSolo || location == loc) {
			intro( new IsMafia(loc) );
		}
	}
	
	public void add_iscitizen(int loc) {
		if (isSolo || location == loc) {
			intro( new IsCitizen(loc) );
		}
	}
	
	public void add_duration(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new Duration(loc,arg1) );
		}
	}
	
	public void add_liveplayers(int loc,SimpMultiset<Integer>  arg1,SimpMultiset<Integer>  arg2) {
		if (isSolo || location == loc) {
			intro( new LivePlayers(loc,arg1,arg2) );
		}
	}
	
	public void add_allplayers(int loc,SimpMultiset<Integer>  arg1) {
		if (isSolo || location == loc) {
			intro( new AllPlayers(loc,arg1) );
		}
	}
	
	public void add_allmafia(int loc,SimpMultiset<Integer>  arg1) {
		if (isSolo || location == loc) {
			intro( new AllMafia(loc,arg1) );
		}
	}
	
	public void add_trans(int loc,boolean arg1,boolean arg2) {
		if (isSolo || location == loc) {
			intro( new Trans(loc,arg1,arg2) );
		}
	}
	
	public void add_cycle(int loc,boolean arg1) {
		if (isSolo || location == loc) {
			intro( new Cycle(loc,arg1) );
		}
	}
	
	public void add_checkvotes(int loc,SimpMultiset<Integer>  arg1) {
		if (isSolo || location == loc) {
			intro( new CheckVotes(loc,arg1) );
		}
	}
	
	public void add_checkend(int loc) {
		if (isSolo || location == loc) {
			intro( new CheckEnd(loc) );
		}
	}
	
	public void add_notifymarked(int loc) {
		if (isSolo || location == loc) {
			intro( new NotifyMarked(loc) );
		}
	}
	
	public void add_notifyiscitizen(int loc) {
		if (isSolo || location == loc) {
			intro( new NotifyIsCitizen(loc) );
		}
	}
	
	public void add_notifyismafia(int loc,SimpMultiset<Integer>  arg1) {
		if (isSolo || location == loc) {
			intro( new NotifyIsMafia(loc,arg1) );
		}
	}
	
	public void add_notifymafiachangedvote(int loc,int arg1,int arg2) {
		if (isSolo || location == loc) {
			intro( new NotifyMafiaChangedVote(loc,arg1,arg2) );
		}
	}
	
	public void add_notifycitizenchangedvote(int loc,int arg1,int arg2) {
		if (isSolo || location == loc) {
			intro( new NotifyCitizenChangedVote(loc,arg1,arg2) );
		}
	}
	
	public void add_warnnight(int loc,long arg1) {
		if (isSolo || location == loc) {
			intro( new WarnNight(loc,arg1) );
		}
	}
	
	public void add_warnday(int loc,long arg1) {
		if (isSolo || location == loc) {
			intro( new WarnDay(loc,arg1) );
		}
	}
	
	public void add_signalnight(int loc,long arg1) {
		if (isSolo || location == loc) {
			intro( new SignalNight(loc,arg1) );
		}
	}
	
	public void add_signalday(int loc,long arg1) {
		if (isSolo || location == loc) {
			intro( new SignalDay(loc,arg1) );
		}
	}
	
	public void add_wakemafia(int loc,long arg1) {
		if (isSolo || location == loc) {
			intro( new WakeMafia(loc,arg1) );
		}
	}
	
	public void add_notifycheckvotes(int loc,SimpMultiset<Integer>  arg1,long arg2,boolean arg3) {
		if (isSolo || location == loc) {
			intro( new NotifyCheckVotes(loc,arg1,arg2,arg3) );
		}
	}
	
	public void add_notifydeath(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new NotifyDeath(loc,arg1) );
		}
	}
	
	public void add_notifymafiawin(int loc) {
		if (isSolo || location == loc) {
			intro( new NotifyMafiaWin(loc) );
		}
	}
	
	public void add_notifycitizenswin(int loc) {
		if (isSolo || location == loc) {
			intro( new NotifyCitizensWin(loc) );
		}
	}
	
	public void add_delay(int loc,int arg1) {
		if (isSolo || location == loc) {
			intro( new Delay(loc,arg1) );
		}
	}
	
	public void add_beep(int loc,String arg1) {
		if (isSolo || location == loc) {
			intro( new Beep(loc,arg1) );
		}
	}
	
	public void add_toast(int loc,String arg1) {
		if (isSolo || location == loc) {
			intro( new Toast(loc,arg1) );
		}
	}
	
	protected void intro(Initialize initialize) {
		goals.add( initialize );
		notify_new_goals();
	}
	
	protected void intro(Start start) {
		goals.add( start );
		notify_new_goals();
	}
	
	protected void intro(Kill kill) {
		goals.add( kill );
		notify_new_goals();
	}
	
	protected void intro(MafiaChangedVote mafiachangedvote) {
		goals.add( mafiachangedvote );
		notify_new_goals();
	}
	
	protected void intro(CitizenChangedVote citizenchangedvote) {
		goals.add( citizenchangedvote );
		notify_new_goals();
	}
	
	protected void intro(Mark mark) {
		goals.add( mark );
		notify_new_goals();
	}
	
	protected void intro(Moderator moderator) {
		goals.add( moderator );
		notify_new_goals();
	}
	
	protected void intro(IsModerator ismoderator) {
		goals.add( ismoderator );
		notify_new_goals();
	}
	
	protected void intro(IsMafia ismafia) {
		goals.add( ismafia );
		notify_new_goals();
	}
	
	protected void intro(IsCitizen iscitizen) {
		goals.add( iscitizen );
		notify_new_goals();
	}
	
	protected void intro(Duration duration) {
		goals.add( duration );
		notify_new_goals();
	}
	
	protected void intro(LivePlayers liveplayers) {
		goals.add( liveplayers );
		notify_new_goals();
	}
	
	protected void intro(AllPlayers allplayers) {
		goals.add( allplayers );
		notify_new_goals();
	}
	
	protected void intro(AllMafia allmafia) {
		goals.add( allmafia );
		notify_new_goals();
	}
	
	protected void intro(Trans trans) {
		goals.add( trans );
		notify_new_goals();
	}
	
	protected void intro(Cycle cycle) {
		goals.add( cycle );
		notify_new_goals();
	}
	
	protected void intro(CheckVotes checkvotes) {
		goals.add( checkvotes );
		notify_new_goals();
	}
	
	protected void intro(CheckEnd checkend) {
		goals.add( checkend );
		notify_new_goals();
	}
	
	protected void intro(NotifyMarked notifymarked) {
		goals.add( notifymarked );
		notify_new_goals();
	}
	
	protected void intro(NotifyIsCitizen notifyiscitizen) {
		goals.add( notifyiscitizen );
		notify_new_goals();
	}
	
	protected void intro(NotifyIsMafia notifyismafia) {
		goals.add( notifyismafia );
		notify_new_goals();
	}
	
	protected void intro(NotifyMafiaChangedVote notifymafiachangedvote) {
		goals.add( notifymafiachangedvote );
		notify_new_goals();
	}
	
	protected void intro(NotifyCitizenChangedVote notifycitizenchangedvote) {
		goals.add( notifycitizenchangedvote );
		notify_new_goals();
	}
	
	protected void intro(WarnNight warnnight) {
		goals.add( warnnight );
		notify_new_goals();
	}
	
	protected void intro(WarnDay warnday) {
		goals.add( warnday );
		notify_new_goals();
	}
	
	protected void intro(SignalNight signalnight) {
		goals.add( signalnight );
		notify_new_goals();
	}
	
	protected void intro(SignalDay signalday) {
		goals.add( signalday );
		notify_new_goals();
	}
	
	protected void intro(WakeMafia wakemafia) {
		goals.add( wakemafia );
		notify_new_goals();
	}
	
	protected void intro(NotifyCheckVotes notifycheckvotes) {
		goals.add( notifycheckvotes );
		notify_new_goals();
	}
	
	protected void intro(NotifyDeath notifydeath) {
		goals.add( notifydeath );
		notify_new_goals();
	}
	
	protected void intro(NotifyMafiaWin notifymafiawin) {
		goals.add( notifymafiawin );
		notify_new_goals();
	}
	
	protected void intro(NotifyCitizensWin notifycitizenswin) {
		goals.add( notifycitizenswin );
		notify_new_goals();
	}
	
	protected void intro(Delay delay) {
		goals.add( delay );
		store( delay );
		notify_new_goals();
	}	
	
	protected void intro(Beep beep) {
		goals.add( beep );
		store( beep );
		notify_new_goals();
	}	
	
	protected void intro(Toast toast) {
		goals.add( toast );
		store( toast );
		notify_new_goals();
	}	
	
	protected void send(Initialize initialize) {
		if(location == initialize.get_loc()) {
			intro(initialize);
		} else {
			send_buffers.add(initialize);
		}
	}
	
	protected void send(Start start) {
		if(location == start.get_loc()) {
			intro(start);
		} else {
			send_buffers.add(start);
		}
	}
	
	protected void send(Kill kill) {
		if(location == kill.get_loc()) {
			intro(kill);
		} else {
			send_buffers.add(kill);
		}
	}
	
	protected void send(MafiaChangedVote mafiachangedvote) {
		if(location == mafiachangedvote.get_loc()) {
			intro(mafiachangedvote);
		} else {
			send_buffers.add(mafiachangedvote);
		}
	}
	
	protected void send(CitizenChangedVote citizenchangedvote) {
		if(location == citizenchangedvote.get_loc()) {
			intro(citizenchangedvote);
		} else {
			send_buffers.add(citizenchangedvote);
		}
	}
	
	protected void send(Mark mark) {
		if(location == mark.get_loc()) {
			intro(mark);
		} else {
			send_buffers.add(mark);
		}
	}
	
	protected void send(Moderator moderator) {
		if(location == moderator.get_loc()) {
			intro(moderator);
		} else {
			send_buffers.add(moderator);
		}
	}
	
	protected void send(IsModerator ismoderator) {
		if(location == ismoderator.get_loc()) {
			intro(ismoderator);
		} else {
			send_buffers.add(ismoderator);
		}
	}
	
	protected void send(IsMafia ismafia) {
		if(location == ismafia.get_loc()) {
			intro(ismafia);
		} else {
			send_buffers.add(ismafia);
		}
	}
	
	protected void send(IsCitizen iscitizen) {
		if(location == iscitizen.get_loc()) {
			intro(iscitizen);
		} else {
			send_buffers.add(iscitizen);
		}
	}
	
	protected void send(Duration duration) {
		if(location == duration.get_loc()) {
			intro(duration);
		} else {
			send_buffers.add(duration);
		}
	}
	
	protected void send(LivePlayers liveplayers) {
		if(location == liveplayers.get_loc()) {
			intro(liveplayers);
		} else {
			send_buffers.add(liveplayers);
		}
	}
	
	protected void send(AllPlayers allplayers) {
		if(location == allplayers.get_loc()) {
			intro(allplayers);
		} else {
			send_buffers.add(allplayers);
		}
	}
	
	protected void send(AllMafia allmafia) {
		if(location == allmafia.get_loc()) {
			intro(allmafia);
		} else {
			send_buffers.add(allmafia);
		}
	}
	
	protected void send(Trans trans) {
		if(location == trans.get_loc()) {
			intro(trans);
		} else {
			send_buffers.add(trans);
		}
	}
	
	protected void send(Cycle cycle) {
		if(location == cycle.get_loc()) {
			intro(cycle);
		} else {
			send_buffers.add(cycle);
		}
	}
	
	protected void send(CheckVotes checkvotes) {
		if(location == checkvotes.get_loc()) {
			intro(checkvotes);
		} else {
			send_buffers.add(checkvotes);
		}
	}
	
	protected void send(CheckEnd checkend) {
		if(location == checkend.get_loc()) {
			intro(checkend);
		} else {
			send_buffers.add(checkend);
		}
	}
	
	protected void send(NotifyMarked notifymarked) {
		if(location == notifymarked.get_loc()) {
			intro(notifymarked);
		} else {
			send_buffers.add(notifymarked);
		}
	}
	
	protected void send(NotifyIsCitizen notifyiscitizen) {
		if(location == notifyiscitizen.get_loc()) {
			intro(notifyiscitizen);
		} else {
			send_buffers.add(notifyiscitizen);
		}
	}
	
	protected void send(NotifyIsMafia notifyismafia) {
		if(location == notifyismafia.get_loc()) {
			intro(notifyismafia);
		} else {
			send_buffers.add(notifyismafia);
		}
	}
	
	protected void send(NotifyMafiaChangedVote notifymafiachangedvote) {
		if(location == notifymafiachangedvote.get_loc()) {
			intro(notifymafiachangedvote);
		} else {
			send_buffers.add(notifymafiachangedvote);
		}
	}
	
	protected void send(NotifyCitizenChangedVote notifycitizenchangedvote) {
		if(location == notifycitizenchangedvote.get_loc()) {
			intro(notifycitizenchangedvote);
		} else {
			send_buffers.add(notifycitizenchangedvote);
		}
	}
	
	protected void send(WarnNight warnnight) {
		if(location == warnnight.get_loc()) {
			intro(warnnight);
		} else {
			send_buffers.add(warnnight);
		}
	}
	
	protected void send(WarnDay warnday) {
		if(location == warnday.get_loc()) {
			intro(warnday);
		} else {
			send_buffers.add(warnday);
		}
	}
	
	protected void send(SignalNight signalnight) {
		if(location == signalnight.get_loc()) {
			intro(signalnight);
		} else {
			send_buffers.add(signalnight);
		}
	}
	
	protected void send(SignalDay signalday) {
		if(location == signalday.get_loc()) {
			intro(signalday);
		} else {
			send_buffers.add(signalday);
		}
	}
	
	protected void send(WakeMafia wakemafia) {
		if(location == wakemafia.get_loc()) {
			intro(wakemafia);
		} else {
			send_buffers.add(wakemafia);
		}
	}
	
	protected void send(NotifyCheckVotes notifycheckvotes) {
		if(location == notifycheckvotes.get_loc()) {
			intro(notifycheckvotes);
		} else {
			send_buffers.add(notifycheckvotes);
		}
	}
	
	protected void send(NotifyDeath notifydeath) {
		if(location == notifydeath.get_loc()) {
			intro(notifydeath);
		} else {
			send_buffers.add(notifydeath);
		}
	}
	
	protected void send(NotifyMafiaWin notifymafiawin) {
		if(location == notifymafiawin.get_loc()) {
			intro(notifymafiawin);
		} else {
			send_buffers.add(notifymafiawin);
		}
	}
	
	protected void send(NotifyCitizensWin notifycitizenswin) {
		if(location == notifycitizenswin.get_loc()) {
			intro(notifycitizenswin);
		} else {
			send_buffers.add(notifycitizenswin);
		}
	}
	
	protected void send(Delay delay) {
		if(location == delay.get_loc()) {
			intro(delay);
		} else {
			send_buffers.add(delay);
		}
	}
	
	protected void send(Beep beep) {
		if(location == beep.get_loc()) {
			intro(beep);
		} else {
			send_buffers.add(beep);
		}
	}
	
	protected void send(Toast toast) {
		if(location == toast.get_loc()) {
			intro(toast);
		} else {
			send_buffers.add(toast);
		}
	}
	
	

	public void addInitialize(SimpMultiset<Integer>  arg1,int arg2) {
		intro( new Initialize(location,arg1,arg2) );
	}
	
	public void addStart() {
		intro( new Start(location) );
	}
	
	public void addKill(int arg1) {
		intro( new Kill(location,arg1) );
	}
	
	public void addMafiaChangedVote(int arg1) {
		intro( new MafiaChangedVote(location,arg1) );
	}
	
	public void addCitizenChangedVote(int arg1) {
		intro( new CitizenChangedVote(location,arg1) );
	}
	
	public void addMark(int arg1) {
		intro( new Mark(location,arg1) );
	}
	

	public void setNotifyMarkedActuator(ActuatorAction<Unit> action) {
		setActuator("notifymarked", action);
	}
	
	public void setNotifyIsCitizenActuator(ActuatorAction<Unit> action) {
		setActuator("notifyiscitizen", action);
	}
	
	public void setNotifyIsMafiaActuator(ActuatorAction<SimpMultiset<Integer> > action) {
		setActuator("notifyismafia", action);
	}
	
	public void setNotifyMafiaChangedVoteActuator(ActuatorAction<Tuple2<Integer,Integer>> action) {
		setActuator("notifymafiachangedvote", action);
	}
	
	public void setNotifyCitizenChangedVoteActuator(ActuatorAction<Tuple2<Integer,Integer>> action) {
		setActuator("notifycitizenchangedvote", action);
	}
	
	public void setWarnNightActuator(ActuatorAction<Long> action) {
		setActuator("warnnight", action);
	}
	
	public void setWarnDayActuator(ActuatorAction<Long> action) {
		setActuator("warnday", action);
	}
	
	public void setSignalNightActuator(ActuatorAction<Long> action) {
		setActuator("signalnight", action);
	}
	
	public void setSignalDayActuator(ActuatorAction<Long> action) {
		setActuator("signalday", action);
	}
	
	public void setWakeMafiaActuator(ActuatorAction<Long> action) {
		setActuator("wakemafia", action);
	}
	
	public void setNotifyCheckVotesActuator(ActuatorAction<Tuple3<SimpMultiset<Integer> ,Long,Boolean>> action) {
		setActuator("notifycheckvotes", action);
	}
	
	public void setNotifyDeathActuator(ActuatorAction<Integer> action) {
		setActuator("notifydeath", action);
	}
	
	public void setNotifyMafiaWinActuator(ActuatorAction<Unit> action) {
		setActuator("notifymafiawin", action);
	}
	
	public void setNotifyCitizensWinActuator(ActuatorAction<Unit> action) {
		setActuator("notifycitizenswin", action);
	}
	
	public void setDelayActuator(ActuatorAction<Integer> action) {
		setActuator("delay", action);
	}
	
	public void setBeepActuator(ActuatorAction<String> action) {
		setActuator("beep", action);
	}
	
	public void setToastActuator(ActuatorAction<String> action) {
		setActuator("toast", action);
	}
	

	

	

	public ConcListStore[] getLinearStores() {
		ConcListStore[] stores = new ConcListStore[0];
		
		return stores;
	}
	

	/*
	**** 0 Join Ordering of Rule initi ****
	Rule Head Variables: (I::0), (Ps::1), (D::2)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]initialize((Ps::1),(D::2))
	DeleteHead #H0
	LetBind (Ms::3) pick(((Ps::1),size((Ps::1)) / 3))
	LetBind (Cs::4) diff(((Ps::1),(Ms::3)))
	IntroAtom Local NoPrior Mono [(I::0)]duration((D::2))
	IntroAtom Local NoPrior Mono [(I::0)]livePlayers((Cs::4),(Ms::3))
	IntroAtom Local NoPrior Mono [(I::0)]isModerator()
	IntroCompre Remote NoPrior Mono (P::5) (Ps::1) [(P::5)]allPlayers((Ps::1))
	IntroCompre Remote NoPrior Mono (C::6) (Cs::4) [(C::6)]notifyIsCitizen()
	IntroCompre Remote NoPrior Mono (M::7) (Ms::3) [(M::7)]notifyIsMafia((Ms::3))
	*/
	protected boolean execute_initialize_join_ordering_1(Initialize act) {
		
		int i;
		SimpMultiset<Integer>  ps;
		int d;
		SimpMultiset<Integer>  ms;
		SimpMultiset<Integer>  cs;
		int p;
		int c;
		int m;
		// Join Task: Active #H0 [(I::0)]initialize((Ps::1),(D::2))
		i = act.loc;
		ps = act.arg1;
		d = act.arg2;
		// Join Task: DeleteHead #H0
		// H0 is active and monotone, no delete required
		// Join Task: LetBind (Ms::3) pick(((Ps::1),size((Ps::1)) / 3))
		ms = ExtLib.pick(ps,ExtLib.size(ps) / 3);
		;
		// Join Task: LetBind (Cs::4) diff(((Ps::1),(Ms::3)))
		cs = ExtLib.diff(ps,ms);
		;
		// Join Task: IntroAtom Local NoPrior Mono [(I::0)]duration((D::2))
		intro( new Duration(i,d) );
		// Join Task: IntroAtom Local NoPrior Mono [(I::0)]livePlayers((Cs::4),(Ms::3))
		intro( new LivePlayers(i,cs,ms) );
		// Join Task: IntroAtom Local NoPrior Mono [(I::0)]isModerator()
		intro( new IsModerator(i) );
		// Join Task: IntroCompre Remote NoPrior Mono (P::5) (Ps::1) [(P::5)]allPlayers((Ps::1))
		SimpMultiset<Integer>  comp_0 = ps;
		for(int idx=0; idx<comp_0.size(); idx++) {
			p = comp_0.get(idx);
			send( new AllPlayers(p,ps) ); 
			send( new Moderator(p,i) ); 
		}
		// Join Task: IntroCompre Remote NoPrior Mono (C::6) (Cs::4) [(C::6)]notifyIsCitizen()
		SimpMultiset<Integer>  comp_1 = cs;
		for(int idx=0; idx<comp_1.size(); idx++) {
			c = comp_1.get(idx);
			send( new NotifyIsCitizen(c) ); 
			send( new IsCitizen(c) ); 
		}
		// Join Task: IntroCompre Remote NoPrior Mono (M::7) (Ms::3) [(M::7)]notifyIsMafia((Ms::3))
		SimpMultiset<Integer>  comp_2 = ms;
		for(int idx=0; idx<comp_2.size(); idx++) {
			m = comp_2.get(idx);
			send( new NotifyIsMafia(m,ms) ); 
			send( new IsMafia(m) ); 
			send( new AllMafia(m,ms) ); 
		}
		initi_rule_count++;
		return false;
		
	}
	
	/*
	**** 0 Join Ordering of Rule start ****
	Rule Head Variables: (I::0)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]start()
	LookupAtom #H1 6:0:hash<[+]moderator(+)|.>  (I::0),(I::0) [(I::0)]moderator((I::0))
	DeleteHead #H0
	LetBind (Night::1) true
	LetBind (IsFirst::2) true
	IntroAtom Local NoPrior Mono [(I::0)]trans((Night::1),(IsFirst::2))
	IntroAtom Local NoPrior Mono [(I::0)]cycle((Night::1))
	*/
	protected boolean execute_start_join_ordering_1(Start act) {
		
		int i;
		boolean night;
		boolean isfirst;
		// Join Task: Active #H0 [(I::0)]start()
		i = act.loc;
		// Join Task: LookupAtom #H1 6:0:hash<[+]moderator(+)|.>  (I::0),(I::0) [(I::0)]moderator((I::0))
		StoreIter<Moderator> candidates_1 = moderator_store_0.lookup_candidates(index0Moderator(i,i));
		Moderator cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int i__1;
			i__1 = cand_1.loc;
			i__1 = cand_1.arg1;
			if (Equality.is_eq(i,i__1)) {
				// Join Task: DeleteHead #H0
				// H0 is active and monotone, no delete required
				// Join Task: LetBind (Night::1) true
				night = true;
				;
				// Join Task: LetBind (IsFirst::2) true
				isfirst = true;
				;
				// Join Task: IntroAtom Local NoPrior Mono [(I::0)]trans((Night::1),(IsFirst::2))
				intro( new Trans(i,night,isfirst) );
				// Join Task: IntroAtom Local NoPrior Mono [(I::0)]cycle((Night::1))
				intro( new Cycle(i,night) );
				start_rule_count++;
				return false;
			} else {
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule kill ****
	Rule Head Variables: (I::0), (Ps::1), (K::2), (Cs::3), (Ms::4)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]kill((K::2))
	LookupAtom #H1 7:0:hash<[+]isModerator()|.>  (I::0) [(I::0)]isModerator()
	LookupAtom #H2 12:0:hash<[+]allPlayers(-)|.>  (I::0) [(I::0)]allPlayers((Ps::1))
	LookupAtom #H3 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::3),(Ms::4))
	DeleteHead #H0
	DeleteHead #H3
	LetBind (Lvar1::5) diff(((Cs::3),{(K::2)}))
	LetBind (Lvar2::6) diff(((Ms::4),{(K::2)}))
	IntroAtom Local NoPrior Mono [(I::0)]livePlayers((Lvar1::5),(Lvar2::6))
	IntroAtom Local NoPrior Mono [(I::0)]checkEnd()
	IntroCompre Remote NoPrior Mono (P::7) (Ps::1) [(P::7)]notifyDeath((K::2))
	*/
	protected boolean execute_kill_join_ordering_1(Kill act) {
		
		int i;
		SimpMultiset<Integer>  ps;
		int k;
		SimpMultiset<Integer>  cs;
		SimpMultiset<Integer>  ms;
		SimpMultiset<Integer>  lvar1;
		SimpMultiset<Integer>  lvar2;
		int p;
		// Join Task: Active #H0 [(I::0)]kill((K::2))
		i = act.loc;
		k = act.arg1;
		// Join Task: LookupAtom #H1 7:0:hash<[+]isModerator()|.>  (I::0) [(I::0)]isModerator()
		StoreIter<IsModerator> candidates_1 = ismoderator_store_0.lookup_candidates(index0IsModerator(i));
		IsModerator cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int i__1;
			i__1 = cand_1.loc;
			if (true) {
				// Join Task: LookupAtom #H2 12:0:hash<[+]allPlayers(-)|.>  (I::0) [(I::0)]allPlayers((Ps::1))
				StoreIter<AllPlayers> candidates_2 = allplayers_store_0.lookup_candidates(index0AllPlayers(i));
				AllPlayers cand_2 = candidates_2.get_next();
				while(cand_2 != null) {
					int i__2;
					i__2 = cand_2.loc;
					ps = cand_2.arg1;
					if (true) {
						// Join Task: LookupAtom #H3 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::3),(Ms::4))
						StoreIter<LivePlayers> candidates_3 = liveplayers_store_0.lookup_candidates(index0LivePlayers(i));
						LivePlayers cand_3 = candidates_3.get_next_alive();
						while(cand_3 != null) {
							int i__3;
							i__3 = cand_3.loc;
							cs = cand_3.arg1;
							ms = cand_3.arg2;
							if (true) {
								// Join Task: DeleteHead #H0
								// H0 is active and monotone, no delete required
								// Join Task: DeleteHead #H3
								liveplayers_store_0.remove( cand_3 );
								// Join Task: LetBind (Lvar1::5) diff(((Cs::3),{(K::2)}))
								Integer[] temp0 = { k };
								lvar1 = ExtLib.diff(cs,Misc.to_mset(temp0));
								;
								// Join Task: LetBind (Lvar2::6) diff(((Ms::4),{(K::2)}))
								Integer[] temp1 = { k };
								lvar2 = ExtLib.diff(ms,Misc.to_mset(temp1));
								;
								// Join Task: IntroAtom Local NoPrior Mono [(I::0)]livePlayers((Lvar1::5),(Lvar2::6))
								intro( new LivePlayers(i,lvar1,lvar2) );
								// Join Task: IntroAtom Local NoPrior Mono [(I::0)]checkEnd()
								intro( new CheckEnd(i) );
								// Join Task: IntroCompre Remote NoPrior Mono (P::7) (Ps::1) [(P::7)]notifyDeath((K::2))
								SimpMultiset<Integer>  comp_0 = ps;
								for(int idx=0; idx<comp_0.size(); idx++) {
									p = comp_0.get(idx);
									send( new NotifyDeath(p,k) ); 
								}
								kill_rule_count++;
								return false;
							}
							cand_3 = candidates_3.get_next_alive();
						}
					}
					cand_2 = candidates_2.get_next();
				}
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule mvote ****
	Rule Head Variables: (X::0), (Ms::1), (I::2), (C::3)
	Rule Head Compre Binders: 
	Active #H0 [(X::0)]mafiaChangedVote((C::3))
	LookupAtom #H1 8:0:hash<[+]isMafia()|.>  (X::0) [(X::0)]isMafia()
	LookupAtom #H2 13:0:hash<[+]allMafia(-)|.>  (X::0) [(X::0)]allMafia((Ms::1))
	LookupAtom #H3 6:1:hash<[+]moderator(-)|.>  (X::0) [(X::0)]moderator((I::2))
	DeleteHead #H0
	IntroCompre Remote NoPrior Mono (M::4) union(({(I::2)},(Ms::1))) [(M::4)]notifyMafiaChangedVote((X::0),(C::3))
	*/
	protected boolean execute_mafiachangedvote_join_ordering_1(MafiaChangedVote act) {
		
		int x;
		SimpMultiset<Integer>  ms;
		int i;
		int c;
		int m;
		// Join Task: Active #H0 [(X::0)]mafiaChangedVote((C::3))
		x = act.loc;
		c = act.arg1;
		// Join Task: LookupAtom #H1 8:0:hash<[+]isMafia()|.>  (X::0) [(X::0)]isMafia()
		StoreIter<IsMafia> candidates_1 = ismafia_store_0.lookup_candidates(index0IsMafia(x));
		IsMafia cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int x__1;
			x__1 = cand_1.loc;
			if (true) {
				// Join Task: LookupAtom #H2 13:0:hash<[+]allMafia(-)|.>  (X::0) [(X::0)]allMafia((Ms::1))
				StoreIter<AllMafia> candidates_2 = allmafia_store_0.lookup_candidates(index0AllMafia(x));
				AllMafia cand_2 = candidates_2.get_next();
				while(cand_2 != null) {
					int x__2;
					x__2 = cand_2.loc;
					ms = cand_2.arg1;
					if (true) {
						// Join Task: LookupAtom #H3 6:1:hash<[+]moderator(-)|.>  (X::0) [(X::0)]moderator((I::2))
						StoreIter<Moderator> candidates_3 = moderator_store_1.lookup_candidates(index1Moderator(x));
						Moderator cand_3 = candidates_3.get_next();
						while(cand_3 != null) {
							int x__3;
							x__3 = cand_3.loc;
							i = cand_3.arg1;
							if (true) {
								// Join Task: DeleteHead #H0
								// H0 is active and monotone, no delete required
								// Join Task: IntroCompre Remote NoPrior Mono (M::4) union(({(I::2)},(Ms::1))) [(M::4)]notifyMafiaChangedVote((X::0),(C::3))
								Integer[] temp2 = { i };
								SimpMultiset<Integer>  comp_0 = ExtLib.union(Misc.to_mset(temp2),ms);
								for(int idx=0; idx<comp_0.size(); idx++) {
									m = comp_0.get(idx);
									send( new NotifyMafiaChangedVote(m,x,c) ); 
								}
								mvote_rule_count++;
								return false;
							}
							cand_3 = candidates_3.get_next();
						}
					}
					cand_2 = candidates_2.get_next();
				}
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule cvote ****
	Rule Head Variables: (X::0), (Ps::1), (C::2)
	Rule Head Compre Binders: 
	Active #H0 [(X::0)]citizenChangedVote((C::2))
	LookupAtom #H1 12:0:hash<[+]allPlayers(-)|.>  (X::0) [(X::0)]allPlayers((Ps::1))
	DeleteHead #H0
	IntroCompre Remote NoPrior Mono (P::3) (Ps::1) [(P::3)]notifyCitizenChangedVote((X::0),(C::2))
	*/
	protected boolean execute_citizenchangedvote_join_ordering_1(CitizenChangedVote act) {
		
		int x;
		SimpMultiset<Integer>  ps;
		int c;
		int p;
		// Join Task: Active #H0 [(X::0)]citizenChangedVote((C::2))
		x = act.loc;
		c = act.arg1;
		// Join Task: LookupAtom #H1 12:0:hash<[+]allPlayers(-)|.>  (X::0) [(X::0)]allPlayers((Ps::1))
		StoreIter<AllPlayers> candidates_1 = allplayers_store_0.lookup_candidates(index0AllPlayers(x));
		AllPlayers cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int x__1;
			x__1 = cand_1.loc;
			ps = cand_1.arg1;
			if (true) {
				// Join Task: DeleteHead #H0
				// H0 is active and monotone, no delete required
				// Join Task: IntroCompre Remote NoPrior Mono (P::3) (Ps::1) [(P::3)]notifyCitizenChangedVote((X::0),(C::2))
				SimpMultiset<Integer>  comp_0 = ps;
				for(int idx=0; idx<comp_0.size(); idx++) {
					p = comp_0.get(idx);
					send( new NotifyCitizenChangedVote(p,x,c) ); 
				}
				cvote_rule_count++;
				return false;
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule marked ****
	Rule Head Variables: (I::0), (M::1)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]mark((M::1))
	LookupAtom #H1 7:0:hash<[+]isModerator()|.>  (I::0) [(I::0)]isModerator()
	DeleteHead #H0
	IntroAtom Remote NoPrior Mono [(M::1)]notifyMarked()
	IntroAtom Local NoPrior Mono [(I::0)]checkEnd()
	*/
	protected boolean execute_mark_join_ordering_1(Mark act) {
		
		int i;
		int m;
		// Join Task: Active #H0 [(I::0)]mark((M::1))
		i = act.loc;
		m = act.arg1;
		// Join Task: LookupAtom #H1 7:0:hash<[+]isModerator()|.>  (I::0) [(I::0)]isModerator()
		StoreIter<IsModerator> candidates_1 = ismoderator_store_0.lookup_candidates(index0IsModerator(i));
		IsModerator cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int i__1;
			i__1 = cand_1.loc;
			if (true) {
				// Join Task: DeleteHead #H0
				// H0 is active and monotone, no delete required
				// Join Task: IntroAtom Remote NoPrior Mono [(M::1)]notifyMarked()
				send( new NotifyMarked(m) ); 
				// Join Task: IntroAtom Local NoPrior Mono [(I::0)]checkEnd()
				intro( new CheckEnd(i) );
				marked_rule_count++;
				return false;
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule start ****
	Rule Head Variables: (I::0)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]moderator((I::0))
	LookupAtom #H1 1:0:hash<[+]start()|.>  (I::0) [(I::0)]start()
	DeleteHead #H1
	LetBind (Night::1) true
	LetBind (IsFirst::2) true
	IntroAtom Local NoPrior Mono [(I::0)]trans((Night::1),(IsFirst::2))
	IntroAtom Local NoPrior Mono [(I::0)]cycle((Night::1))
	*/
	protected boolean execute_moderator_join_ordering_1(Moderator act) {
		
		int i;
		boolean night;
		boolean isfirst;
		// Join Task: Active #H0 [(I::0)]moderator((I::0))
		i = act.loc;
		i = act.arg1;
		// Join Task: LookupAtom #H1 1:0:hash<[+]start()|.>  (I::0) [(I::0)]start()
		StoreIter<Start> candidates_1 = start_store_0.lookup_candidates(index0Start(i));
		Start cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int i__1;
			i__1 = cand_1.loc;
			if (true) {
				// Join Task: DeleteHead #H1
				start_store_0.remove( cand_1 );
				// Join Task: LetBind (Night::1) true
				night = true;
				;
				// Join Task: LetBind (IsFirst::2) true
				isfirst = true;
				;
				// Join Task: IntroAtom Local NoPrior Mono [(I::0)]trans((Night::1),(IsFirst::2))
				intro( new Trans(i,night,isfirst) );
				// Join Task: IntroAtom Local NoPrior Mono [(I::0)]cycle((Night::1))
				intro( new Cycle(i,night) );
				start_rule_count++;
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 3 Join Ordering of Rule mvote ****
	Rule Head Variables: (X::0), (Ms::1), (I::2), (C::3)
	Rule Head Compre Binders: 
	Active #H0 [(X::0)]moderator((I::2))
	LookupAtom #H1 8:0:hash<[+]isMafia()|.>  (X::0) [(X::0)]isMafia()
	LookupAtom #H2 3:0:hash<[+]mafiaChangedVote(-)|.>  (X::0) [(X::0)]mafiaChangedVote((C::3))
	LookupAtom #H3 13:0:hash<[+]allMafia(-)|.>  (X::0) [(X::0)]allMafia((Ms::1))
	DeleteHead #H2
	IntroCompre Remote NoPrior Mono (M::4) union(({(I::2)},(Ms::1))) [(M::4)]notifyMafiaChangedVote((X::0),(C::3))
	*/
	protected boolean execute_moderator_join_ordering_2(Moderator act) {
		
		int x;
		SimpMultiset<Integer>  ms;
		int i;
		int c;
		int m;
		// Join Task: Active #H0 [(X::0)]moderator((I::2))
		x = act.loc;
		i = act.arg1;
		// Join Task: LookupAtom #H1 8:0:hash<[+]isMafia()|.>  (X::0) [(X::0)]isMafia()
		StoreIter<IsMafia> candidates_1 = ismafia_store_0.lookup_candidates(index0IsMafia(x));
		IsMafia cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int x__1;
			x__1 = cand_1.loc;
			if (true) {
				// Join Task: LookupAtom #H2 3:0:hash<[+]mafiaChangedVote(-)|.>  (X::0) [(X::0)]mafiaChangedVote((C::3))
				StoreIter<MafiaChangedVote> candidates_2 = mafiachangedvote_store_0.lookup_candidates(index0MafiaChangedVote(x));
				MafiaChangedVote cand_2 = candidates_2.get_next_alive();
				while(cand_2 != null) {
					int x__2;
					x__2 = cand_2.loc;
					c = cand_2.arg1;
					if (true) {
						// Join Task: LookupAtom #H3 13:0:hash<[+]allMafia(-)|.>  (X::0) [(X::0)]allMafia((Ms::1))
						StoreIter<AllMafia> candidates_3 = allmafia_store_0.lookup_candidates(index0AllMafia(x));
						AllMafia cand_3 = candidates_3.get_next();
						while(cand_3 != null) {
							int x__3;
							x__3 = cand_3.loc;
							ms = cand_3.arg1;
							if (true) {
								// Join Task: DeleteHead #H2
								mafiachangedvote_store_0.remove( cand_2 );
								// Join Task: IntroCompre Remote NoPrior Mono (M::4) union(({(I::2)},(Ms::1))) [(M::4)]notifyMafiaChangedVote((X::0),(C::3))
								Integer[] temp3 = { i };
								SimpMultiset<Integer>  comp_0 = ExtLib.union(Misc.to_mset(temp3),ms);
								for(int idx=0; idx<comp_0.size(); idx++) {
									m = comp_0.get(idx);
									send( new NotifyMafiaChangedVote(m,x,c) ); 
								}
								mvote_rule_count++;
							}
							cand_3 = candidates_3.get_next();
						}
					}
					cand_2 = candidates_2.get_next_alive();
				}
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 2 Join Ordering of Rule kill ****
	Rule Head Variables: (I::0), (Ps::1), (K::2), (Cs::3), (Ms::4)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]isModerator()
	LookupAtom #H1 2:0:hash<[+]kill(-)|.>  (I::0) [(I::0)]kill((K::2))
	LookupAtom #H2 12:0:hash<[+]allPlayers(-)|.>  (I::0) [(I::0)]allPlayers((Ps::1))
	LookupAtom #H3 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::3),(Ms::4))
	DeleteHead #H1
	DeleteHead #H3
	LetBind (Lvar1::5) diff(((Cs::3),{(K::2)}))
	LetBind (Lvar2::6) diff(((Ms::4),{(K::2)}))
	IntroAtom Local NoPrior Mono [(I::0)]livePlayers((Lvar1::5),(Lvar2::6))
	IntroAtom Local NoPrior Mono [(I::0)]checkEnd()
	IntroCompre Remote NoPrior Mono (P::7) (Ps::1) [(P::7)]notifyDeath((K::2))
	*/
	protected boolean execute_ismoderator_join_ordering_1(IsModerator act) {
		
		int i;
		SimpMultiset<Integer>  ps;
		int k;
		SimpMultiset<Integer>  cs;
		SimpMultiset<Integer>  ms;
		SimpMultiset<Integer>  lvar1;
		SimpMultiset<Integer>  lvar2;
		int p;
		// Join Task: Active #H0 [(I::0)]isModerator()
		i = act.loc;
		// Join Task: LookupAtom #H1 2:0:hash<[+]kill(-)|.>  (I::0) [(I::0)]kill((K::2))
		StoreIter<Kill> candidates_1 = kill_store_0.lookup_candidates(index0Kill(i));
		Kill cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int i__1;
			i__1 = cand_1.loc;
			k = cand_1.arg1;
			if (true) {
				// Join Task: LookupAtom #H2 12:0:hash<[+]allPlayers(-)|.>  (I::0) [(I::0)]allPlayers((Ps::1))
				StoreIter<AllPlayers> candidates_2 = allplayers_store_0.lookup_candidates(index0AllPlayers(i));
				AllPlayers cand_2 = candidates_2.get_next();
				while(cand_2 != null) {
					int i__2;
					i__2 = cand_2.loc;
					ps = cand_2.arg1;
					if (true) {
						// Join Task: LookupAtom #H3 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::3),(Ms::4))
						StoreIter<LivePlayers> candidates_3 = liveplayers_store_0.lookup_candidates(index0LivePlayers(i));
						LivePlayers cand_3 = candidates_3.get_next_alive();
						while(cand_3 != null) {
							int i__3;
							i__3 = cand_3.loc;
							cs = cand_3.arg1;
							ms = cand_3.arg2;
							if (true) {
								// Join Task: DeleteHead #H1
								kill_store_0.remove( cand_1 );
								// Join Task: DeleteHead #H3
								liveplayers_store_0.remove( cand_3 );
								// Join Task: LetBind (Lvar1::5) diff(((Cs::3),{(K::2)}))
								Integer[] temp4 = { k };
								lvar1 = ExtLib.diff(cs,Misc.to_mset(temp4));
								;
								// Join Task: LetBind (Lvar2::6) diff(((Ms::4),{(K::2)}))
								Integer[] temp5 = { k };
								lvar2 = ExtLib.diff(ms,Misc.to_mset(temp5));
								;
								// Join Task: IntroAtom Local NoPrior Mono [(I::0)]livePlayers((Lvar1::5),(Lvar2::6))
								intro( new LivePlayers(i,lvar1,lvar2) );
								// Join Task: IntroAtom Local NoPrior Mono [(I::0)]checkEnd()
								intro( new CheckEnd(i) );
								// Join Task: IntroCompre Remote NoPrior Mono (P::7) (Ps::1) [(P::7)]notifyDeath((K::2))
								SimpMultiset<Integer>  comp_0 = ps;
								for(int idx=0; idx<comp_0.size(); idx++) {
									p = comp_0.get(idx);
									send( new NotifyDeath(p,k) ); 
								}
								kill_rule_count++;
							}
							cand_3 = candidates_3.get_next_alive();
						}
					}
					cand_2 = candidates_2.get_next();
				}
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule marked ****
	Rule Head Variables: (I::0), (M::1)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]isModerator()
	LookupAtom #H1 5:0:hash<[+]mark(-)|.>  (I::0) [(I::0)]mark((M::1))
	DeleteHead #H1
	IntroAtom Remote NoPrior Mono [(M::1)]notifyMarked()
	IntroAtom Local NoPrior Mono [(I::0)]checkEnd()
	*/
	protected boolean execute_ismoderator_join_ordering_2(IsModerator act) {
		
		int i;
		int m;
		// Join Task: Active #H0 [(I::0)]isModerator()
		i = act.loc;
		// Join Task: LookupAtom #H1 5:0:hash<[+]mark(-)|.>  (I::0) [(I::0)]mark((M::1))
		StoreIter<Mark> candidates_1 = mark_store_0.lookup_candidates(index0Mark(i));
		Mark cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int i__1;
			i__1 = cand_1.loc;
			m = cand_1.arg1;
			if (true) {
				// Join Task: DeleteHead #H1
				mark_store_0.remove( cand_1 );
				// Join Task: IntroAtom Remote NoPrior Mono [(M::1)]notifyMarked()
				send( new NotifyMarked(m) ); 
				// Join Task: IntroAtom Local NoPrior Mono [(I::0)]checkEnd()
				intro( new CheckEnd(i) );
				marked_rule_count++;
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule mvote ****
	Rule Head Variables: (X::0), (Ms::1), (I::2), (C::3)
	Rule Head Compre Binders: 
	Active #H0 [(X::0)]isMafia()
	LookupAtom #H1 3:0:hash<[+]mafiaChangedVote(-)|.>  (X::0) [(X::0)]mafiaChangedVote((C::3))
	LookupAtom #H2 13:0:hash<[+]allMafia(-)|.>  (X::0) [(X::0)]allMafia((Ms::1))
	LookupAtom #H3 6:1:hash<[+]moderator(-)|.>  (X::0) [(X::0)]moderator((I::2))
	DeleteHead #H1
	IntroCompre Remote NoPrior Mono (M::4) union(({(I::2)},(Ms::1))) [(M::4)]notifyMafiaChangedVote((X::0),(C::3))
	*/
	protected boolean execute_ismafia_join_ordering_1(IsMafia act) {
		
		int x;
		SimpMultiset<Integer>  ms;
		int i;
		int c;
		int m;
		// Join Task: Active #H0 [(X::0)]isMafia()
		x = act.loc;
		// Join Task: LookupAtom #H1 3:0:hash<[+]mafiaChangedVote(-)|.>  (X::0) [(X::0)]mafiaChangedVote((C::3))
		StoreIter<MafiaChangedVote> candidates_1 = mafiachangedvote_store_0.lookup_candidates(index0MafiaChangedVote(x));
		MafiaChangedVote cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int x__1;
			x__1 = cand_1.loc;
			c = cand_1.arg1;
			if (true) {
				// Join Task: LookupAtom #H2 13:0:hash<[+]allMafia(-)|.>  (X::0) [(X::0)]allMafia((Ms::1))
				StoreIter<AllMafia> candidates_2 = allmafia_store_0.lookup_candidates(index0AllMafia(x));
				AllMafia cand_2 = candidates_2.get_next();
				while(cand_2 != null) {
					int x__2;
					x__2 = cand_2.loc;
					ms = cand_2.arg1;
					if (true) {
						// Join Task: LookupAtom #H3 6:1:hash<[+]moderator(-)|.>  (X::0) [(X::0)]moderator((I::2))
						StoreIter<Moderator> candidates_3 = moderator_store_1.lookup_candidates(index1Moderator(x));
						Moderator cand_3 = candidates_3.get_next();
						while(cand_3 != null) {
							int x__3;
							x__3 = cand_3.loc;
							i = cand_3.arg1;
							if (true) {
								// Join Task: DeleteHead #H1
								mafiachangedvote_store_0.remove( cand_1 );
								// Join Task: IntroCompre Remote NoPrior Mono (M::4) union(({(I::2)},(Ms::1))) [(M::4)]notifyMafiaChangedVote((X::0),(C::3))
								Integer[] temp6 = { i };
								SimpMultiset<Integer>  comp_0 = ExtLib.union(Misc.to_mset(temp6),ms);
								for(int idx=0; idx<comp_0.size(); idx++) {
									m = comp_0.get(idx);
									send( new NotifyMafiaChangedVote(m,x,c) ); 
								}
								mvote_rule_count++;
							}
							cand_3 = candidates_3.get_next();
						}
					}
					cand_2 = candidates_2.get_next();
				}
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 2 Join Ordering of Rule night ****
	Rule Head Variables: (I::0), (Ps::1), (D::2), (Cs::3), (Ms::4), (Night::5), (IsFirst::6)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]duration((D::2))
	LookupAtom #H1 12:0:hash<[+]allPlayers(-)|.>  (I::0) [(I::0)]allPlayers((Ps::1))
	LookupAtom #H2 14:0:hash<[+]trans(-,-)|.>  (I::0) [(I::0)]trans((Night::5),(IsFirst::6))
	CheckGuard (Night::5)
	LookupAtom #H3 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::3),(Ms::4))
	DeleteHead #H2
	LetBind (TimeWarn::7) addSeconds((timeNow(1),1))
	LetBind (TimeNight::8) addSeconds(((TimeWarn::7),10))
	LetBind (TimeWake::9) addSeconds(((TimeNight::8),5))
	LetBind (TimeNext::10) addSeconds((addSeconds(((TimeNight::8),(D::2))),0 - 11))
	IntroAtom Local NoPrior Mono [(I::0)]notifyCheckVotes((Ms::4),(TimeNext::10),(IsFirst::6))
	IntroCompre Remote NoPrior Mono (P::11) (Ps::1) [(P::11)]warnNight((TimeWarn::7))
	IntroCompre Remote NoPrior Mono (M::12) (Ms::4) [(M::12)]wakeMafia((TimeWake::9))
	*/
	protected boolean execute_duration_join_ordering_1(Duration act) {
		
		int i;
		SimpMultiset<Integer>  ps;
		int d;
		SimpMultiset<Integer>  cs;
		SimpMultiset<Integer>  ms;
		boolean night;
		boolean isfirst;
		long timewarn;
		long timenight;
		long timewake;
		long timenext;
		int p;
		int m;
		// Join Task: Active #H0 [(I::0)]duration((D::2))
		i = act.loc;
		d = act.arg1;
		// Join Task: LookupAtom #H1 12:0:hash<[+]allPlayers(-)|.>  (I::0) [(I::0)]allPlayers((Ps::1))
		StoreIter<AllPlayers> candidates_1 = allplayers_store_0.lookup_candidates(index0AllPlayers(i));
		AllPlayers cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int i__1;
			i__1 = cand_1.loc;
			ps = cand_1.arg1;
			if (true) {
				// Join Task: LookupAtom #H2 14:0:hash<[+]trans(-,-)|.>  (I::0) [(I::0)]trans((Night::5),(IsFirst::6))
				StoreIter<Trans> candidates_2 = trans_store_0.lookup_candidates(index0Trans(i));
				Trans cand_2 = candidates_2.get_next_alive();
				while(cand_2 != null) {
					int i__2;
					i__2 = cand_2.loc;
					night = cand_2.arg1;
					isfirst = cand_2.arg2;
					if (true) {
						// Join Task: CheckGuard (Night::5)
						if (night) {
							// Join Task: LookupAtom #H3 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::3),(Ms::4))
							StoreIter<LivePlayers> candidates_3 = liveplayers_store_0.lookup_candidates(index0LivePlayers(i));
							LivePlayers cand_3 = candidates_3.get_next_alive();
							while(cand_3 != null) {
								int i__3;
								i__3 = cand_3.loc;
								cs = cand_3.arg1;
								ms = cand_3.arg2;
								if (true) {
									// Join Task: DeleteHead #H2
									trans_store_0.remove( cand_2 );
									// Join Task: LetBind (TimeWarn::7) addSeconds((timeNow(1),1))
									timewarn = ExtLib.addSeconds(ExtLib.timeNow(1),1);
									;
									// Join Task: LetBind (TimeNight::8) addSeconds(((TimeWarn::7),10))
									timenight = ExtLib.addSeconds(timewarn,10);
									;
									// Join Task: LetBind (TimeWake::9) addSeconds(((TimeNight::8),5))
									timewake = ExtLib.addSeconds(timenight,5);
									;
									// Join Task: LetBind (TimeNext::10) addSeconds((addSeconds(((TimeNight::8),(D::2))),0 - 11))
									timenext = ExtLib.addSeconds(ExtLib.addSeconds(timenight,d),0 - 11);
									;
									// Join Task: IntroAtom Local NoPrior Mono [(I::0)]notifyCheckVotes((Ms::4),(TimeNext::10),(IsFirst::6))
									intro( new NotifyCheckVotes(i,ms,timenext,isfirst) );
									// Join Task: IntroCompre Remote NoPrior Mono (P::11) (Ps::1) [(P::11)]warnNight((TimeWarn::7))
									SimpMultiset<Integer>  comp_0 = ps;
									for(int idx=0; idx<comp_0.size(); idx++) {
										p = comp_0.get(idx);
										send( new WarnNight(p,timewarn) ); 
										send( new SignalNight(p,timenight) ); 
									}
									// Join Task: IntroCompre Remote NoPrior Mono (M::12) (Ms::4) [(M::12)]wakeMafia((TimeWake::9))
									SimpMultiset<Integer>  comp_1 = ms;
									for(int idx=0; idx<comp_1.size(); idx++) {
										m = comp_1.get(idx);
										send( new WakeMafia(m,timewake) ); 
									}
									night_rule_count++;
								}
								cand_3 = candidates_3.get_next_alive();
							}
						}
					}
					cand_2 = candidates_2.get_next_alive();
				}
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 2 Join Ordering of Rule day ****
	Rule Head Variables: (I::0), (Ps::1), (D::2), (Cs::3), (Ms::4), (Night::5), (IsFirst::6)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]duration((D::2))
	LookupAtom #H1 12:0:hash<[+]allPlayers(-)|.>  (I::0) [(I::0)]allPlayers((Ps::1))
	LookupAtom #H2 14:0:hash<[+]trans(-,-)|.>  (I::0) [(I::0)]trans((Night::5),(IsFirst::6))
	CheckGuard not((Night::5))
	LookupAtom #H3 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::3),(Ms::4))
	DeleteHead #H2
	LetBind (TimeWarn::7) addSeconds((timeNow(1),1))
	LetBind (TimeDay::8) addSeconds(((TimeWarn::7),10))
	LetBind (TimeNext::9) addSeconds((addSeconds(((TimeDay::8),(D::2))),0 - 11))
	LetBind (Lvar0::10) union(((Ms::4),(Cs::3)))
	IntroAtom Local NoPrior Mono [(I::0)]notifyCheckVotes((Lvar0::10),(TimeNext::9),(IsFirst::6))
	IntroCompre Remote NoPrior Mono (P::11) (Ps::1) [(P::11)]warnDay((TimeWarn::7))
	*/
	protected boolean execute_duration_join_ordering_2(Duration act) {
		
		int i;
		SimpMultiset<Integer>  ps;
		int d;
		SimpMultiset<Integer>  cs;
		SimpMultiset<Integer>  ms;
		boolean night;
		boolean isfirst;
		long timewarn;
		long timeday;
		long timenext;
		SimpMultiset<Integer>  lvar0;
		int p;
		// Join Task: Active #H0 [(I::0)]duration((D::2))
		i = act.loc;
		d = act.arg1;
		// Join Task: LookupAtom #H1 12:0:hash<[+]allPlayers(-)|.>  (I::0) [(I::0)]allPlayers((Ps::1))
		StoreIter<AllPlayers> candidates_1 = allplayers_store_0.lookup_candidates(index0AllPlayers(i));
		AllPlayers cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int i__1;
			i__1 = cand_1.loc;
			ps = cand_1.arg1;
			if (true) {
				// Join Task: LookupAtom #H2 14:0:hash<[+]trans(-,-)|.>  (I::0) [(I::0)]trans((Night::5),(IsFirst::6))
				StoreIter<Trans> candidates_2 = trans_store_0.lookup_candidates(index0Trans(i));
				Trans cand_2 = candidates_2.get_next_alive();
				while(cand_2 != null) {
					int i__2;
					i__2 = cand_2.loc;
					night = cand_2.arg1;
					isfirst = cand_2.arg2;
					if (true) {
						// Join Task: CheckGuard not((Night::5))
						if (ExtLib.not(night)) {
							// Join Task: LookupAtom #H3 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::3),(Ms::4))
							StoreIter<LivePlayers> candidates_3 = liveplayers_store_0.lookup_candidates(index0LivePlayers(i));
							LivePlayers cand_3 = candidates_3.get_next_alive();
							while(cand_3 != null) {
								int i__3;
								i__3 = cand_3.loc;
								cs = cand_3.arg1;
								ms = cand_3.arg2;
								if (true) {
									// Join Task: DeleteHead #H2
									trans_store_0.remove( cand_2 );
									// Join Task: LetBind (TimeWarn::7) addSeconds((timeNow(1),1))
									timewarn = ExtLib.addSeconds(ExtLib.timeNow(1),1);
									;
									// Join Task: LetBind (TimeDay::8) addSeconds(((TimeWarn::7),10))
									timeday = ExtLib.addSeconds(timewarn,10);
									;
									// Join Task: LetBind (TimeNext::9) addSeconds((addSeconds(((TimeDay::8),(D::2))),0 - 11))
									timenext = ExtLib.addSeconds(ExtLib.addSeconds(timeday,d),0 - 11);
									;
									// Join Task: LetBind (Lvar0::10) union(((Ms::4),(Cs::3)))
									lvar0 = ExtLib.union(ms,cs);
									;
									// Join Task: IntroAtom Local NoPrior Mono [(I::0)]notifyCheckVotes((Lvar0::10),(TimeNext::9),(IsFirst::6))
									intro( new NotifyCheckVotes(i,lvar0,timenext,isfirst) );
									// Join Task: IntroCompre Remote NoPrior Mono (P::11) (Ps::1) [(P::11)]warnDay((TimeWarn::7))
									SimpMultiset<Integer>  comp_0 = ps;
									for(int idx=0; idx<comp_0.size(); idx++) {
										p = comp_0.get(idx);
										send( new WarnDay(p,timewarn) ); 
										send( new SignalDay(p,timeday) ); 
									}
									day_rule_count++;
								}
								cand_3 = candidates_3.get_next_alive();
							}
						}
					}
					cand_2 = candidates_2.get_next_alive();
				}
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 3 Join Ordering of Rule night ****
	Rule Head Variables: (I::0), (Ps::1), (D::2), (Cs::3), (Ms::4), (Night::5), (IsFirst::6)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]livePlayers((Cs::3),(Ms::4))
	LookupAtom #H1 12:0:hash<[+]allPlayers(-)|.>  (I::0) [(I::0)]allPlayers((Ps::1))
	LookupAtom #H2 10:0:hash<[+]duration(-)|.>  (I::0) [(I::0)]duration((D::2))
	LookupAtom #H3 14:0:hash<[+]trans(-,-)|.>  (I::0) [(I::0)]trans((Night::5),(IsFirst::6))
	CheckGuard (Night::5)
	DeleteHead #H3
	LetBind (TimeWarn::7) addSeconds((timeNow(1),1))
	LetBind (TimeNight::8) addSeconds(((TimeWarn::7),10))
	LetBind (TimeWake::9) addSeconds(((TimeNight::8),5))
	LetBind (TimeNext::10) addSeconds((addSeconds(((TimeNight::8),(D::2))),0 - 11))
	IntroAtom Local NoPrior Mono [(I::0)]notifyCheckVotes((Ms::4),(TimeNext::10),(IsFirst::6))
	IntroCompre Remote NoPrior Mono (P::11) (Ps::1) [(P::11)]warnNight((TimeWarn::7))
	IntroCompre Remote NoPrior Mono (M::12) (Ms::4) [(M::12)]wakeMafia((TimeWake::9))
	*/
	protected boolean execute_liveplayers_join_ordering_1(LivePlayers act) {
		
		int i;
		SimpMultiset<Integer>  ps;
		int d;
		SimpMultiset<Integer>  cs;
		SimpMultiset<Integer>  ms;
		boolean night;
		boolean isfirst;
		long timewarn;
		long timenight;
		long timewake;
		long timenext;
		int p;
		int m;
		// Join Task: Active #H0 [(I::0)]livePlayers((Cs::3),(Ms::4))
		i = act.loc;
		cs = act.arg1;
		ms = act.arg2;
		// Join Task: LookupAtom #H1 12:0:hash<[+]allPlayers(-)|.>  (I::0) [(I::0)]allPlayers((Ps::1))
		StoreIter<AllPlayers> candidates_1 = allplayers_store_0.lookup_candidates(index0AllPlayers(i));
		AllPlayers cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int i__1;
			i__1 = cand_1.loc;
			ps = cand_1.arg1;
			if (true) {
				// Join Task: LookupAtom #H2 10:0:hash<[+]duration(-)|.>  (I::0) [(I::0)]duration((D::2))
				StoreIter<Duration> candidates_2 = duration_store_0.lookup_candidates(index0Duration(i));
				Duration cand_2 = candidates_2.get_next();
				while(cand_2 != null) {
					int i__2;
					i__2 = cand_2.loc;
					d = cand_2.arg1;
					if (true) {
						// Join Task: LookupAtom #H3 14:0:hash<[+]trans(-,-)|.>  (I::0) [(I::0)]trans((Night::5),(IsFirst::6))
						StoreIter<Trans> candidates_3 = trans_store_0.lookup_candidates(index0Trans(i));
						Trans cand_3 = candidates_3.get_next_alive();
						while(cand_3 != null) {
							int i__3;
							i__3 = cand_3.loc;
							night = cand_3.arg1;
							isfirst = cand_3.arg2;
							if (true) {
								// Join Task: CheckGuard (Night::5)
								if (night) {
									// Join Task: DeleteHead #H3
									trans_store_0.remove( cand_3 );
									// Join Task: LetBind (TimeWarn::7) addSeconds((timeNow(1),1))
									timewarn = ExtLib.addSeconds(ExtLib.timeNow(1),1);
									;
									// Join Task: LetBind (TimeNight::8) addSeconds(((TimeWarn::7),10))
									timenight = ExtLib.addSeconds(timewarn,10);
									;
									// Join Task: LetBind (TimeWake::9) addSeconds(((TimeNight::8),5))
									timewake = ExtLib.addSeconds(timenight,5);
									;
									// Join Task: LetBind (TimeNext::10) addSeconds((addSeconds(((TimeNight::8),(D::2))),0 - 11))
									timenext = ExtLib.addSeconds(ExtLib.addSeconds(timenight,d),0 - 11);
									;
									// Join Task: IntroAtom Local NoPrior Mono [(I::0)]notifyCheckVotes((Ms::4),(TimeNext::10),(IsFirst::6))
									intro( new NotifyCheckVotes(i,ms,timenext,isfirst) );
									// Join Task: IntroCompre Remote NoPrior Mono (P::11) (Ps::1) [(P::11)]warnNight((TimeWarn::7))
									SimpMultiset<Integer>  comp_0 = ps;
									for(int idx=0; idx<comp_0.size(); idx++) {
										p = comp_0.get(idx);
										send( new WarnNight(p,timewarn) ); 
										send( new SignalNight(p,timenight) ); 
									}
									// Join Task: IntroCompre Remote NoPrior Mono (M::12) (Ms::4) [(M::12)]wakeMafia((TimeWake::9))
									SimpMultiset<Integer>  comp_1 = ms;
									for(int idx=0; idx<comp_1.size(); idx++) {
										m = comp_1.get(idx);
										send( new WakeMafia(m,timewake) ); 
									}
									night_rule_count++;
								}
							}
							cand_3 = candidates_3.get_next_alive();
						}
					}
					cand_2 = candidates_2.get_next();
				}
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 3 Join Ordering of Rule day ****
	Rule Head Variables: (I::0), (Ps::1), (D::2), (Cs::3), (Ms::4), (Night::5), (IsFirst::6)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]livePlayers((Cs::3),(Ms::4))
	LookupAtom #H1 12:0:hash<[+]allPlayers(-)|.>  (I::0) [(I::0)]allPlayers((Ps::1))
	LookupAtom #H2 10:0:hash<[+]duration(-)|.>  (I::0) [(I::0)]duration((D::2))
	LookupAtom #H3 14:0:hash<[+]trans(-,-)|.>  (I::0) [(I::0)]trans((Night::5),(IsFirst::6))
	CheckGuard not((Night::5))
	DeleteHead #H3
	LetBind (TimeWarn::7) addSeconds((timeNow(1),1))
	LetBind (TimeDay::8) addSeconds(((TimeWarn::7),10))
	LetBind (TimeNext::9) addSeconds((addSeconds(((TimeDay::8),(D::2))),0 - 11))
	LetBind (Lvar0::10) union(((Ms::4),(Cs::3)))
	IntroAtom Local NoPrior Mono [(I::0)]notifyCheckVotes((Lvar0::10),(TimeNext::9),(IsFirst::6))
	IntroCompre Remote NoPrior Mono (P::11) (Ps::1) [(P::11)]warnDay((TimeWarn::7))
	*/
	protected boolean execute_liveplayers_join_ordering_2(LivePlayers act) {
		
		int i;
		SimpMultiset<Integer>  ps;
		int d;
		SimpMultiset<Integer>  cs;
		SimpMultiset<Integer>  ms;
		boolean night;
		boolean isfirst;
		long timewarn;
		long timeday;
		long timenext;
		SimpMultiset<Integer>  lvar0;
		int p;
		// Join Task: Active #H0 [(I::0)]livePlayers((Cs::3),(Ms::4))
		i = act.loc;
		cs = act.arg1;
		ms = act.arg2;
		// Join Task: LookupAtom #H1 12:0:hash<[+]allPlayers(-)|.>  (I::0) [(I::0)]allPlayers((Ps::1))
		StoreIter<AllPlayers> candidates_1 = allplayers_store_0.lookup_candidates(index0AllPlayers(i));
		AllPlayers cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int i__1;
			i__1 = cand_1.loc;
			ps = cand_1.arg1;
			if (true) {
				// Join Task: LookupAtom #H2 10:0:hash<[+]duration(-)|.>  (I::0) [(I::0)]duration((D::2))
				StoreIter<Duration> candidates_2 = duration_store_0.lookup_candidates(index0Duration(i));
				Duration cand_2 = candidates_2.get_next();
				while(cand_2 != null) {
					int i__2;
					i__2 = cand_2.loc;
					d = cand_2.arg1;
					if (true) {
						// Join Task: LookupAtom #H3 14:0:hash<[+]trans(-,-)|.>  (I::0) [(I::0)]trans((Night::5),(IsFirst::6))
						StoreIter<Trans> candidates_3 = trans_store_0.lookup_candidates(index0Trans(i));
						Trans cand_3 = candidates_3.get_next_alive();
						while(cand_3 != null) {
							int i__3;
							i__3 = cand_3.loc;
							night = cand_3.arg1;
							isfirst = cand_3.arg2;
							if (true) {
								// Join Task: CheckGuard not((Night::5))
								if (ExtLib.not(night)) {
									// Join Task: DeleteHead #H3
									trans_store_0.remove( cand_3 );
									// Join Task: LetBind (TimeWarn::7) addSeconds((timeNow(1),1))
									timewarn = ExtLib.addSeconds(ExtLib.timeNow(1),1);
									;
									// Join Task: LetBind (TimeDay::8) addSeconds(((TimeWarn::7),10))
									timeday = ExtLib.addSeconds(timewarn,10);
									;
									// Join Task: LetBind (TimeNext::9) addSeconds((addSeconds(((TimeDay::8),(D::2))),0 - 11))
									timenext = ExtLib.addSeconds(ExtLib.addSeconds(timeday,d),0 - 11);
									;
									// Join Task: LetBind (Lvar0::10) union(((Ms::4),(Cs::3)))
									lvar0 = ExtLib.union(ms,cs);
									;
									// Join Task: IntroAtom Local NoPrior Mono [(I::0)]notifyCheckVotes((Lvar0::10),(TimeNext::9),(IsFirst::6))
									intro( new NotifyCheckVotes(i,lvar0,timenext,isfirst) );
									// Join Task: IntroCompre Remote NoPrior Mono (P::11) (Ps::1) [(P::11)]warnDay((TimeWarn::7))
									SimpMultiset<Integer>  comp_0 = ps;
									for(int idx=0; idx<comp_0.size(); idx++) {
										p = comp_0.get(idx);
										send( new WarnDay(p,timewarn) ); 
										send( new SignalDay(p,timeday) ); 
									}
									day_rule_count++;
								}
							}
							cand_3 = candidates_3.get_next_alive();
						}
					}
					cand_2 = candidates_2.get_next();
				}
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule kill ****
	Rule Head Variables: (I::0), (Ps::1), (K::2), (Cs::3), (Ms::4)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]livePlayers((Cs::3),(Ms::4))
	LookupAtom #H1 7:0:hash<[+]isModerator()|.>  (I::0) [(I::0)]isModerator()
	LookupAtom #H2 2:0:hash<[+]kill(-)|.>  (I::0) [(I::0)]kill((K::2))
	LookupAtom #H3 12:0:hash<[+]allPlayers(-)|.>  (I::0) [(I::0)]allPlayers((Ps::1))
	DeleteHead #H0
	DeleteHead #H2
	LetBind (Lvar1::5) diff(((Cs::3),{(K::2)}))
	LetBind (Lvar2::6) diff(((Ms::4),{(K::2)}))
	IntroAtom Local NoPrior Mono [(I::0)]livePlayers((Lvar1::5),(Lvar2::6))
	IntroAtom Local NoPrior Mono [(I::0)]checkEnd()
	IntroCompre Remote NoPrior Mono (P::7) (Ps::1) [(P::7)]notifyDeath((K::2))
	*/
	protected boolean execute_liveplayers_join_ordering_3(LivePlayers act) {
		
		int i;
		SimpMultiset<Integer>  ps;
		int k;
		SimpMultiset<Integer>  cs;
		SimpMultiset<Integer>  ms;
		SimpMultiset<Integer>  lvar1;
		SimpMultiset<Integer>  lvar2;
		int p;
		// Join Task: Active #H0 [(I::0)]livePlayers((Cs::3),(Ms::4))
		i = act.loc;
		cs = act.arg1;
		ms = act.arg2;
		// Join Task: LookupAtom #H1 7:0:hash<[+]isModerator()|.>  (I::0) [(I::0)]isModerator()
		StoreIter<IsModerator> candidates_1 = ismoderator_store_0.lookup_candidates(index0IsModerator(i));
		IsModerator cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int i__1;
			i__1 = cand_1.loc;
			if (true) {
				// Join Task: LookupAtom #H2 2:0:hash<[+]kill(-)|.>  (I::0) [(I::0)]kill((K::2))
				StoreIter<Kill> candidates_2 = kill_store_0.lookup_candidates(index0Kill(i));
				Kill cand_2 = candidates_2.get_next_alive();
				while(cand_2 != null) {
					int i__2;
					i__2 = cand_2.loc;
					k = cand_2.arg1;
					if (true) {
						// Join Task: LookupAtom #H3 12:0:hash<[+]allPlayers(-)|.>  (I::0) [(I::0)]allPlayers((Ps::1))
						StoreIter<AllPlayers> candidates_3 = allplayers_store_0.lookup_candidates(index0AllPlayers(i));
						AllPlayers cand_3 = candidates_3.get_next();
						while(cand_3 != null) {
							int i__3;
							i__3 = cand_3.loc;
							ps = cand_3.arg1;
							if (true) {
								// Join Task: DeleteHead #H0
								// H0 is active and monotone, no delete required
								// Join Task: DeleteHead #H2
								kill_store_0.remove( cand_2 );
								// Join Task: LetBind (Lvar1::5) diff(((Cs::3),{(K::2)}))
								Integer[] temp7 = { k };
								lvar1 = ExtLib.diff(cs,Misc.to_mset(temp7));
								;
								// Join Task: LetBind (Lvar2::6) diff(((Ms::4),{(K::2)}))
								Integer[] temp8 = { k };
								lvar2 = ExtLib.diff(ms,Misc.to_mset(temp8));
								;
								// Join Task: IntroAtom Local NoPrior Mono [(I::0)]livePlayers((Lvar1::5),(Lvar2::6))
								intro( new LivePlayers(i,lvar1,lvar2) );
								// Join Task: IntroAtom Local NoPrior Mono [(I::0)]checkEnd()
								intro( new CheckEnd(i) );
								// Join Task: IntroCompre Remote NoPrior Mono (P::7) (Ps::1) [(P::7)]notifyDeath((K::2))
								SimpMultiset<Integer>  comp_0 = ps;
								for(int idx=0; idx<comp_0.size(); idx++) {
									p = comp_0.get(idx);
									send( new NotifyDeath(p,k) ); 
								}
								kill_rule_count++;
								return false;
							}
							cand_3 = candidates_3.get_next();
						}
					}
					cand_2 = candidates_2.get_next_alive();
				}
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 2 Join Ordering of Rule end1 ****
	Rule Head Variables: (I::0), (Ps::1), (Cs::2), (Ms::3)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]livePlayers((Cs::2),(Ms::3))
	CheckGuard size((Ms::3)) >= size((Cs::2))
	LookupAtom #H1 17:0:hash<[+]checkEnd()|.>  (I::0) [(I::0)]checkEnd()
	LookupAtom #H2 12:0:hash<[+]allPlayers(-)|.>  (I::0) [(I::0)]allPlayers((Ps::1))
	DeleteHead #H1
	IntroCompre Remote NoPrior Mono (P::4) (Ps::1) [(P::4)]notifyMafiaWin()
	*/
	protected boolean execute_liveplayers_join_ordering_4(LivePlayers act) {
		
		int i;
		SimpMultiset<Integer>  ps;
		SimpMultiset<Integer>  cs;
		SimpMultiset<Integer>  ms;
		int p;
		// Join Task: Active #H0 [(I::0)]livePlayers((Cs::2),(Ms::3))
		i = act.loc;
		cs = act.arg1;
		ms = act.arg2;
		// Join Task: CheckGuard size((Ms::3)) >= size((Cs::2))
		if (ExtLib.size(ms) >= ExtLib.size(cs)) {
			// Join Task: LookupAtom #H1 17:0:hash<[+]checkEnd()|.>  (I::0) [(I::0)]checkEnd()
			StoreIter<CheckEnd> candidates_1 = checkend_store_0.lookup_candidates(index0CheckEnd(i));
			CheckEnd cand_1 = candidates_1.get_next_alive();
			while(cand_1 != null) {
				int i__1;
				i__1 = cand_1.loc;
				if (true) {
					// Join Task: LookupAtom #H2 12:0:hash<[+]allPlayers(-)|.>  (I::0) [(I::0)]allPlayers((Ps::1))
					StoreIter<AllPlayers> candidates_2 = allplayers_store_0.lookup_candidates(index0AllPlayers(i));
					AllPlayers cand_2 = candidates_2.get_next();
					while(cand_2 != null) {
						int i__2;
						i__2 = cand_2.loc;
						ps = cand_2.arg1;
						if (true) {
							// Join Task: DeleteHead #H1
							checkend_store_0.remove( cand_1 );
							// Join Task: IntroCompre Remote NoPrior Mono (P::4) (Ps::1) [(P::4)]notifyMafiaWin()
							SimpMultiset<Integer>  comp_0 = ps;
							for(int idx=0; idx<comp_0.size(); idx++) {
								p = comp_0.get(idx);
								send( new NotifyMafiaWin(p) ); 
							}
							end1_rule_count++;
						}
						cand_2 = candidates_2.get_next();
					}
				}
				cand_1 = candidates_1.get_next_alive();
			}
		}
		return true;
	}
	
	/*
	**** 2 Join Ordering of Rule end2 ****
	Rule Head Variables: (I::0), (Ps::1), (Cs::2), (Ms::3)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]livePlayers((Cs::2),(Ms::3))
	CheckGuard size((Ms::3)) == 0
	LookupAtom #H1 17:0:hash<[+]checkEnd()|.>  (I::0) [(I::0)]checkEnd()
	LookupAtom #H2 12:0:hash<[+]allPlayers(-)|.>  (I::0) [(I::0)]allPlayers((Ps::1))
	DeleteHead #H1
	IntroCompre Remote NoPrior Mono (P::4) (Ps::1) [(P::4)]notifyCitizensWin()
	*/
	protected boolean execute_liveplayers_join_ordering_5(LivePlayers act) {
		
		int i;
		SimpMultiset<Integer>  ps;
		SimpMultiset<Integer>  cs;
		SimpMultiset<Integer>  ms;
		int p;
		// Join Task: Active #H0 [(I::0)]livePlayers((Cs::2),(Ms::3))
		i = act.loc;
		cs = act.arg1;
		ms = act.arg2;
		// Join Task: CheckGuard size((Ms::3)) == 0
		if (Equality.is_eq(ExtLib.size(ms),0)) {
			// Join Task: LookupAtom #H1 17:0:hash<[+]checkEnd()|.>  (I::0) [(I::0)]checkEnd()
			StoreIter<CheckEnd> candidates_1 = checkend_store_0.lookup_candidates(index0CheckEnd(i));
			CheckEnd cand_1 = candidates_1.get_next_alive();
			while(cand_1 != null) {
				int i__1;
				i__1 = cand_1.loc;
				if (true) {
					// Join Task: LookupAtom #H2 12:0:hash<[+]allPlayers(-)|.>  (I::0) [(I::0)]allPlayers((Ps::1))
					StoreIter<AllPlayers> candidates_2 = allplayers_store_0.lookup_candidates(index0AllPlayers(i));
					AllPlayers cand_2 = candidates_2.get_next();
					while(cand_2 != null) {
						int i__2;
						i__2 = cand_2.loc;
						ps = cand_2.arg1;
						if (true) {
							// Join Task: DeleteHead #H1
							checkend_store_0.remove( cand_1 );
							// Join Task: IntroCompre Remote NoPrior Mono (P::4) (Ps::1) [(P::4)]notifyCitizensWin()
							SimpMultiset<Integer>  comp_0 = ps;
							for(int idx=0; idx<comp_0.size(); idx++) {
								p = comp_0.get(idx);
								send( new NotifyCitizensWin(p) ); 
							}
							end2_rule_count++;
						}
						cand_2 = candidates_2.get_next();
					}
				}
				cand_1 = candidates_1.get_next_alive();
			}
		}
		return true;
	}
	
	/*
	**** 2 Join Ordering of Rule cont ****
	Rule Head Variables: (I::0), (Cs::1), (Ms::2), (Night::3)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]livePlayers((Cs::1),(Ms::2))
	CheckGuard size((Ms::2)) < size((Cs::1))
	CheckGuard size((Ms::2)) > 0
	LookupAtom #H1 17:0:hash<[+]checkEnd()|.>  (I::0) [(I::0)]checkEnd()
	LookupAtom #H2 15:0:hash<[+]cycle(-)|.>  (I::0) [(I::0)]cycle((Night::3))
	DeleteHead #H1
	DeleteHead #H2
	LetBind (Lvar3::4) not((Night::3))
	LetBind (Lvar4::5) not((Night::3))
	IntroAtom Local NoPrior Mono [(I::0)]trans((Lvar3::4),false)
	IntroAtom Local NoPrior Mono [(I::0)]cycle((Lvar4::5))
	*/
	protected boolean execute_liveplayers_join_ordering_6(LivePlayers act) {
		
		int i;
		SimpMultiset<Integer>  cs;
		SimpMultiset<Integer>  ms;
		boolean night;
		boolean lvar3;
		boolean lvar4;
		// Join Task: Active #H0 [(I::0)]livePlayers((Cs::1),(Ms::2))
		i = act.loc;
		cs = act.arg1;
		ms = act.arg2;
		// Join Task: CheckGuard size((Ms::2)) < size((Cs::1))
		if (ExtLib.size(ms) < ExtLib.size(cs)) {
			// Join Task: CheckGuard size((Ms::2)) > 0
			if (ExtLib.size(ms) > 0) {
				// Join Task: LookupAtom #H1 17:0:hash<[+]checkEnd()|.>  (I::0) [(I::0)]checkEnd()
				StoreIter<CheckEnd> candidates_1 = checkend_store_0.lookup_candidates(index0CheckEnd(i));
				CheckEnd cand_1 = candidates_1.get_next_alive();
				while(cand_1 != null) {
					int i__1;
					i__1 = cand_1.loc;
					if (true) {
						// Join Task: LookupAtom #H2 15:0:hash<[+]cycle(-)|.>  (I::0) [(I::0)]cycle((Night::3))
						StoreIter<Cycle> candidates_2 = cycle_store_0.lookup_candidates(index0Cycle(i));
						Cycle cand_2 = candidates_2.get_next_alive();
						while(cand_2 != null) {
							int i__2;
							i__2 = cand_2.loc;
							night = cand_2.arg1;
							if (true) {
								// Join Task: DeleteHead #H1
								checkend_store_0.remove( cand_1 );
								// Join Task: DeleteHead #H2
								cycle_store_0.remove( cand_2 );
								// Join Task: LetBind (Lvar3::4) not((Night::3))
								lvar3 = ExtLib.not(night);
								;
								// Join Task: LetBind (Lvar4::5) not((Night::3))
								lvar4 = ExtLib.not(night);
								;
								// Join Task: IntroAtom Local NoPrior Mono [(I::0)]trans((Lvar3::4),false)
								intro( new Trans(i,lvar3,false) );
								// Join Task: IntroAtom Local NoPrior Mono [(I::0)]cycle((Lvar4::5))
								intro( new Cycle(i,lvar4) );
								cont_rule_count++;
							}
							cand_2 = candidates_2.get_next_alive();
						}
					}
					cand_1 = candidates_1.get_next_alive();
				}
			}
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule cvote ****
	Rule Head Variables: (X::0), (Ps::1), (C::2)
	Rule Head Compre Binders: 
	Active #H0 [(X::0)]allPlayers((Ps::1))
	LookupAtom #H1 4:0:hash<[+]citizenChangedVote(-)|.>  (X::0) [(X::0)]citizenChangedVote((C::2))
	DeleteHead #H1
	IntroCompre Remote NoPrior Mono (P::3) (Ps::1) [(P::3)]notifyCitizenChangedVote((X::0),(C::2))
	*/
	protected boolean execute_allplayers_join_ordering_1(AllPlayers act) {
		
		int x;
		SimpMultiset<Integer>  ps;
		int c;
		int p;
		// Join Task: Active #H0 [(X::0)]allPlayers((Ps::1))
		x = act.loc;
		ps = act.arg1;
		// Join Task: LookupAtom #H1 4:0:hash<[+]citizenChangedVote(-)|.>  (X::0) [(X::0)]citizenChangedVote((C::2))
		StoreIter<CitizenChangedVote> candidates_1 = citizenchangedvote_store_0.lookup_candidates(index0CitizenChangedVote(x));
		CitizenChangedVote cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int x__1;
			x__1 = cand_1.loc;
			c = cand_1.arg1;
			if (true) {
				// Join Task: DeleteHead #H1
				citizenchangedvote_store_0.remove( cand_1 );
				// Join Task: IntroCompre Remote NoPrior Mono (P::3) (Ps::1) [(P::3)]notifyCitizenChangedVote((X::0),(C::2))
				SimpMultiset<Integer>  comp_0 = ps;
				for(int idx=0; idx<comp_0.size(); idx++) {
					p = comp_0.get(idx);
					send( new NotifyCitizenChangedVote(p,x,c) ); 
				}
				cvote_rule_count++;
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule night ****
	Rule Head Variables: (I::0), (Ps::1), (D::2), (Cs::3), (Ms::4), (Night::5), (IsFirst::6)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]allPlayers((Ps::1))
	LookupAtom #H1 10:0:hash<[+]duration(-)|.>  (I::0) [(I::0)]duration((D::2))
	LookupAtom #H2 14:0:hash<[+]trans(-,-)|.>  (I::0) [(I::0)]trans((Night::5),(IsFirst::6))
	CheckGuard (Night::5)
	LookupAtom #H3 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::3),(Ms::4))
	DeleteHead #H2
	LetBind (TimeWarn::7) addSeconds((timeNow(1),1))
	LetBind (TimeNight::8) addSeconds(((TimeWarn::7),10))
	LetBind (TimeWake::9) addSeconds(((TimeNight::8),5))
	LetBind (TimeNext::10) addSeconds((addSeconds(((TimeNight::8),(D::2))),0 - 11))
	IntroAtom Local NoPrior Mono [(I::0)]notifyCheckVotes((Ms::4),(TimeNext::10),(IsFirst::6))
	IntroCompre Remote NoPrior Mono (P::11) (Ps::1) [(P::11)]warnNight((TimeWarn::7))
	IntroCompre Remote NoPrior Mono (M::12) (Ms::4) [(M::12)]wakeMafia((TimeWake::9))
	*/
	protected boolean execute_allplayers_join_ordering_2(AllPlayers act) {
		
		int i;
		SimpMultiset<Integer>  ps;
		int d;
		SimpMultiset<Integer>  cs;
		SimpMultiset<Integer>  ms;
		boolean night;
		boolean isfirst;
		long timewarn;
		long timenight;
		long timewake;
		long timenext;
		int p;
		int m;
		// Join Task: Active #H0 [(I::0)]allPlayers((Ps::1))
		i = act.loc;
		ps = act.arg1;
		// Join Task: LookupAtom #H1 10:0:hash<[+]duration(-)|.>  (I::0) [(I::0)]duration((D::2))
		StoreIter<Duration> candidates_1 = duration_store_0.lookup_candidates(index0Duration(i));
		Duration cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int i__1;
			i__1 = cand_1.loc;
			d = cand_1.arg1;
			if (true) {
				// Join Task: LookupAtom #H2 14:0:hash<[+]trans(-,-)|.>  (I::0) [(I::0)]trans((Night::5),(IsFirst::6))
				StoreIter<Trans> candidates_2 = trans_store_0.lookup_candidates(index0Trans(i));
				Trans cand_2 = candidates_2.get_next_alive();
				while(cand_2 != null) {
					int i__2;
					i__2 = cand_2.loc;
					night = cand_2.arg1;
					isfirst = cand_2.arg2;
					if (true) {
						// Join Task: CheckGuard (Night::5)
						if (night) {
							// Join Task: LookupAtom #H3 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::3),(Ms::4))
							StoreIter<LivePlayers> candidates_3 = liveplayers_store_0.lookup_candidates(index0LivePlayers(i));
							LivePlayers cand_3 = candidates_3.get_next_alive();
							while(cand_3 != null) {
								int i__3;
								i__3 = cand_3.loc;
								cs = cand_3.arg1;
								ms = cand_3.arg2;
								if (true) {
									// Join Task: DeleteHead #H2
									trans_store_0.remove( cand_2 );
									// Join Task: LetBind (TimeWarn::7) addSeconds((timeNow(1),1))
									timewarn = ExtLib.addSeconds(ExtLib.timeNow(1),1);
									;
									// Join Task: LetBind (TimeNight::8) addSeconds(((TimeWarn::7),10))
									timenight = ExtLib.addSeconds(timewarn,10);
									;
									// Join Task: LetBind (TimeWake::9) addSeconds(((TimeNight::8),5))
									timewake = ExtLib.addSeconds(timenight,5);
									;
									// Join Task: LetBind (TimeNext::10) addSeconds((addSeconds(((TimeNight::8),(D::2))),0 - 11))
									timenext = ExtLib.addSeconds(ExtLib.addSeconds(timenight,d),0 - 11);
									;
									// Join Task: IntroAtom Local NoPrior Mono [(I::0)]notifyCheckVotes((Ms::4),(TimeNext::10),(IsFirst::6))
									intro( new NotifyCheckVotes(i,ms,timenext,isfirst) );
									// Join Task: IntroCompre Remote NoPrior Mono (P::11) (Ps::1) [(P::11)]warnNight((TimeWarn::7))
									SimpMultiset<Integer>  comp_0 = ps;
									for(int idx=0; idx<comp_0.size(); idx++) {
										p = comp_0.get(idx);
										send( new WarnNight(p,timewarn) ); 
										send( new SignalNight(p,timenight) ); 
									}
									// Join Task: IntroCompre Remote NoPrior Mono (M::12) (Ms::4) [(M::12)]wakeMafia((TimeWake::9))
									SimpMultiset<Integer>  comp_1 = ms;
									for(int idx=0; idx<comp_1.size(); idx++) {
										m = comp_1.get(idx);
										send( new WakeMafia(m,timewake) ); 
									}
									night_rule_count++;
								}
								cand_3 = candidates_3.get_next_alive();
							}
						}
					}
					cand_2 = candidates_2.get_next_alive();
				}
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule day ****
	Rule Head Variables: (I::0), (Ps::1), (D::2), (Cs::3), (Ms::4), (Night::5), (IsFirst::6)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]allPlayers((Ps::1))
	LookupAtom #H1 10:0:hash<[+]duration(-)|.>  (I::0) [(I::0)]duration((D::2))
	LookupAtom #H2 14:0:hash<[+]trans(-,-)|.>  (I::0) [(I::0)]trans((Night::5),(IsFirst::6))
	CheckGuard not((Night::5))
	LookupAtom #H3 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::3),(Ms::4))
	DeleteHead #H2
	LetBind (TimeWarn::7) addSeconds((timeNow(1),1))
	LetBind (TimeDay::8) addSeconds(((TimeWarn::7),10))
	LetBind (TimeNext::9) addSeconds((addSeconds(((TimeDay::8),(D::2))),0 - 11))
	LetBind (Lvar0::10) union(((Ms::4),(Cs::3)))
	IntroAtom Local NoPrior Mono [(I::0)]notifyCheckVotes((Lvar0::10),(TimeNext::9),(IsFirst::6))
	IntroCompre Remote NoPrior Mono (P::11) (Ps::1) [(P::11)]warnDay((TimeWarn::7))
	*/
	protected boolean execute_allplayers_join_ordering_3(AllPlayers act) {
		
		int i;
		SimpMultiset<Integer>  ps;
		int d;
		SimpMultiset<Integer>  cs;
		SimpMultiset<Integer>  ms;
		boolean night;
		boolean isfirst;
		long timewarn;
		long timeday;
		long timenext;
		SimpMultiset<Integer>  lvar0;
		int p;
		// Join Task: Active #H0 [(I::0)]allPlayers((Ps::1))
		i = act.loc;
		ps = act.arg1;
		// Join Task: LookupAtom #H1 10:0:hash<[+]duration(-)|.>  (I::0) [(I::0)]duration((D::2))
		StoreIter<Duration> candidates_1 = duration_store_0.lookup_candidates(index0Duration(i));
		Duration cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int i__1;
			i__1 = cand_1.loc;
			d = cand_1.arg1;
			if (true) {
				// Join Task: LookupAtom #H2 14:0:hash<[+]trans(-,-)|.>  (I::0) [(I::0)]trans((Night::5),(IsFirst::6))
				StoreIter<Trans> candidates_2 = trans_store_0.lookup_candidates(index0Trans(i));
				Trans cand_2 = candidates_2.get_next_alive();
				while(cand_2 != null) {
					int i__2;
					i__2 = cand_2.loc;
					night = cand_2.arg1;
					isfirst = cand_2.arg2;
					if (true) {
						// Join Task: CheckGuard not((Night::5))
						if (ExtLib.not(night)) {
							// Join Task: LookupAtom #H3 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::3),(Ms::4))
							StoreIter<LivePlayers> candidates_3 = liveplayers_store_0.lookup_candidates(index0LivePlayers(i));
							LivePlayers cand_3 = candidates_3.get_next_alive();
							while(cand_3 != null) {
								int i__3;
								i__3 = cand_3.loc;
								cs = cand_3.arg1;
								ms = cand_3.arg2;
								if (true) {
									// Join Task: DeleteHead #H2
									trans_store_0.remove( cand_2 );
									// Join Task: LetBind (TimeWarn::7) addSeconds((timeNow(1),1))
									timewarn = ExtLib.addSeconds(ExtLib.timeNow(1),1);
									;
									// Join Task: LetBind (TimeDay::8) addSeconds(((TimeWarn::7),10))
									timeday = ExtLib.addSeconds(timewarn,10);
									;
									// Join Task: LetBind (TimeNext::9) addSeconds((addSeconds(((TimeDay::8),(D::2))),0 - 11))
									timenext = ExtLib.addSeconds(ExtLib.addSeconds(timeday,d),0 - 11);
									;
									// Join Task: LetBind (Lvar0::10) union(((Ms::4),(Cs::3)))
									lvar0 = ExtLib.union(ms,cs);
									;
									// Join Task: IntroAtom Local NoPrior Mono [(I::0)]notifyCheckVotes((Lvar0::10),(TimeNext::9),(IsFirst::6))
									intro( new NotifyCheckVotes(i,lvar0,timenext,isfirst) );
									// Join Task: IntroCompre Remote NoPrior Mono (P::11) (Ps::1) [(P::11)]warnDay((TimeWarn::7))
									SimpMultiset<Integer>  comp_0 = ps;
									for(int idx=0; idx<comp_0.size(); idx++) {
										p = comp_0.get(idx);
										send( new WarnDay(p,timewarn) ); 
										send( new SignalDay(p,timeday) ); 
									}
									day_rule_count++;
								}
								cand_3 = candidates_3.get_next_alive();
							}
						}
					}
					cand_2 = candidates_2.get_next_alive();
				}
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 3 Join Ordering of Rule kill ****
	Rule Head Variables: (I::0), (Ps::1), (K::2), (Cs::3), (Ms::4)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]allPlayers((Ps::1))
	LookupAtom #H1 7:0:hash<[+]isModerator()|.>  (I::0) [(I::0)]isModerator()
	LookupAtom #H2 2:0:hash<[+]kill(-)|.>  (I::0) [(I::0)]kill((K::2))
	LookupAtom #H3 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::3),(Ms::4))
	DeleteHead #H2
	DeleteHead #H3
	LetBind (Lvar1::5) diff(((Cs::3),{(K::2)}))
	LetBind (Lvar2::6) diff(((Ms::4),{(K::2)}))
	IntroAtom Local NoPrior Mono [(I::0)]livePlayers((Lvar1::5),(Lvar2::6))
	IntroAtom Local NoPrior Mono [(I::0)]checkEnd()
	IntroCompre Remote NoPrior Mono (P::7) (Ps::1) [(P::7)]notifyDeath((K::2))
	*/
	protected boolean execute_allplayers_join_ordering_4(AllPlayers act) {
		
		int i;
		SimpMultiset<Integer>  ps;
		int k;
		SimpMultiset<Integer>  cs;
		SimpMultiset<Integer>  ms;
		SimpMultiset<Integer>  lvar1;
		SimpMultiset<Integer>  lvar2;
		int p;
		// Join Task: Active #H0 [(I::0)]allPlayers((Ps::1))
		i = act.loc;
		ps = act.arg1;
		// Join Task: LookupAtom #H1 7:0:hash<[+]isModerator()|.>  (I::0) [(I::0)]isModerator()
		StoreIter<IsModerator> candidates_1 = ismoderator_store_0.lookup_candidates(index0IsModerator(i));
		IsModerator cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int i__1;
			i__1 = cand_1.loc;
			if (true) {
				// Join Task: LookupAtom #H2 2:0:hash<[+]kill(-)|.>  (I::0) [(I::0)]kill((K::2))
				StoreIter<Kill> candidates_2 = kill_store_0.lookup_candidates(index0Kill(i));
				Kill cand_2 = candidates_2.get_next_alive();
				while(cand_2 != null) {
					int i__2;
					i__2 = cand_2.loc;
					k = cand_2.arg1;
					if (true) {
						// Join Task: LookupAtom #H3 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::3),(Ms::4))
						StoreIter<LivePlayers> candidates_3 = liveplayers_store_0.lookup_candidates(index0LivePlayers(i));
						LivePlayers cand_3 = candidates_3.get_next_alive();
						while(cand_3 != null) {
							int i__3;
							i__3 = cand_3.loc;
							cs = cand_3.arg1;
							ms = cand_3.arg2;
							if (true) {
								// Join Task: DeleteHead #H2
								kill_store_0.remove( cand_2 );
								// Join Task: DeleteHead #H3
								liveplayers_store_0.remove( cand_3 );
								// Join Task: LetBind (Lvar1::5) diff(((Cs::3),{(K::2)}))
								Integer[] temp9 = { k };
								lvar1 = ExtLib.diff(cs,Misc.to_mset(temp9));
								;
								// Join Task: LetBind (Lvar2::6) diff(((Ms::4),{(K::2)}))
								Integer[] temp10 = { k };
								lvar2 = ExtLib.diff(ms,Misc.to_mset(temp10));
								;
								// Join Task: IntroAtom Local NoPrior Mono [(I::0)]livePlayers((Lvar1::5),(Lvar2::6))
								intro( new LivePlayers(i,lvar1,lvar2) );
								// Join Task: IntroAtom Local NoPrior Mono [(I::0)]checkEnd()
								intro( new CheckEnd(i) );
								// Join Task: IntroCompre Remote NoPrior Mono (P::7) (Ps::1) [(P::7)]notifyDeath((K::2))
								SimpMultiset<Integer>  comp_0 = ps;
								for(int idx=0; idx<comp_0.size(); idx++) {
									p = comp_0.get(idx);
									send( new NotifyDeath(p,k) ); 
								}
								kill_rule_count++;
							}
							cand_3 = candidates_3.get_next_alive();
						}
					}
					cand_2 = candidates_2.get_next_alive();
				}
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule end1 ****
	Rule Head Variables: (I::0), (Ps::1), (Cs::2), (Ms::3)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]allPlayers((Ps::1))
	LookupAtom #H1 17:0:hash<[+]checkEnd()|.>  (I::0) [(I::0)]checkEnd()
	LookupAtom #H2 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::2),(Ms::3))
	CheckGuard size((Ms::3)) >= size((Cs::2))
	DeleteHead #H1
	IntroCompre Remote NoPrior Mono (P::4) (Ps::1) [(P::4)]notifyMafiaWin()
	*/
	protected boolean execute_allplayers_join_ordering_5(AllPlayers act) {
		
		int i;
		SimpMultiset<Integer>  ps;
		SimpMultiset<Integer>  cs;
		SimpMultiset<Integer>  ms;
		int p;
		// Join Task: Active #H0 [(I::0)]allPlayers((Ps::1))
		i = act.loc;
		ps = act.arg1;
		// Join Task: LookupAtom #H1 17:0:hash<[+]checkEnd()|.>  (I::0) [(I::0)]checkEnd()
		StoreIter<CheckEnd> candidates_1 = checkend_store_0.lookup_candidates(index0CheckEnd(i));
		CheckEnd cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int i__1;
			i__1 = cand_1.loc;
			if (true) {
				// Join Task: LookupAtom #H2 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::2),(Ms::3))
				StoreIter<LivePlayers> candidates_2 = liveplayers_store_0.lookup_candidates(index0LivePlayers(i));
				LivePlayers cand_2 = candidates_2.get_next_alive();
				while(cand_2 != null) {
					int i__2;
					i__2 = cand_2.loc;
					cs = cand_2.arg1;
					ms = cand_2.arg2;
					if (true) {
						// Join Task: CheckGuard size((Ms::3)) >= size((Cs::2))
						if (ExtLib.size(ms) >= ExtLib.size(cs)) {
							// Join Task: DeleteHead #H1
							checkend_store_0.remove( cand_1 );
							// Join Task: IntroCompre Remote NoPrior Mono (P::4) (Ps::1) [(P::4)]notifyMafiaWin()
							SimpMultiset<Integer>  comp_0 = ps;
							for(int idx=0; idx<comp_0.size(); idx++) {
								p = comp_0.get(idx);
								send( new NotifyMafiaWin(p) ); 
							}
							end1_rule_count++;
						}
					}
					cand_2 = candidates_2.get_next_alive();
				}
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule end2 ****
	Rule Head Variables: (I::0), (Ps::1), (Cs::2), (Ms::3)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]allPlayers((Ps::1))
	LookupAtom #H1 17:0:hash<[+]checkEnd()|.>  (I::0) [(I::0)]checkEnd()
	LookupAtom #H2 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::2),(Ms::3))
	CheckGuard size((Ms::3)) == 0
	DeleteHead #H1
	IntroCompre Remote NoPrior Mono (P::4) (Ps::1) [(P::4)]notifyCitizensWin()
	*/
	protected boolean execute_allplayers_join_ordering_6(AllPlayers act) {
		
		int i;
		SimpMultiset<Integer>  ps;
		SimpMultiset<Integer>  cs;
		SimpMultiset<Integer>  ms;
		int p;
		// Join Task: Active #H0 [(I::0)]allPlayers((Ps::1))
		i = act.loc;
		ps = act.arg1;
		// Join Task: LookupAtom #H1 17:0:hash<[+]checkEnd()|.>  (I::0) [(I::0)]checkEnd()
		StoreIter<CheckEnd> candidates_1 = checkend_store_0.lookup_candidates(index0CheckEnd(i));
		CheckEnd cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int i__1;
			i__1 = cand_1.loc;
			if (true) {
				// Join Task: LookupAtom #H2 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::2),(Ms::3))
				StoreIter<LivePlayers> candidates_2 = liveplayers_store_0.lookup_candidates(index0LivePlayers(i));
				LivePlayers cand_2 = candidates_2.get_next_alive();
				while(cand_2 != null) {
					int i__2;
					i__2 = cand_2.loc;
					cs = cand_2.arg1;
					ms = cand_2.arg2;
					if (true) {
						// Join Task: CheckGuard size((Ms::3)) == 0
						if (Equality.is_eq(ExtLib.size(ms),0)) {
							// Join Task: DeleteHead #H1
							checkend_store_0.remove( cand_1 );
							// Join Task: IntroCompre Remote NoPrior Mono (P::4) (Ps::1) [(P::4)]notifyCitizensWin()
							SimpMultiset<Integer>  comp_0 = ps;
							for(int idx=0; idx<comp_0.size(); idx++) {
								p = comp_0.get(idx);
								send( new NotifyCitizensWin(p) ); 
							}
							end2_rule_count++;
						}
					}
					cand_2 = candidates_2.get_next_alive();
				}
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 2 Join Ordering of Rule mvote ****
	Rule Head Variables: (X::0), (Ms::1), (I::2), (C::3)
	Rule Head Compre Binders: 
	Active #H0 [(X::0)]allMafia((Ms::1))
	LookupAtom #H1 8:0:hash<[+]isMafia()|.>  (X::0) [(X::0)]isMafia()
	LookupAtom #H2 3:0:hash<[+]mafiaChangedVote(-)|.>  (X::0) [(X::0)]mafiaChangedVote((C::3))
	LookupAtom #H3 6:1:hash<[+]moderator(-)|.>  (X::0) [(X::0)]moderator((I::2))
	DeleteHead #H2
	IntroCompre Remote NoPrior Mono (M::4) union(({(I::2)},(Ms::1))) [(M::4)]notifyMafiaChangedVote((X::0),(C::3))
	*/
	protected boolean execute_allmafia_join_ordering_1(AllMafia act) {
		
		int x;
		SimpMultiset<Integer>  ms;
		int i;
		int c;
		int m;
		// Join Task: Active #H0 [(X::0)]allMafia((Ms::1))
		x = act.loc;
		ms = act.arg1;
		// Join Task: LookupAtom #H1 8:0:hash<[+]isMafia()|.>  (X::0) [(X::0)]isMafia()
		StoreIter<IsMafia> candidates_1 = ismafia_store_0.lookup_candidates(index0IsMafia(x));
		IsMafia cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int x__1;
			x__1 = cand_1.loc;
			if (true) {
				// Join Task: LookupAtom #H2 3:0:hash<[+]mafiaChangedVote(-)|.>  (X::0) [(X::0)]mafiaChangedVote((C::3))
				StoreIter<MafiaChangedVote> candidates_2 = mafiachangedvote_store_0.lookup_candidates(index0MafiaChangedVote(x));
				MafiaChangedVote cand_2 = candidates_2.get_next_alive();
				while(cand_2 != null) {
					int x__2;
					x__2 = cand_2.loc;
					c = cand_2.arg1;
					if (true) {
						// Join Task: LookupAtom #H3 6:1:hash<[+]moderator(-)|.>  (X::0) [(X::0)]moderator((I::2))
						StoreIter<Moderator> candidates_3 = moderator_store_1.lookup_candidates(index1Moderator(x));
						Moderator cand_3 = candidates_3.get_next();
						while(cand_3 != null) {
							int x__3;
							x__3 = cand_3.loc;
							i = cand_3.arg1;
							if (true) {
								// Join Task: DeleteHead #H2
								mafiachangedvote_store_0.remove( cand_2 );
								// Join Task: IntroCompre Remote NoPrior Mono (M::4) union(({(I::2)},(Ms::1))) [(M::4)]notifyMafiaChangedVote((X::0),(C::3))
								Integer[] temp11 = { i };
								SimpMultiset<Integer>  comp_0 = ExtLib.union(Misc.to_mset(temp11),ms);
								for(int idx=0; idx<comp_0.size(); idx++) {
									m = comp_0.get(idx);
									send( new NotifyMafiaChangedVote(m,x,c) ); 
								}
								mvote_rule_count++;
							}
							cand_3 = candidates_3.get_next();
						}
					}
					cand_2 = candidates_2.get_next_alive();
				}
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule night ****
	Rule Head Variables: (I::0), (Ps::1), (D::2), (Cs::3), (Ms::4), (Night::5), (IsFirst::6)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]trans((Night::5),(IsFirst::6))
	CheckGuard (Night::5)
	LookupAtom #H1 12:0:hash<[+]allPlayers(-)|.>  (I::0) [(I::0)]allPlayers((Ps::1))
	LookupAtom #H2 10:0:hash<[+]duration(-)|.>  (I::0) [(I::0)]duration((D::2))
	LookupAtom #H3 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::3),(Ms::4))
	DeleteHead #H0
	LetBind (TimeWarn::7) addSeconds((timeNow(1),1))
	LetBind (TimeNight::8) addSeconds(((TimeWarn::7),10))
	LetBind (TimeWake::9) addSeconds(((TimeNight::8),5))
	LetBind (TimeNext::10) addSeconds((addSeconds(((TimeNight::8),(D::2))),0 - 11))
	IntroAtom Local NoPrior Mono [(I::0)]notifyCheckVotes((Ms::4),(TimeNext::10),(IsFirst::6))
	IntroCompre Remote NoPrior Mono (P::11) (Ps::1) [(P::11)]warnNight((TimeWarn::7))
	IntroCompre Remote NoPrior Mono (M::12) (Ms::4) [(M::12)]wakeMafia((TimeWake::9))
	*/
	protected boolean execute_trans_join_ordering_1(Trans act) {
		
		int i;
		SimpMultiset<Integer>  ps;
		int d;
		SimpMultiset<Integer>  cs;
		SimpMultiset<Integer>  ms;
		boolean night;
		boolean isfirst;
		long timewarn;
		long timenight;
		long timewake;
		long timenext;
		int p;
		int m;
		// Join Task: Active #H0 [(I::0)]trans((Night::5),(IsFirst::6))
		i = act.loc;
		night = act.arg1;
		isfirst = act.arg2;
		// Join Task: CheckGuard (Night::5)
		if (night) {
			// Join Task: LookupAtom #H1 12:0:hash<[+]allPlayers(-)|.>  (I::0) [(I::0)]allPlayers((Ps::1))
			StoreIter<AllPlayers> candidates_1 = allplayers_store_0.lookup_candidates(index0AllPlayers(i));
			AllPlayers cand_1 = candidates_1.get_next();
			while(cand_1 != null) {
				int i__1;
				i__1 = cand_1.loc;
				ps = cand_1.arg1;
				if (true) {
					// Join Task: LookupAtom #H2 10:0:hash<[+]duration(-)|.>  (I::0) [(I::0)]duration((D::2))
					StoreIter<Duration> candidates_2 = duration_store_0.lookup_candidates(index0Duration(i));
					Duration cand_2 = candidates_2.get_next();
					while(cand_2 != null) {
						int i__2;
						i__2 = cand_2.loc;
						d = cand_2.arg1;
						if (true) {
							// Join Task: LookupAtom #H3 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::3),(Ms::4))
							StoreIter<LivePlayers> candidates_3 = liveplayers_store_0.lookup_candidates(index0LivePlayers(i));
							LivePlayers cand_3 = candidates_3.get_next_alive();
							while(cand_3 != null) {
								int i__3;
								i__3 = cand_3.loc;
								cs = cand_3.arg1;
								ms = cand_3.arg2;
								if (true) {
									// Join Task: DeleteHead #H0
									// H0 is active and monotone, no delete required
									// Join Task: LetBind (TimeWarn::7) addSeconds((timeNow(1),1))
									timewarn = ExtLib.addSeconds(ExtLib.timeNow(1),1);
									;
									// Join Task: LetBind (TimeNight::8) addSeconds(((TimeWarn::7),10))
									timenight = ExtLib.addSeconds(timewarn,10);
									;
									// Join Task: LetBind (TimeWake::9) addSeconds(((TimeNight::8),5))
									timewake = ExtLib.addSeconds(timenight,5);
									;
									// Join Task: LetBind (TimeNext::10) addSeconds((addSeconds(((TimeNight::8),(D::2))),0 - 11))
									timenext = ExtLib.addSeconds(ExtLib.addSeconds(timenight,d),0 - 11);
									;
									// Join Task: IntroAtom Local NoPrior Mono [(I::0)]notifyCheckVotes((Ms::4),(TimeNext::10),(IsFirst::6))
									intro( new NotifyCheckVotes(i,ms,timenext,isfirst) );
									// Join Task: IntroCompre Remote NoPrior Mono (P::11) (Ps::1) [(P::11)]warnNight((TimeWarn::7))
									SimpMultiset<Integer>  comp_0 = ps;
									for(int idx=0; idx<comp_0.size(); idx++) {
										p = comp_0.get(idx);
										send( new WarnNight(p,timewarn) ); 
										send( new SignalNight(p,timenight) ); 
									}
									// Join Task: IntroCompre Remote NoPrior Mono (M::12) (Ms::4) [(M::12)]wakeMafia((TimeWake::9))
									SimpMultiset<Integer>  comp_1 = ms;
									for(int idx=0; idx<comp_1.size(); idx++) {
										m = comp_1.get(idx);
										send( new WakeMafia(m,timewake) ); 
									}
									night_rule_count++;
									return false;
								}
								cand_3 = candidates_3.get_next_alive();
							}
						}
						cand_2 = candidates_2.get_next();
					}
				}
				cand_1 = candidates_1.get_next();
			}
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule day ****
	Rule Head Variables: (I::0), (Ps::1), (D::2), (Cs::3), (Ms::4), (Night::5), (IsFirst::6)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]trans((Night::5),(IsFirst::6))
	CheckGuard not((Night::5))
	LookupAtom #H1 12:0:hash<[+]allPlayers(-)|.>  (I::0) [(I::0)]allPlayers((Ps::1))
	LookupAtom #H2 10:0:hash<[+]duration(-)|.>  (I::0) [(I::0)]duration((D::2))
	LookupAtom #H3 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::3),(Ms::4))
	DeleteHead #H0
	LetBind (TimeWarn::7) addSeconds((timeNow(1),1))
	LetBind (TimeDay::8) addSeconds(((TimeWarn::7),10))
	LetBind (TimeNext::9) addSeconds((addSeconds(((TimeDay::8),(D::2))),0 - 11))
	LetBind (Lvar0::10) union(((Ms::4),(Cs::3)))
	IntroAtom Local NoPrior Mono [(I::0)]notifyCheckVotes((Lvar0::10),(TimeNext::9),(IsFirst::6))
	IntroCompre Remote NoPrior Mono (P::11) (Ps::1) [(P::11)]warnDay((TimeWarn::7))
	*/
	protected boolean execute_trans_join_ordering_2(Trans act) {
		
		int i;
		SimpMultiset<Integer>  ps;
		int d;
		SimpMultiset<Integer>  cs;
		SimpMultiset<Integer>  ms;
		boolean night;
		boolean isfirst;
		long timewarn;
		long timeday;
		long timenext;
		SimpMultiset<Integer>  lvar0;
		int p;
		// Join Task: Active #H0 [(I::0)]trans((Night::5),(IsFirst::6))
		i = act.loc;
		night = act.arg1;
		isfirst = act.arg2;
		// Join Task: CheckGuard not((Night::5))
		if (ExtLib.not(night)) {
			// Join Task: LookupAtom #H1 12:0:hash<[+]allPlayers(-)|.>  (I::0) [(I::0)]allPlayers((Ps::1))
			StoreIter<AllPlayers> candidates_1 = allplayers_store_0.lookup_candidates(index0AllPlayers(i));
			AllPlayers cand_1 = candidates_1.get_next();
			while(cand_1 != null) {
				int i__1;
				i__1 = cand_1.loc;
				ps = cand_1.arg1;
				if (true) {
					// Join Task: LookupAtom #H2 10:0:hash<[+]duration(-)|.>  (I::0) [(I::0)]duration((D::2))
					StoreIter<Duration> candidates_2 = duration_store_0.lookup_candidates(index0Duration(i));
					Duration cand_2 = candidates_2.get_next();
					while(cand_2 != null) {
						int i__2;
						i__2 = cand_2.loc;
						d = cand_2.arg1;
						if (true) {
							// Join Task: LookupAtom #H3 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::3),(Ms::4))
							StoreIter<LivePlayers> candidates_3 = liveplayers_store_0.lookup_candidates(index0LivePlayers(i));
							LivePlayers cand_3 = candidates_3.get_next_alive();
							while(cand_3 != null) {
								int i__3;
								i__3 = cand_3.loc;
								cs = cand_3.arg1;
								ms = cand_3.arg2;
								if (true) {
									// Join Task: DeleteHead #H0
									// H0 is active and monotone, no delete required
									// Join Task: LetBind (TimeWarn::7) addSeconds((timeNow(1),1))
									timewarn = ExtLib.addSeconds(ExtLib.timeNow(1),1);
									;
									// Join Task: LetBind (TimeDay::8) addSeconds(((TimeWarn::7),10))
									timeday = ExtLib.addSeconds(timewarn,10);
									;
									// Join Task: LetBind (TimeNext::9) addSeconds((addSeconds(((TimeDay::8),(D::2))),0 - 11))
									timenext = ExtLib.addSeconds(ExtLib.addSeconds(timeday,d),0 - 11);
									;
									// Join Task: LetBind (Lvar0::10) union(((Ms::4),(Cs::3)))
									lvar0 = ExtLib.union(ms,cs);
									;
									// Join Task: IntroAtom Local NoPrior Mono [(I::0)]notifyCheckVotes((Lvar0::10),(TimeNext::9),(IsFirst::6))
									intro( new NotifyCheckVotes(i,lvar0,timenext,isfirst) );
									// Join Task: IntroCompre Remote NoPrior Mono (P::11) (Ps::1) [(P::11)]warnDay((TimeWarn::7))
									SimpMultiset<Integer>  comp_0 = ps;
									for(int idx=0; idx<comp_0.size(); idx++) {
										p = comp_0.get(idx);
										send( new WarnDay(p,timewarn) ); 
										send( new SignalDay(p,timeday) ); 
									}
									day_rule_count++;
									return false;
								}
								cand_3 = candidates_3.get_next_alive();
							}
						}
						cand_2 = candidates_2.get_next();
					}
				}
				cand_1 = candidates_1.get_next();
			}
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule cont ****
	Rule Head Variables: (I::0), (Cs::1), (Ms::2), (Night::3)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]cycle((Night::3))
	LookupAtom #H1 17:0:hash<[+]checkEnd()|.>  (I::0) [(I::0)]checkEnd()
	LookupAtom #H2 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::1),(Ms::2))
	CheckGuard size((Ms::2)) < size((Cs::1))
	CheckGuard size((Ms::2)) > 0
	DeleteHead #H0
	DeleteHead #H1
	LetBind (Lvar3::4) not((Night::3))
	LetBind (Lvar4::5) not((Night::3))
	IntroAtom Local NoPrior Mono [(I::0)]trans((Lvar3::4),false)
	IntroAtom Local NoPrior Mono [(I::0)]cycle((Lvar4::5))
	*/
	protected boolean execute_cycle_join_ordering_1(Cycle act) {
		
		int i;
		SimpMultiset<Integer>  cs;
		SimpMultiset<Integer>  ms;
		boolean night;
		boolean lvar3;
		boolean lvar4;
		// Join Task: Active #H0 [(I::0)]cycle((Night::3))
		i = act.loc;
		night = act.arg1;
		// Join Task: LookupAtom #H1 17:0:hash<[+]checkEnd()|.>  (I::0) [(I::0)]checkEnd()
		StoreIter<CheckEnd> candidates_1 = checkend_store_0.lookup_candidates(index0CheckEnd(i));
		CheckEnd cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int i__1;
			i__1 = cand_1.loc;
			if (true) {
				// Join Task: LookupAtom #H2 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::1),(Ms::2))
				StoreIter<LivePlayers> candidates_2 = liveplayers_store_0.lookup_candidates(index0LivePlayers(i));
				LivePlayers cand_2 = candidates_2.get_next_alive();
				while(cand_2 != null) {
					int i__2;
					i__2 = cand_2.loc;
					cs = cand_2.arg1;
					ms = cand_2.arg2;
					if (true) {
						// Join Task: CheckGuard size((Ms::2)) < size((Cs::1))
						if (ExtLib.size(ms) < ExtLib.size(cs)) {
							// Join Task: CheckGuard size((Ms::2)) > 0
							if (ExtLib.size(ms) > 0) {
								// Join Task: DeleteHead #H0
								// H0 is active and monotone, no delete required
								// Join Task: DeleteHead #H1
								checkend_store_0.remove( cand_1 );
								// Join Task: LetBind (Lvar3::4) not((Night::3))
								lvar3 = ExtLib.not(night);
								;
								// Join Task: LetBind (Lvar4::5) not((Night::3))
								lvar4 = ExtLib.not(night);
								;
								// Join Task: IntroAtom Local NoPrior Mono [(I::0)]trans((Lvar3::4),false)
								intro( new Trans(i,lvar3,false) );
								// Join Task: IntroAtom Local NoPrior Mono [(I::0)]cycle((Lvar4::5))
								intro( new Cycle(i,lvar4) );
								cont_rule_count++;
								return false;
							}
						}
					}
					cand_2 = candidates_2.get_next_alive();
				}
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule end1 ****
	Rule Head Variables: (I::0), (Ps::1), (Cs::2), (Ms::3)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]checkEnd()
	LookupAtom #H1 12:0:hash<[+]allPlayers(-)|.>  (I::0) [(I::0)]allPlayers((Ps::1))
	LookupAtom #H2 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::2),(Ms::3))
	CheckGuard size((Ms::3)) >= size((Cs::2))
	DeleteHead #H0
	IntroCompre Remote NoPrior Mono (P::4) (Ps::1) [(P::4)]notifyMafiaWin()
	*/
	protected boolean execute_checkend_join_ordering_1(CheckEnd act) {
		
		int i;
		SimpMultiset<Integer>  ps;
		SimpMultiset<Integer>  cs;
		SimpMultiset<Integer>  ms;
		int p;
		// Join Task: Active #H0 [(I::0)]checkEnd()
		i = act.loc;
		// Join Task: LookupAtom #H1 12:0:hash<[+]allPlayers(-)|.>  (I::0) [(I::0)]allPlayers((Ps::1))
		StoreIter<AllPlayers> candidates_1 = allplayers_store_0.lookup_candidates(index0AllPlayers(i));
		AllPlayers cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int i__1;
			i__1 = cand_1.loc;
			ps = cand_1.arg1;
			if (true) {
				// Join Task: LookupAtom #H2 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::2),(Ms::3))
				StoreIter<LivePlayers> candidates_2 = liveplayers_store_0.lookup_candidates(index0LivePlayers(i));
				LivePlayers cand_2 = candidates_2.get_next_alive();
				while(cand_2 != null) {
					int i__2;
					i__2 = cand_2.loc;
					cs = cand_2.arg1;
					ms = cand_2.arg2;
					if (true) {
						// Join Task: CheckGuard size((Ms::3)) >= size((Cs::2))
						if (ExtLib.size(ms) >= ExtLib.size(cs)) {
							// Join Task: DeleteHead #H0
							// H0 is active and monotone, no delete required
							// Join Task: IntroCompre Remote NoPrior Mono (P::4) (Ps::1) [(P::4)]notifyMafiaWin()
							SimpMultiset<Integer>  comp_0 = ps;
							for(int idx=0; idx<comp_0.size(); idx++) {
								p = comp_0.get(idx);
								send( new NotifyMafiaWin(p) ); 
							}
							end1_rule_count++;
							return false;
						}
					}
					cand_2 = candidates_2.get_next_alive();
				}
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule end2 ****
	Rule Head Variables: (I::0), (Ps::1), (Cs::2), (Ms::3)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]checkEnd()
	LookupAtom #H1 12:0:hash<[+]allPlayers(-)|.>  (I::0) [(I::0)]allPlayers((Ps::1))
	LookupAtom #H2 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::2),(Ms::3))
	CheckGuard size((Ms::3)) == 0
	DeleteHead #H0
	IntroCompre Remote NoPrior Mono (P::4) (Ps::1) [(P::4)]notifyCitizensWin()
	*/
	protected boolean execute_checkend_join_ordering_2(CheckEnd act) {
		
		int i;
		SimpMultiset<Integer>  ps;
		SimpMultiset<Integer>  cs;
		SimpMultiset<Integer>  ms;
		int p;
		// Join Task: Active #H0 [(I::0)]checkEnd()
		i = act.loc;
		// Join Task: LookupAtom #H1 12:0:hash<[+]allPlayers(-)|.>  (I::0) [(I::0)]allPlayers((Ps::1))
		StoreIter<AllPlayers> candidates_1 = allplayers_store_0.lookup_candidates(index0AllPlayers(i));
		AllPlayers cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int i__1;
			i__1 = cand_1.loc;
			ps = cand_1.arg1;
			if (true) {
				// Join Task: LookupAtom #H2 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::2),(Ms::3))
				StoreIter<LivePlayers> candidates_2 = liveplayers_store_0.lookup_candidates(index0LivePlayers(i));
				LivePlayers cand_2 = candidates_2.get_next_alive();
				while(cand_2 != null) {
					int i__2;
					i__2 = cand_2.loc;
					cs = cand_2.arg1;
					ms = cand_2.arg2;
					if (true) {
						// Join Task: CheckGuard size((Ms::3)) == 0
						if (Equality.is_eq(ExtLib.size(ms),0)) {
							// Join Task: DeleteHead #H0
							// H0 is active and monotone, no delete required
							// Join Task: IntroCompre Remote NoPrior Mono (P::4) (Ps::1) [(P::4)]notifyCitizensWin()
							SimpMultiset<Integer>  comp_0 = ps;
							for(int idx=0; idx<comp_0.size(); idx++) {
								p = comp_0.get(idx);
								send( new NotifyCitizensWin(p) ); 
							}
							end2_rule_count++;
							return false;
						}
					}
					cand_2 = candidates_2.get_next_alive();
				}
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule cont ****
	Rule Head Variables: (I::0), (Cs::1), (Ms::2), (Night::3)
	Rule Head Compre Binders: 
	Active #H0 [(I::0)]checkEnd()
	LookupAtom #H1 15:0:hash<[+]cycle(-)|.>  (I::0) [(I::0)]cycle((Night::3))
	LookupAtom #H2 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::1),(Ms::2))
	CheckGuard size((Ms::2)) < size((Cs::1))
	CheckGuard size((Ms::2)) > 0
	DeleteHead #H0
	DeleteHead #H1
	LetBind (Lvar3::4) not((Night::3))
	LetBind (Lvar4::5) not((Night::3))
	IntroAtom Local NoPrior Mono [(I::0)]trans((Lvar3::4),false)
	IntroAtom Local NoPrior Mono [(I::0)]cycle((Lvar4::5))
	*/
	protected boolean execute_checkend_join_ordering_3(CheckEnd act) {
		
		int i;
		SimpMultiset<Integer>  cs;
		SimpMultiset<Integer>  ms;
		boolean night;
		boolean lvar3;
		boolean lvar4;
		// Join Task: Active #H0 [(I::0)]checkEnd()
		i = act.loc;
		// Join Task: LookupAtom #H1 15:0:hash<[+]cycle(-)|.>  (I::0) [(I::0)]cycle((Night::3))
		StoreIter<Cycle> candidates_1 = cycle_store_0.lookup_candidates(index0Cycle(i));
		Cycle cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int i__1;
			i__1 = cand_1.loc;
			night = cand_1.arg1;
			if (true) {
				// Join Task: LookupAtom #H2 11:0:hash<[+]livePlayers(-,-)|.>  (I::0) [(I::0)]livePlayers((Cs::1),(Ms::2))
				StoreIter<LivePlayers> candidates_2 = liveplayers_store_0.lookup_candidates(index0LivePlayers(i));
				LivePlayers cand_2 = candidates_2.get_next_alive();
				while(cand_2 != null) {
					int i__2;
					i__2 = cand_2.loc;
					cs = cand_2.arg1;
					ms = cand_2.arg2;
					if (true) {
						// Join Task: CheckGuard size((Ms::2)) < size((Cs::1))
						if (ExtLib.size(ms) < ExtLib.size(cs)) {
							// Join Task: CheckGuard size((Ms::2)) > 0
							if (ExtLib.size(ms) > 0) {
								// Join Task: DeleteHead #H0
								// H0 is active and monotone, no delete required
								// Join Task: DeleteHead #H1
								cycle_store_0.remove( cand_1 );
								// Join Task: LetBind (Lvar3::4) not((Night::3))
								lvar3 = ExtLib.not(night);
								;
								// Join Task: LetBind (Lvar4::5) not((Night::3))
								lvar4 = ExtLib.not(night);
								;
								// Join Task: IntroAtom Local NoPrior Mono [(I::0)]trans((Lvar3::4),false)
								intro( new Trans(i,lvar3,false) );
								// Join Task: IntroAtom Local NoPrior Mono [(I::0)]cycle((Lvar4::5))
								intro( new Cycle(i,lvar4) );
								cont_rule_count++;
								return false;
							}
						}
					}
					cand_2 = candidates_2.get_next_alive();
				}
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	

	protected void execute(Initialize initialize) {
		if( execute_initialize_join_ordering_1(initialize) ) {
			store( initialize );
		}
	}
	
	protected void execute(Start start) {
		if( execute_start_join_ordering_1(start) ) {
			store( start );
		}
	}
	
	protected void execute(Kill kill) {
		if( execute_kill_join_ordering_1(kill) ) {
			store( kill );
		}
	}
	
	protected void execute(MafiaChangedVote mafiachangedvote) {
		if( execute_mafiachangedvote_join_ordering_1(mafiachangedvote) ) {
			store( mafiachangedvote );
		}
	}
	
	protected void execute(CitizenChangedVote citizenchangedvote) {
		if( execute_citizenchangedvote_join_ordering_1(citizenchangedvote) ) {
			store( citizenchangedvote );
		}
	}
	
	protected void execute(Mark mark) {
		if( execute_mark_join_ordering_1(mark) ) {
			store( mark );
		}
	}
	
	protected void execute(Moderator moderator) {
		execute_moderator_join_ordering_1( moderator );
		execute_moderator_join_ordering_2( moderator );
		store( moderator );
	}
	
	protected void execute(IsModerator ismoderator) {
		execute_ismoderator_join_ordering_1( ismoderator );
		execute_ismoderator_join_ordering_2( ismoderator );
		store( ismoderator );
	}
	
	protected void execute(IsMafia ismafia) {
		execute_ismafia_join_ordering_1( ismafia );
		store( ismafia );
	}
	
	protected void execute(IsCitizen iscitizen) {
		store( iscitizen );
	}
	
	protected void execute(Duration duration) {
		execute_duration_join_ordering_1( duration );
		execute_duration_join_ordering_2( duration );
		store( duration );
	}
	
	protected void execute(LivePlayers liveplayers) {
		execute_liveplayers_join_ordering_1( liveplayers );
		execute_liveplayers_join_ordering_2( liveplayers );
		if( execute_liveplayers_join_ordering_3(liveplayers) ) {
			execute_liveplayers_join_ordering_4( liveplayers );
			execute_liveplayers_join_ordering_5( liveplayers );
			execute_liveplayers_join_ordering_6( liveplayers );
			store( liveplayers );
		}
	}
	
	protected void execute(AllPlayers allplayers) {
		execute_allplayers_join_ordering_1( allplayers );
		execute_allplayers_join_ordering_2( allplayers );
		execute_allplayers_join_ordering_3( allplayers );
		execute_allplayers_join_ordering_4( allplayers );
		execute_allplayers_join_ordering_5( allplayers );
		execute_allplayers_join_ordering_6( allplayers );
		store( allplayers );
	}
	
	protected void execute(AllMafia allmafia) {
		execute_allmafia_join_ordering_1( allmafia );
		store( allmafia );
	}
	
	protected void execute(Trans trans) {
		if( execute_trans_join_ordering_1(trans) ) {
			if( execute_trans_join_ordering_2(trans) ) {
				store( trans );
			}
		}
	}
	
	protected void execute(Cycle cycle) {
		if( execute_cycle_join_ordering_1(cycle) ) {
			store( cycle );
		}
	}
	
	protected void execute(CheckVotes checkvotes) {
		store( checkvotes );
	}
	
	protected void execute(CheckEnd checkend) {
		if( execute_checkend_join_ordering_1(checkend) ) {
			if( execute_checkend_join_ordering_2(checkend) ) {
				if( execute_checkend_join_ordering_3(checkend) ) {
					store( checkend );
				}
			}
		}
	}
	

	@Override
	public void init() {
	}

}


