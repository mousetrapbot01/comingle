import java.util.LinkedList;

import comingle.goals.*;
import comingle.store.*;
import comingle.facts.*;
import comingle.rewrite.*;
import comingle.hash.*;
import comingle.tuple.*;
import comingle.misc.*;





class Shortpath extends RewriteMachine {

	abstract class ShortpathFact extends Fact {
		public ShortpathFact(int l) { super(l); }
		public void execute(Shortpath ensem) { }
	}

	class TransReq extends ShortpathFact {
		public int arg1;
		public int arg2;
	
		public TransReq(int l, int a1, int a2) { super(l); arg1=a1; arg2=a2; }
	
		public int fact_idx() { return 0; }
	
		@Override
		public void execute(Shortpath ensem) { ensem.execute( this ); }
	
		public String toString() { return String.format("[%s]TransReq(%s,%s)",loc,arg1,arg2); }
	}
	
	class Edge extends ShortpathFact {
		public int arg1;
		public int arg2;
	
		public Edge(int l, int a1, int a2) { super(l); arg1=a1; arg2=a2; }
	
		public int fact_idx() { return 1; }
	
		@Override
		public void execute(Shortpath ensem) { ensem.execute( this ); }
	
		public String toString() { return String.format("[%s]Edge(%s,%s)",loc,arg1,arg2); }
	}
	
	class Path extends ShortpathFact {
		public int arg1;
		public int arg2;
	
		public Path(int l, int a1, int a2) { super(l); arg1=a1; arg2=a2; }
	
		public int fact_idx() { return 2; }
	
		@Override
		public void execute(Shortpath ensem) { ensem.execute( this ); }
	
		public String toString() { return String.format("[%s]Path(%s,%s)",loc,arg1,arg2); }
	}
	

	protected static int index0TransReq(int loc) {
		return Hash.hash(loc);
	}
	protected static int index0Path(int loc, int arg1) {
		return Hash.join(Hash.hash(loc),Hash.hash(arg1));
	}
	protected static int index1Path(int loc) {
		return Hash.hash(loc);
	}

	protected static final int trans_req_fact_idx = 0;
	protected static final int edge_fact_idx = 1;
	protected static final int path_fact_idx = 2;

	protected Goals<ShortpathFact> goals;

	MultiMapStore<TransReq> transreq_store_0;
	ListStore<TransReq> transreq_store_1;
	ListStore<Edge> edge_store_0;
	MultiMapStore<Path> path_store_0;
	MultiMapStore<Path> path_store_1;
	ListStore<Path> path_store_2;

	protected int base_rule_count;
	protected int elim_rule_count;
	protected int trans_1_rule_count;
	protected int trans_2_rule_count;
	protected int rule_app_misses;

	public Shortpath() {
		super();
	
		base_rule_count = 0;
		elim_rule_count = 0;
		trans_1_rule_count = 0;
		trans_2_rule_count = 0;
		rule_app_misses = 0;
	
		goals = new ListGoals<ShortpathFact>();
		set_goal_component( goals );
	
		transreq_store_0 = new MultiMapStore<TransReq>();
		transreq_store_0.set_name("TransReq Store");
		// set_store_component( transreq_store_0 );
		
		transreq_store_1 = new ListStore<TransReq>();
		transreq_store_1.set_name("TransReq Store");
		// set_store_component( transreq_store_1 );
		
		edge_store_0 = new ListStore<Edge>();
		edge_store_0.set_name("Edge Store");
		// set_store_component( edge_store_0 );
		
		path_store_0 = new MultiMapStore<Path>();
		path_store_0.set_name("Path Store");
		// set_store_component( path_store_0 );
		
		path_store_1 = new MultiMapStore<Path>();
		path_store_1.set_name("Path Store");
		// set_store_component( path_store_1 );
		
		path_store_2 = new ListStore<Path>();
		path_store_2.set_name("Path Store");
		// set_store_component( path_store_2 );
		
	
		set_store_component( transreq_store_1 );
		set_store_component( edge_store_0 );
		set_store_component( path_store_2 );
	}
	

	@Override
	protected boolean rewrite() {
		boolean done_something = false;
		while(goals.has_goals()) {
			goals.next().execute( this );
			done_something = true;
		}
		return done_something;
	}
	
	@Override
	protected boolean rewrite(int max_steps) {
		int count = 0;
		while(goals.has_goals() && count < max_steps) {
			goals.next().execute( this );
			count++;
		}
		return count > 0;
	}

	protected void store(TransReq trans_req) {
		transreq_store_0.add( trans_req, index0TransReq(trans_req.loc) );
		transreq_store_1.add( trans_req );
	} 				
	
	protected void store(Edge edge) {
		edge_store_0.add( edge );
	} 				
	
	protected void store(Path path) {
		path_store_0.add( path, index0Path(path.loc,path.arg1) );
		path_store_1.add( path, index1Path(path.loc) );
		path_store_2.add( path );
	} 				
	
	public void add_trans_req(int loc,int arg1,int arg2) {
		goals.add( new TransReq(loc,arg1,arg2) );
		
		notify_new_goals();
	}
	
	public void add_edge(int loc,int arg1,int arg2) {
		goals.add( new Edge(loc,arg1,arg2) );
		
		notify_new_goals();
	}
	
	public void add_path(int loc,int arg1,int arg2) {
		goals.add( new Path(loc,arg1,arg2) );
		
		notify_new_goals();
	}
	
	

	/*
	**** 0 Join Ordering of Rule trans_2 ****
	Rule Head Variables: Y, X, Z, D2, D1
	Rule Head Compre Binders: 
	Active #H0 [Y]trans_req(X,D1)
	LookupAtom #H1 2:1:hash<[+]path(-,-)|.> Y [Y]path(Z,D2)
	CheckGuard X != Z
	LetBind lvar0 D1 + D2
	IntroAtom Remote NoPrior Mono [X]path(Z,lvar0)
	*/
	protected boolean execute_trans_req_join_ordering_1(TransReq act) {
		
		int y;
		int x;
		int z;
		int d2;
		int d1;
		// Join Task: Active #H0 [Y]trans_req(X,D1)
		y = act.loc;
		x = act.arg1;
		d1 = act.arg2;
		// Join Task: LookupAtom #H1 2:1:hash<[+]path(-,-)|.> Y [Y]path(Z,D2)
		StoreIter<Path> candidates_1 = path_store_1.lookup_candidates(index1Path(y));
		Path cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int y1;
			y1 = cand_1.loc;
			z = cand_1.arg1;
			d2 = cand_1.arg2;
			if (true) {
				// Join Task: CheckGuard X != Z
				if (x != z) {
					// Join Task: LetBind lvar0 D1 + D2
					int lvar0;
					lvar0 = d1 + d2;
					;
					// Join Task: IntroAtom Remote NoPrior Mono [X]path(Z,lvar0)
					goals.add( new Path(x,z,lvar0) );
					trans_2_rule_count++;
				}
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule base ****
	Rule Head Variables: Y, X, D
	Rule Head Compre Binders: 
	Active #H0 [X]edge(Y,D)
	IntroAtom Local NoPrior Mono [X]path(Y,D)
	*/
	protected boolean execute_edge_join_ordering_1(Edge act) {
		
		int y;
		int x;
		int d;
		// Join Task: Active #H0 [X]edge(Y,D)
		x = act.loc;
		y = act.arg1;
		d = act.arg2;
		// Join Task: IntroAtom Local NoPrior Mono [X]path(Y,D)
		goals.add( new Path(x,y,d) );
		base_rule_count++;
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule trans_1 ****
	Rule Head Variables: Y, X, D
	Rule Head Compre Binders: 
	Active #H0 [X]edge(Y,D)
	IntroAtom Remote NoPrior Mono [Y]trans_req(X,D)
	*/
	protected boolean execute_edge_join_ordering_2(Edge act) {
		
		int y;
		int x;
		int d;
		// Join Task: Active #H0 [X]edge(Y,D)
		x = act.loc;
		y = act.arg1;
		d = act.arg2;
		// Join Task: IntroAtom Remote NoPrior Mono [Y]trans_req(X,D)
		goals.add( new TransReq(y,x,d) );
		trans_1_rule_count++;
		return true;
	}
	
	/*
	**** 0 Join Ordering of Rule elim ****
	Rule Head Variables: Y, X, D2, D1
	Rule Head Compre Binders: 
	Active #H0 [X]path(Y,D2)
	LookupAtom #H1 2:0:hash<[+]path(+,-)|.> X,Y [X]path(Y,D1)
	NeqHead #H1 #H0
	CheckGuard D1 <= D2
	DeleteHead #H0
	*/
	protected boolean execute_path_join_ordering_1(Path act) {
		
		int y;
		int x;
		int d2;
		int d1;
		// Join Task: Active #H0 [X]path(Y,D2)
		x = act.loc;
		y = act.arg1;
		d2 = act.arg2;
		// Join Task: LookupAtom #H1 2:0:hash<[+]path(+,-)|.> X,Y [X]path(Y,D1)
		StoreIter<Path> candidates_1 = path_store_0.lookup_candidates(index0Path(x,y));
		Path cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int x1;
			int y1;
			x1 = cand_1.loc;
			y1 = cand_1.arg1;
			d1 = cand_1.arg2;
			if (Equality.is_eq(x,x1) && Equality.is_eq(y,y1)) {
				// Join Task: NeqHead #H1 #H0
				// Join Task: CheckGuard D1 <= D2
				if (d1 <= d2) {
					// Join Task: DeleteHead #H0
					// H0 is active and monotone, no delete required
					elim_rule_count++;
					return false;
				}
			} else {
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule elim ****
	Rule Head Variables: Y, X, D2, D1
	Rule Head Compre Binders: 
	Active #H0 [X]path(Y,D1)
	LookupAtom #H1 2:0:hash<[+]path(+,-)|.> X,Y [X]path(Y,D2)
	NeqHead #H1 #H0
	CheckGuard D1 <= D2
	DeleteHead #H1
	*/
	protected boolean execute_path_join_ordering_2(Path act) {
		
		int y;
		int x;
		int d2;
		int d1;
		// Join Task: Active #H0 [X]path(Y,D1)
		x = act.loc;
		y = act.arg1;
		d1 = act.arg2;
		// Join Task: LookupAtom #H1 2:0:hash<[+]path(+,-)|.> X,Y [X]path(Y,D2)
		StoreIter<Path> candidates_1 = path_store_0.lookup_candidates(index0Path(x,y));
		Path cand_1 = candidates_1.get_next_alive();
		while(cand_1 != null) {
			int x1;
			int y1;
			x1 = cand_1.loc;
			y1 = cand_1.arg1;
			d2 = cand_1.arg2;
			if (Equality.is_eq(x,x1) && Equality.is_eq(y,y1)) {
				// Join Task: NeqHead #H1 #H0
				// Join Task: CheckGuard D1 <= D2
				if (d1 <= d2) {
					// Join Task: DeleteHead #H1
					path_store_0.remove( cand_1 );
					elim_rule_count++;
				}
			} else {
			}
			cand_1 = candidates_1.get_next_alive();
		}
		return true;
	}
	
	/*
	**** 1 Join Ordering of Rule trans_2 ****
	Rule Head Variables: Y, X, Z, D2, D1
	Rule Head Compre Binders: 
	Active #H0 [Y]path(Z,D2)
	LookupAtom #H1 0:0:hash<[+]trans_req(-,-)|.> Y [Y]trans_req(X,D1)
	CheckGuard X != Z
	LetBind lvar0 D1 + D2
	IntroAtom Remote NoPrior Mono [X]path(Z,lvar0)
	*/
	protected boolean execute_path_join_ordering_3(Path act) {
		
		int y;
		int x;
		int z;
		int d2;
		int d1;
		// Join Task: Active #H0 [Y]path(Z,D2)
		y = act.loc;
		z = act.arg1;
		d2 = act.arg2;
		// Join Task: LookupAtom #H1 0:0:hash<[+]trans_req(-,-)|.> Y [Y]trans_req(X,D1)
		StoreIter<TransReq> candidates_1 = transreq_store_0.lookup_candidates(index0TransReq(y));
		TransReq cand_1 = candidates_1.get_next();
		while(cand_1 != null) {
			int y1;
			y1 = cand_1.loc;
			x = cand_1.arg1;
			d1 = cand_1.arg2;
			if (true) {
				// Join Task: CheckGuard X != Z
				if (x != z) {
					// Join Task: LetBind lvar0 D1 + D2
					int lvar0;
					lvar0 = d1 + d2;
					;
					// Join Task: IntroAtom Remote NoPrior Mono [X]path(Z,lvar0)
					goals.add( new Path(x,z,lvar0) );
					trans_2_rule_count++;
				}
			}
			cand_1 = candidates_1.get_next();
		}
		return true;
	}
	

	protected void execute(TransReq trans_req) {
		execute_trans_req_join_ordering_1( trans_req );
		store( trans_req );
	}
	
	protected void execute(Edge edge) {
		execute_edge_join_ordering_1( edge );
		execute_edge_join_ordering_2( edge );
		store( edge );
	}
	
	protected void execute(Path path) {
		if( execute_path_join_ordering_1(path) ) {
			execute_path_join_ordering_2( path );
			execute_path_join_ordering_3( path );
			store( path );
		}
	}

	@Override
	public void init() {
		int l0 = 0;
		int l1 = 1;
		int l2 = 2;
		int l3 = 3;
		int l4 = 4;
		int l5 = 5;
		int l6 = 6;
		int l7 = 7;
		int l8 = 8;
		add_edge(l0,l1,7);
		add_edge(l0,l2,4);
		add_edge(l1,l3,2);
		add_edge(l2,l3,20);
		add_edge(l3,l4,1);
		add_edge(l3,l5,18);
		add_edge(l3,l6,3);
		add_edge(l4,l7,40);
		add_edge(l4,l5,1);
		add_edge(l5,l7,15);
		add_edge(l5,l6,2);
		add_edge(l6,l7,8);
		add_edge(l7,l0,13);
		add_edge(l7,l8,6);
		add_edge(l8,l0,4);
	}
	

	public static void execute_0() {
		Shortpath en = new Shortpath();
		int l0 = 0;
		int l1 = 1;
		int l2 = 2;
		int l3 = 3;
		int l4 = 4;
		int l5 = 5;
		int l6 = 6;
		int l7 = 7;
		int l8 = 8;
		en.add_edge(l0,l1,7);
		en.add_edge(l0,l2,4);
		en.add_edge(l1,l3,2);
		en.add_edge(l2,l3,20);
		en.add_edge(l3,l4,1);
		en.add_edge(l3,l5,18);
		en.add_edge(l3,l6,3);
		en.add_edge(l4,l7,40);
		en.add_edge(l4,l5,1);
		en.add_edge(l5,l7,15);
		en.add_edge(l5,l6,2);
		en.add_edge(l6,l7,8);
		en.add_edge(l7,l0,13);
		en.add_edge(l7,l8,6);
		en.add_edge(l8,l0,4);
		System.out.println("Initial:\n" + en.toString());
		en.start();
		System.out.println("Intermediate:\n" + en.toString());
		en.wait_for_quiescence();
		System.out.println("Final:\n" + en.toString());
		en.stop_rewrite();
	}

	public static void main(String[] args)  { 
		
		execute_0();
	}
	

}


